// Code generated by mockery v2.40.3. DO NOT EDIT.

package mocks

import (
	context "context"

	admin "github.com/flyteorg/flyte/flyteidl/gen/pb-go/flyteidl/admin"

	mock "github.com/stretchr/testify/mock"

	time "time"
)

// ExecutionInterface is an autogenerated mock type for the ExecutionInterface type
type ExecutionInterface struct {
	mock.Mock
}

type ExecutionInterface_Expecter struct {
	mock *mock.Mock
}

func (_m *ExecutionInterface) EXPECT() *ExecutionInterface_Expecter {
	return &ExecutionInterface_Expecter{mock: &_m.Mock}
}

// CreateExecution provides a mock function with given fields: ctx, request, requestedAt
func (_m *ExecutionInterface) CreateExecution(ctx context.Context, request *admin.ExecutionCreateRequest, requestedAt time.Time) (*admin.ExecutionCreateResponse, error) {
	ret := _m.Called(ctx, request, requestedAt)

	if len(ret) == 0 {
		panic("no return value specified for CreateExecution")
	}

	var r0 *admin.ExecutionCreateResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *admin.ExecutionCreateRequest, time.Time) (*admin.ExecutionCreateResponse, error)); ok {
		return rf(ctx, request, requestedAt)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *admin.ExecutionCreateRequest, time.Time) *admin.ExecutionCreateResponse); ok {
		r0 = rf(ctx, request, requestedAt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*admin.ExecutionCreateResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *admin.ExecutionCreateRequest, time.Time) error); ok {
		r1 = rf(ctx, request, requestedAt)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExecutionInterface_CreateExecution_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateExecution'
type ExecutionInterface_CreateExecution_Call struct {
	*mock.Call
}

// CreateExecution is a helper method to define mock.On call
//   - ctx context.Context
//   - request *admin.ExecutionCreateRequest
//   - requestedAt time.Time
func (_e *ExecutionInterface_Expecter) CreateExecution(ctx interface{}, request interface{}, requestedAt interface{}) *ExecutionInterface_CreateExecution_Call {
	return &ExecutionInterface_CreateExecution_Call{Call: _e.mock.On("CreateExecution", ctx, request, requestedAt)}
}

func (_c *ExecutionInterface_CreateExecution_Call) Run(run func(ctx context.Context, request *admin.ExecutionCreateRequest, requestedAt time.Time)) *ExecutionInterface_CreateExecution_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*admin.ExecutionCreateRequest), args[2].(time.Time))
	})
	return _c
}

func (_c *ExecutionInterface_CreateExecution_Call) Return(_a0 *admin.ExecutionCreateResponse, _a1 error) *ExecutionInterface_CreateExecution_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ExecutionInterface_CreateExecution_Call) RunAndReturn(run func(context.Context, *admin.ExecutionCreateRequest, time.Time) (*admin.ExecutionCreateResponse, error)) *ExecutionInterface_CreateExecution_Call {
	_c.Call.Return(run)
	return _c
}

// CreateWorkflowEvent provides a mock function with given fields: ctx, request
func (_m *ExecutionInterface) CreateWorkflowEvent(ctx context.Context, request *admin.WorkflowExecutionEventRequest) (*admin.WorkflowExecutionEventResponse, error) {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for CreateWorkflowEvent")
	}

	var r0 *admin.WorkflowExecutionEventResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *admin.WorkflowExecutionEventRequest) (*admin.WorkflowExecutionEventResponse, error)); ok {
		return rf(ctx, request)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *admin.WorkflowExecutionEventRequest) *admin.WorkflowExecutionEventResponse); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*admin.WorkflowExecutionEventResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *admin.WorkflowExecutionEventRequest) error); ok {
		r1 = rf(ctx, request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExecutionInterface_CreateWorkflowEvent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateWorkflowEvent'
type ExecutionInterface_CreateWorkflowEvent_Call struct {
	*mock.Call
}

// CreateWorkflowEvent is a helper method to define mock.On call
//   - ctx context.Context
//   - request *admin.WorkflowExecutionEventRequest
func (_e *ExecutionInterface_Expecter) CreateWorkflowEvent(ctx interface{}, request interface{}) *ExecutionInterface_CreateWorkflowEvent_Call {
	return &ExecutionInterface_CreateWorkflowEvent_Call{Call: _e.mock.On("CreateWorkflowEvent", ctx, request)}
}

func (_c *ExecutionInterface_CreateWorkflowEvent_Call) Run(run func(ctx context.Context, request *admin.WorkflowExecutionEventRequest)) *ExecutionInterface_CreateWorkflowEvent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*admin.WorkflowExecutionEventRequest))
	})
	return _c
}

func (_c *ExecutionInterface_CreateWorkflowEvent_Call) Return(_a0 *admin.WorkflowExecutionEventResponse, _a1 error) *ExecutionInterface_CreateWorkflowEvent_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ExecutionInterface_CreateWorkflowEvent_Call) RunAndReturn(run func(context.Context, *admin.WorkflowExecutionEventRequest) (*admin.WorkflowExecutionEventResponse, error)) *ExecutionInterface_CreateWorkflowEvent_Call {
	_c.Call.Return(run)
	return _c
}

// GetExecution provides a mock function with given fields: ctx, request
func (_m *ExecutionInterface) GetExecution(ctx context.Context, request *admin.WorkflowExecutionGetRequest) (*admin.Execution, error) {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for GetExecution")
	}

	var r0 *admin.Execution
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *admin.WorkflowExecutionGetRequest) (*admin.Execution, error)); ok {
		return rf(ctx, request)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *admin.WorkflowExecutionGetRequest) *admin.Execution); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*admin.Execution)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *admin.WorkflowExecutionGetRequest) error); ok {
		r1 = rf(ctx, request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExecutionInterface_GetExecution_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetExecution'
type ExecutionInterface_GetExecution_Call struct {
	*mock.Call
}

// GetExecution is a helper method to define mock.On call
//   - ctx context.Context
//   - request *admin.WorkflowExecutionGetRequest
func (_e *ExecutionInterface_Expecter) GetExecution(ctx interface{}, request interface{}) *ExecutionInterface_GetExecution_Call {
	return &ExecutionInterface_GetExecution_Call{Call: _e.mock.On("GetExecution", ctx, request)}
}

func (_c *ExecutionInterface_GetExecution_Call) Run(run func(ctx context.Context, request *admin.WorkflowExecutionGetRequest)) *ExecutionInterface_GetExecution_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*admin.WorkflowExecutionGetRequest))
	})
	return _c
}

func (_c *ExecutionInterface_GetExecution_Call) Return(_a0 *admin.Execution, _a1 error) *ExecutionInterface_GetExecution_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ExecutionInterface_GetExecution_Call) RunAndReturn(run func(context.Context, *admin.WorkflowExecutionGetRequest) (*admin.Execution, error)) *ExecutionInterface_GetExecution_Call {
	_c.Call.Return(run)
	return _c
}

// GetExecutionData provides a mock function with given fields: ctx, request
func (_m *ExecutionInterface) GetExecutionData(ctx context.Context, request *admin.WorkflowExecutionGetDataRequest) (*admin.WorkflowExecutionGetDataResponse, error) {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for GetExecutionData")
	}

	var r0 *admin.WorkflowExecutionGetDataResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *admin.WorkflowExecutionGetDataRequest) (*admin.WorkflowExecutionGetDataResponse, error)); ok {
		return rf(ctx, request)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *admin.WorkflowExecutionGetDataRequest) *admin.WorkflowExecutionGetDataResponse); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*admin.WorkflowExecutionGetDataResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *admin.WorkflowExecutionGetDataRequest) error); ok {
		r1 = rf(ctx, request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExecutionInterface_GetExecutionData_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetExecutionData'
type ExecutionInterface_GetExecutionData_Call struct {
	*mock.Call
}

// GetExecutionData is a helper method to define mock.On call
//   - ctx context.Context
//   - request *admin.WorkflowExecutionGetDataRequest
func (_e *ExecutionInterface_Expecter) GetExecutionData(ctx interface{}, request interface{}) *ExecutionInterface_GetExecutionData_Call {
	return &ExecutionInterface_GetExecutionData_Call{Call: _e.mock.On("GetExecutionData", ctx, request)}
}

func (_c *ExecutionInterface_GetExecutionData_Call) Run(run func(ctx context.Context, request *admin.WorkflowExecutionGetDataRequest)) *ExecutionInterface_GetExecutionData_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*admin.WorkflowExecutionGetDataRequest))
	})
	return _c
}

func (_c *ExecutionInterface_GetExecutionData_Call) Return(_a0 *admin.WorkflowExecutionGetDataResponse, _a1 error) *ExecutionInterface_GetExecutionData_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ExecutionInterface_GetExecutionData_Call) RunAndReturn(run func(context.Context, *admin.WorkflowExecutionGetDataRequest) (*admin.WorkflowExecutionGetDataResponse, error)) *ExecutionInterface_GetExecutionData_Call {
	_c.Call.Return(run)
	return _c
}

// ListExecutions provides a mock function with given fields: ctx, request
func (_m *ExecutionInterface) ListExecutions(ctx context.Context, request *admin.ResourceListRequest) (*admin.ExecutionList, error) {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for ListExecutions")
	}

	var r0 *admin.ExecutionList
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *admin.ResourceListRequest) (*admin.ExecutionList, error)); ok {
		return rf(ctx, request)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *admin.ResourceListRequest) *admin.ExecutionList); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*admin.ExecutionList)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *admin.ResourceListRequest) error); ok {
		r1 = rf(ctx, request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExecutionInterface_ListExecutions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListExecutions'
type ExecutionInterface_ListExecutions_Call struct {
	*mock.Call
}

// ListExecutions is a helper method to define mock.On call
//   - ctx context.Context
//   - request *admin.ResourceListRequest
func (_e *ExecutionInterface_Expecter) ListExecutions(ctx interface{}, request interface{}) *ExecutionInterface_ListExecutions_Call {
	return &ExecutionInterface_ListExecutions_Call{Call: _e.mock.On("ListExecutions", ctx, request)}
}

func (_c *ExecutionInterface_ListExecutions_Call) Run(run func(ctx context.Context, request *admin.ResourceListRequest)) *ExecutionInterface_ListExecutions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*admin.ResourceListRequest))
	})
	return _c
}

func (_c *ExecutionInterface_ListExecutions_Call) Return(_a0 *admin.ExecutionList, _a1 error) *ExecutionInterface_ListExecutions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ExecutionInterface_ListExecutions_Call) RunAndReturn(run func(context.Context, *admin.ResourceListRequest) (*admin.ExecutionList, error)) *ExecutionInterface_ListExecutions_Call {
	_c.Call.Return(run)
	return _c
}

// RecoverExecution provides a mock function with given fields: ctx, request, requestedAt
func (_m *ExecutionInterface) RecoverExecution(ctx context.Context, request *admin.ExecutionRecoverRequest, requestedAt time.Time) (*admin.ExecutionCreateResponse, error) {
	ret := _m.Called(ctx, request, requestedAt)

	if len(ret) == 0 {
		panic("no return value specified for RecoverExecution")
	}

	var r0 *admin.ExecutionCreateResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *admin.ExecutionRecoverRequest, time.Time) (*admin.ExecutionCreateResponse, error)); ok {
		return rf(ctx, request, requestedAt)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *admin.ExecutionRecoverRequest, time.Time) *admin.ExecutionCreateResponse); ok {
		r0 = rf(ctx, request, requestedAt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*admin.ExecutionCreateResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *admin.ExecutionRecoverRequest, time.Time) error); ok {
		r1 = rf(ctx, request, requestedAt)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExecutionInterface_RecoverExecution_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RecoverExecution'
type ExecutionInterface_RecoverExecution_Call struct {
	*mock.Call
}

// RecoverExecution is a helper method to define mock.On call
//   - ctx context.Context
//   - request *admin.ExecutionRecoverRequest
//   - requestedAt time.Time
func (_e *ExecutionInterface_Expecter) RecoverExecution(ctx interface{}, request interface{}, requestedAt interface{}) *ExecutionInterface_RecoverExecution_Call {
	return &ExecutionInterface_RecoverExecution_Call{Call: _e.mock.On("RecoverExecution", ctx, request, requestedAt)}
}

func (_c *ExecutionInterface_RecoverExecution_Call) Run(run func(ctx context.Context, request *admin.ExecutionRecoverRequest, requestedAt time.Time)) *ExecutionInterface_RecoverExecution_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*admin.ExecutionRecoverRequest), args[2].(time.Time))
	})
	return _c
}

func (_c *ExecutionInterface_RecoverExecution_Call) Return(_a0 *admin.ExecutionCreateResponse, _a1 error) *ExecutionInterface_RecoverExecution_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ExecutionInterface_RecoverExecution_Call) RunAndReturn(run func(context.Context, *admin.ExecutionRecoverRequest, time.Time) (*admin.ExecutionCreateResponse, error)) *ExecutionInterface_RecoverExecution_Call {
	_c.Call.Return(run)
	return _c
}

// RelaunchExecution provides a mock function with given fields: ctx, request, requestedAt
func (_m *ExecutionInterface) RelaunchExecution(ctx context.Context, request *admin.ExecutionRelaunchRequest, requestedAt time.Time) (*admin.ExecutionCreateResponse, error) {
	ret := _m.Called(ctx, request, requestedAt)

	if len(ret) == 0 {
		panic("no return value specified for RelaunchExecution")
	}

	var r0 *admin.ExecutionCreateResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *admin.ExecutionRelaunchRequest, time.Time) (*admin.ExecutionCreateResponse, error)); ok {
		return rf(ctx, request, requestedAt)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *admin.ExecutionRelaunchRequest, time.Time) *admin.ExecutionCreateResponse); ok {
		r0 = rf(ctx, request, requestedAt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*admin.ExecutionCreateResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *admin.ExecutionRelaunchRequest, time.Time) error); ok {
		r1 = rf(ctx, request, requestedAt)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExecutionInterface_RelaunchExecution_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RelaunchExecution'
type ExecutionInterface_RelaunchExecution_Call struct {
	*mock.Call
}

// RelaunchExecution is a helper method to define mock.On call
//   - ctx context.Context
//   - request *admin.ExecutionRelaunchRequest
//   - requestedAt time.Time
func (_e *ExecutionInterface_Expecter) RelaunchExecution(ctx interface{}, request interface{}, requestedAt interface{}) *ExecutionInterface_RelaunchExecution_Call {
	return &ExecutionInterface_RelaunchExecution_Call{Call: _e.mock.On("RelaunchExecution", ctx, request, requestedAt)}
}

func (_c *ExecutionInterface_RelaunchExecution_Call) Run(run func(ctx context.Context, request *admin.ExecutionRelaunchRequest, requestedAt time.Time)) *ExecutionInterface_RelaunchExecution_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*admin.ExecutionRelaunchRequest), args[2].(time.Time))
	})
	return _c
}

func (_c *ExecutionInterface_RelaunchExecution_Call) Return(_a0 *admin.ExecutionCreateResponse, _a1 error) *ExecutionInterface_RelaunchExecution_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ExecutionInterface_RelaunchExecution_Call) RunAndReturn(run func(context.Context, *admin.ExecutionRelaunchRequest, time.Time) (*admin.ExecutionCreateResponse, error)) *ExecutionInterface_RelaunchExecution_Call {
	_c.Call.Return(run)
	return _c
}

// TerminateExecution provides a mock function with given fields: ctx, request
func (_m *ExecutionInterface) TerminateExecution(ctx context.Context, request *admin.ExecutionTerminateRequest) (*admin.ExecutionTerminateResponse, error) {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for TerminateExecution")
	}

	var r0 *admin.ExecutionTerminateResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *admin.ExecutionTerminateRequest) (*admin.ExecutionTerminateResponse, error)); ok {
		return rf(ctx, request)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *admin.ExecutionTerminateRequest) *admin.ExecutionTerminateResponse); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*admin.ExecutionTerminateResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *admin.ExecutionTerminateRequest) error); ok {
		r1 = rf(ctx, request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExecutionInterface_TerminateExecution_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TerminateExecution'
type ExecutionInterface_TerminateExecution_Call struct {
	*mock.Call
}

// TerminateExecution is a helper method to define mock.On call
//   - ctx context.Context
//   - request *admin.ExecutionTerminateRequest
func (_e *ExecutionInterface_Expecter) TerminateExecution(ctx interface{}, request interface{}) *ExecutionInterface_TerminateExecution_Call {
	return &ExecutionInterface_TerminateExecution_Call{Call: _e.mock.On("TerminateExecution", ctx, request)}
}

func (_c *ExecutionInterface_TerminateExecution_Call) Run(run func(ctx context.Context, request *admin.ExecutionTerminateRequest)) *ExecutionInterface_TerminateExecution_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*admin.ExecutionTerminateRequest))
	})
	return _c
}

func (_c *ExecutionInterface_TerminateExecution_Call) Return(_a0 *admin.ExecutionTerminateResponse, _a1 error) *ExecutionInterface_TerminateExecution_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ExecutionInterface_TerminateExecution_Call) RunAndReturn(run func(context.Context, *admin.ExecutionTerminateRequest) (*admin.ExecutionTerminateResponse, error)) *ExecutionInterface_TerminateExecution_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateExecution provides a mock function with given fields: ctx, request, requestedAt
func (_m *ExecutionInterface) UpdateExecution(ctx context.Context, request *admin.ExecutionUpdateRequest, requestedAt time.Time) (*admin.ExecutionUpdateResponse, error) {
	ret := _m.Called(ctx, request, requestedAt)

	if len(ret) == 0 {
		panic("no return value specified for UpdateExecution")
	}

	var r0 *admin.ExecutionUpdateResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *admin.ExecutionUpdateRequest, time.Time) (*admin.ExecutionUpdateResponse, error)); ok {
		return rf(ctx, request, requestedAt)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *admin.ExecutionUpdateRequest, time.Time) *admin.ExecutionUpdateResponse); ok {
		r0 = rf(ctx, request, requestedAt)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*admin.ExecutionUpdateResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *admin.ExecutionUpdateRequest, time.Time) error); ok {
		r1 = rf(ctx, request, requestedAt)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExecutionInterface_UpdateExecution_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateExecution'
type ExecutionInterface_UpdateExecution_Call struct {
	*mock.Call
}

// UpdateExecution is a helper method to define mock.On call
//   - ctx context.Context
//   - request *admin.ExecutionUpdateRequest
//   - requestedAt time.Time
func (_e *ExecutionInterface_Expecter) UpdateExecution(ctx interface{}, request interface{}, requestedAt interface{}) *ExecutionInterface_UpdateExecution_Call {
	return &ExecutionInterface_UpdateExecution_Call{Call: _e.mock.On("UpdateExecution", ctx, request, requestedAt)}
}

func (_c *ExecutionInterface_UpdateExecution_Call) Run(run func(ctx context.Context, request *admin.ExecutionUpdateRequest, requestedAt time.Time)) *ExecutionInterface_UpdateExecution_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*admin.ExecutionUpdateRequest), args[2].(time.Time))
	})
	return _c
}

func (_c *ExecutionInterface_UpdateExecution_Call) Return(_a0 *admin.ExecutionUpdateResponse, _a1 error) *ExecutionInterface_UpdateExecution_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *ExecutionInterface_UpdateExecution_Call) RunAndReturn(run func(context.Context, *admin.ExecutionUpdateRequest, time.Time) (*admin.ExecutionUpdateResponse, error)) *ExecutionInterface_UpdateExecution_Call {
	_c.Call.Return(run)
	return _c
}

// NewExecutionInterface creates a new instance of ExecutionInterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewExecutionInterface(t interface {
	mock.TestingT
	Cleanup(func())
}) *ExecutionInterface {
	mock := &ExecutionInterface{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
