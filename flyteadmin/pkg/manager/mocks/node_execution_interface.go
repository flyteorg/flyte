// Code generated by mockery v2.40.3. DO NOT EDIT.

package mocks

import (
	context "context"

	admin "github.com/flyteorg/flyte/flyteidl/gen/pb-go/flyteidl/admin"

	mock "github.com/stretchr/testify/mock"
)

// NodeExecutionInterface is an autogenerated mock type for the NodeExecutionInterface type
type NodeExecutionInterface struct {
	mock.Mock
}

type NodeExecutionInterface_Expecter struct {
	mock *mock.Mock
}

func (_m *NodeExecutionInterface) EXPECT() *NodeExecutionInterface_Expecter {
	return &NodeExecutionInterface_Expecter{mock: &_m.Mock}
}

// CreateNodeEvent provides a mock function with given fields: ctx, request
func (_m *NodeExecutionInterface) CreateNodeEvent(ctx context.Context, request *admin.NodeExecutionEventRequest) (*admin.NodeExecutionEventResponse, error) {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for CreateNodeEvent")
	}

	var r0 *admin.NodeExecutionEventResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *admin.NodeExecutionEventRequest) (*admin.NodeExecutionEventResponse, error)); ok {
		return rf(ctx, request)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *admin.NodeExecutionEventRequest) *admin.NodeExecutionEventResponse); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*admin.NodeExecutionEventResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *admin.NodeExecutionEventRequest) error); ok {
		r1 = rf(ctx, request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NodeExecutionInterface_CreateNodeEvent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateNodeEvent'
type NodeExecutionInterface_CreateNodeEvent_Call struct {
	*mock.Call
}

// CreateNodeEvent is a helper method to define mock.On call
//   - ctx context.Context
//   - request *admin.NodeExecutionEventRequest
func (_e *NodeExecutionInterface_Expecter) CreateNodeEvent(ctx interface{}, request interface{}) *NodeExecutionInterface_CreateNodeEvent_Call {
	return &NodeExecutionInterface_CreateNodeEvent_Call{Call: _e.mock.On("CreateNodeEvent", ctx, request)}
}

func (_c *NodeExecutionInterface_CreateNodeEvent_Call) Run(run func(ctx context.Context, request *admin.NodeExecutionEventRequest)) *NodeExecutionInterface_CreateNodeEvent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*admin.NodeExecutionEventRequest))
	})
	return _c
}

func (_c *NodeExecutionInterface_CreateNodeEvent_Call) Return(_a0 *admin.NodeExecutionEventResponse, _a1 error) *NodeExecutionInterface_CreateNodeEvent_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *NodeExecutionInterface_CreateNodeEvent_Call) RunAndReturn(run func(context.Context, *admin.NodeExecutionEventRequest) (*admin.NodeExecutionEventResponse, error)) *NodeExecutionInterface_CreateNodeEvent_Call {
	_c.Call.Return(run)
	return _c
}

// GetDynamicNodeWorkflow provides a mock function with given fields: ctx, request
func (_m *NodeExecutionInterface) GetDynamicNodeWorkflow(ctx context.Context, request *admin.GetDynamicNodeWorkflowRequest) (*admin.DynamicNodeWorkflowResponse, error) {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for GetDynamicNodeWorkflow")
	}

	var r0 *admin.DynamicNodeWorkflowResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *admin.GetDynamicNodeWorkflowRequest) (*admin.DynamicNodeWorkflowResponse, error)); ok {
		return rf(ctx, request)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *admin.GetDynamicNodeWorkflowRequest) *admin.DynamicNodeWorkflowResponse); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*admin.DynamicNodeWorkflowResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *admin.GetDynamicNodeWorkflowRequest) error); ok {
		r1 = rf(ctx, request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NodeExecutionInterface_GetDynamicNodeWorkflow_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDynamicNodeWorkflow'
type NodeExecutionInterface_GetDynamicNodeWorkflow_Call struct {
	*mock.Call
}

// GetDynamicNodeWorkflow is a helper method to define mock.On call
//   - ctx context.Context
//   - request *admin.GetDynamicNodeWorkflowRequest
func (_e *NodeExecutionInterface_Expecter) GetDynamicNodeWorkflow(ctx interface{}, request interface{}) *NodeExecutionInterface_GetDynamicNodeWorkflow_Call {
	return &NodeExecutionInterface_GetDynamicNodeWorkflow_Call{Call: _e.mock.On("GetDynamicNodeWorkflow", ctx, request)}
}

func (_c *NodeExecutionInterface_GetDynamicNodeWorkflow_Call) Run(run func(ctx context.Context, request *admin.GetDynamicNodeWorkflowRequest)) *NodeExecutionInterface_GetDynamicNodeWorkflow_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*admin.GetDynamicNodeWorkflowRequest))
	})
	return _c
}

func (_c *NodeExecutionInterface_GetDynamicNodeWorkflow_Call) Return(_a0 *admin.DynamicNodeWorkflowResponse, _a1 error) *NodeExecutionInterface_GetDynamicNodeWorkflow_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *NodeExecutionInterface_GetDynamicNodeWorkflow_Call) RunAndReturn(run func(context.Context, *admin.GetDynamicNodeWorkflowRequest) (*admin.DynamicNodeWorkflowResponse, error)) *NodeExecutionInterface_GetDynamicNodeWorkflow_Call {
	_c.Call.Return(run)
	return _c
}

// GetNodeExecution provides a mock function with given fields: ctx, request
func (_m *NodeExecutionInterface) GetNodeExecution(ctx context.Context, request *admin.NodeExecutionGetRequest) (*admin.NodeExecution, error) {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for GetNodeExecution")
	}

	var r0 *admin.NodeExecution
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *admin.NodeExecutionGetRequest) (*admin.NodeExecution, error)); ok {
		return rf(ctx, request)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *admin.NodeExecutionGetRequest) *admin.NodeExecution); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*admin.NodeExecution)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *admin.NodeExecutionGetRequest) error); ok {
		r1 = rf(ctx, request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NodeExecutionInterface_GetNodeExecution_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetNodeExecution'
type NodeExecutionInterface_GetNodeExecution_Call struct {
	*mock.Call
}

// GetNodeExecution is a helper method to define mock.On call
//   - ctx context.Context
//   - request *admin.NodeExecutionGetRequest
func (_e *NodeExecutionInterface_Expecter) GetNodeExecution(ctx interface{}, request interface{}) *NodeExecutionInterface_GetNodeExecution_Call {
	return &NodeExecutionInterface_GetNodeExecution_Call{Call: _e.mock.On("GetNodeExecution", ctx, request)}
}

func (_c *NodeExecutionInterface_GetNodeExecution_Call) Run(run func(ctx context.Context, request *admin.NodeExecutionGetRequest)) *NodeExecutionInterface_GetNodeExecution_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*admin.NodeExecutionGetRequest))
	})
	return _c
}

func (_c *NodeExecutionInterface_GetNodeExecution_Call) Return(_a0 *admin.NodeExecution, _a1 error) *NodeExecutionInterface_GetNodeExecution_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *NodeExecutionInterface_GetNodeExecution_Call) RunAndReturn(run func(context.Context, *admin.NodeExecutionGetRequest) (*admin.NodeExecution, error)) *NodeExecutionInterface_GetNodeExecution_Call {
	_c.Call.Return(run)
	return _c
}

// GetNodeExecutionData provides a mock function with given fields: ctx, request
func (_m *NodeExecutionInterface) GetNodeExecutionData(ctx context.Context, request *admin.NodeExecutionGetDataRequest) (*admin.NodeExecutionGetDataResponse, error) {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for GetNodeExecutionData")
	}

	var r0 *admin.NodeExecutionGetDataResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *admin.NodeExecutionGetDataRequest) (*admin.NodeExecutionGetDataResponse, error)); ok {
		return rf(ctx, request)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *admin.NodeExecutionGetDataRequest) *admin.NodeExecutionGetDataResponse); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*admin.NodeExecutionGetDataResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *admin.NodeExecutionGetDataRequest) error); ok {
		r1 = rf(ctx, request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NodeExecutionInterface_GetNodeExecutionData_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetNodeExecutionData'
type NodeExecutionInterface_GetNodeExecutionData_Call struct {
	*mock.Call
}

// GetNodeExecutionData is a helper method to define mock.On call
//   - ctx context.Context
//   - request *admin.NodeExecutionGetDataRequest
func (_e *NodeExecutionInterface_Expecter) GetNodeExecutionData(ctx interface{}, request interface{}) *NodeExecutionInterface_GetNodeExecutionData_Call {
	return &NodeExecutionInterface_GetNodeExecutionData_Call{Call: _e.mock.On("GetNodeExecutionData", ctx, request)}
}

func (_c *NodeExecutionInterface_GetNodeExecutionData_Call) Run(run func(ctx context.Context, request *admin.NodeExecutionGetDataRequest)) *NodeExecutionInterface_GetNodeExecutionData_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*admin.NodeExecutionGetDataRequest))
	})
	return _c
}

func (_c *NodeExecutionInterface_GetNodeExecutionData_Call) Return(_a0 *admin.NodeExecutionGetDataResponse, _a1 error) *NodeExecutionInterface_GetNodeExecutionData_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *NodeExecutionInterface_GetNodeExecutionData_Call) RunAndReturn(run func(context.Context, *admin.NodeExecutionGetDataRequest) (*admin.NodeExecutionGetDataResponse, error)) *NodeExecutionInterface_GetNodeExecutionData_Call {
	_c.Call.Return(run)
	return _c
}

// ListNodeExecutions provides a mock function with given fields: ctx, request
func (_m *NodeExecutionInterface) ListNodeExecutions(ctx context.Context, request *admin.NodeExecutionListRequest) (*admin.NodeExecutionList, error) {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for ListNodeExecutions")
	}

	var r0 *admin.NodeExecutionList
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *admin.NodeExecutionListRequest) (*admin.NodeExecutionList, error)); ok {
		return rf(ctx, request)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *admin.NodeExecutionListRequest) *admin.NodeExecutionList); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*admin.NodeExecutionList)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *admin.NodeExecutionListRequest) error); ok {
		r1 = rf(ctx, request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NodeExecutionInterface_ListNodeExecutions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListNodeExecutions'
type NodeExecutionInterface_ListNodeExecutions_Call struct {
	*mock.Call
}

// ListNodeExecutions is a helper method to define mock.On call
//   - ctx context.Context
//   - request *admin.NodeExecutionListRequest
func (_e *NodeExecutionInterface_Expecter) ListNodeExecutions(ctx interface{}, request interface{}) *NodeExecutionInterface_ListNodeExecutions_Call {
	return &NodeExecutionInterface_ListNodeExecutions_Call{Call: _e.mock.On("ListNodeExecutions", ctx, request)}
}

func (_c *NodeExecutionInterface_ListNodeExecutions_Call) Run(run func(ctx context.Context, request *admin.NodeExecutionListRequest)) *NodeExecutionInterface_ListNodeExecutions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*admin.NodeExecutionListRequest))
	})
	return _c
}

func (_c *NodeExecutionInterface_ListNodeExecutions_Call) Return(_a0 *admin.NodeExecutionList, _a1 error) *NodeExecutionInterface_ListNodeExecutions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *NodeExecutionInterface_ListNodeExecutions_Call) RunAndReturn(run func(context.Context, *admin.NodeExecutionListRequest) (*admin.NodeExecutionList, error)) *NodeExecutionInterface_ListNodeExecutions_Call {
	_c.Call.Return(run)
	return _c
}

// ListNodeExecutionsForTask provides a mock function with given fields: ctx, request
func (_m *NodeExecutionInterface) ListNodeExecutionsForTask(ctx context.Context, request *admin.NodeExecutionForTaskListRequest) (*admin.NodeExecutionList, error) {
	ret := _m.Called(ctx, request)

	if len(ret) == 0 {
		panic("no return value specified for ListNodeExecutionsForTask")
	}

	var r0 *admin.NodeExecutionList
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *admin.NodeExecutionForTaskListRequest) (*admin.NodeExecutionList, error)); ok {
		return rf(ctx, request)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *admin.NodeExecutionForTaskListRequest) *admin.NodeExecutionList); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*admin.NodeExecutionList)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *admin.NodeExecutionForTaskListRequest) error); ok {
		r1 = rf(ctx, request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NodeExecutionInterface_ListNodeExecutionsForTask_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListNodeExecutionsForTask'
type NodeExecutionInterface_ListNodeExecutionsForTask_Call struct {
	*mock.Call
}

// ListNodeExecutionsForTask is a helper method to define mock.On call
//   - ctx context.Context
//   - request *admin.NodeExecutionForTaskListRequest
func (_e *NodeExecutionInterface_Expecter) ListNodeExecutionsForTask(ctx interface{}, request interface{}) *NodeExecutionInterface_ListNodeExecutionsForTask_Call {
	return &NodeExecutionInterface_ListNodeExecutionsForTask_Call{Call: _e.mock.On("ListNodeExecutionsForTask", ctx, request)}
}

func (_c *NodeExecutionInterface_ListNodeExecutionsForTask_Call) Run(run func(ctx context.Context, request *admin.NodeExecutionForTaskListRequest)) *NodeExecutionInterface_ListNodeExecutionsForTask_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*admin.NodeExecutionForTaskListRequest))
	})
	return _c
}

func (_c *NodeExecutionInterface_ListNodeExecutionsForTask_Call) Return(_a0 *admin.NodeExecutionList, _a1 error) *NodeExecutionInterface_ListNodeExecutionsForTask_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *NodeExecutionInterface_ListNodeExecutionsForTask_Call) RunAndReturn(run func(context.Context, *admin.NodeExecutionForTaskListRequest) (*admin.NodeExecutionList, error)) *NodeExecutionInterface_ListNodeExecutionsForTask_Call {
	_c.Call.Return(run)
	return _c
}

// NewNodeExecutionInterface creates a new instance of NodeExecutionInterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewNodeExecutionInterface(t interface {
	mock.TestingT
	Cleanup(func())
}) *NodeExecutionInterface {
	mock := &NodeExecutionInterface{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
