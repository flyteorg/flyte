// Code generated by mockery v1.0.1. DO NOT EDIT.

package mocks

import (
	context "context"

	client "sigs.k8s.io/controller-runtime/pkg/client"

	meta "k8s.io/apimachinery/pkg/api/meta"

	mock "github.com/stretchr/testify/mock"

	runtime "k8s.io/apimachinery/pkg/runtime"

	schema "k8s.io/apimachinery/pkg/runtime/schema"

	types "k8s.io/apimachinery/pkg/types"
)

// MockableControllerRuntimeClient is an autogenerated mock type for the MockableControllerRuntimeClient type
type MockableControllerRuntimeClient struct {
	mock.Mock
}

type MockableControllerRuntimeClient_Create struct {
	*mock.Call
}

func (_m MockableControllerRuntimeClient_Create) Return(_a0 error) *MockableControllerRuntimeClient_Create {
	return &MockableControllerRuntimeClient_Create{Call: _m.Call.Return(_a0)}
}

func (_m *MockableControllerRuntimeClient) OnCreate(ctx context.Context, obj client.Object, opts ...client.CreateOption) *MockableControllerRuntimeClient_Create {
	c_call := _m.On("Create", ctx, obj, opts)
	return &MockableControllerRuntimeClient_Create{Call: c_call}
}

func (_m *MockableControllerRuntimeClient) OnCreateMatch(matchers ...interface{}) *MockableControllerRuntimeClient_Create {
	c_call := _m.On("Create", matchers...)
	return &MockableControllerRuntimeClient_Create{Call: c_call}
}

// Create provides a mock function with given fields: ctx, obj, opts
func (_m *MockableControllerRuntimeClient) Create(ctx context.Context, obj client.Object, opts ...client.CreateOption) error {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, obj)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, client.Object, ...client.CreateOption) error); ok {
		r0 = rf(ctx, obj, opts...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type MockableControllerRuntimeClient_Delete struct {
	*mock.Call
}

func (_m MockableControllerRuntimeClient_Delete) Return(_a0 error) *MockableControllerRuntimeClient_Delete {
	return &MockableControllerRuntimeClient_Delete{Call: _m.Call.Return(_a0)}
}

func (_m *MockableControllerRuntimeClient) OnDelete(ctx context.Context, obj client.Object, opts ...client.DeleteOption) *MockableControllerRuntimeClient_Delete {
	c_call := _m.On("Delete", ctx, obj, opts)
	return &MockableControllerRuntimeClient_Delete{Call: c_call}
}

func (_m *MockableControllerRuntimeClient) OnDeleteMatch(matchers ...interface{}) *MockableControllerRuntimeClient_Delete {
	c_call := _m.On("Delete", matchers...)
	return &MockableControllerRuntimeClient_Delete{Call: c_call}
}

// Delete provides a mock function with given fields: ctx, obj, opts
func (_m *MockableControllerRuntimeClient) Delete(ctx context.Context, obj client.Object, opts ...client.DeleteOption) error {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, obj)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, client.Object, ...client.DeleteOption) error); ok {
		r0 = rf(ctx, obj, opts...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type MockableControllerRuntimeClient_DeleteAllOf struct {
	*mock.Call
}

func (_m MockableControllerRuntimeClient_DeleteAllOf) Return(_a0 error) *MockableControllerRuntimeClient_DeleteAllOf {
	return &MockableControllerRuntimeClient_DeleteAllOf{Call: _m.Call.Return(_a0)}
}

func (_m *MockableControllerRuntimeClient) OnDeleteAllOf(ctx context.Context, obj client.Object, opts ...client.DeleteAllOfOption) *MockableControllerRuntimeClient_DeleteAllOf {
	c_call := _m.On("DeleteAllOf", ctx, obj, opts)
	return &MockableControllerRuntimeClient_DeleteAllOf{Call: c_call}
}

func (_m *MockableControllerRuntimeClient) OnDeleteAllOfMatch(matchers ...interface{}) *MockableControllerRuntimeClient_DeleteAllOf {
	c_call := _m.On("DeleteAllOf", matchers...)
	return &MockableControllerRuntimeClient_DeleteAllOf{Call: c_call}
}

// DeleteAllOf provides a mock function with given fields: ctx, obj, opts
func (_m *MockableControllerRuntimeClient) DeleteAllOf(ctx context.Context, obj client.Object, opts ...client.DeleteAllOfOption) error {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, obj)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, client.Object, ...client.DeleteAllOfOption) error); ok {
		r0 = rf(ctx, obj, opts...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type MockableControllerRuntimeClient_Get struct {
	*mock.Call
}

func (_m MockableControllerRuntimeClient_Get) Return(_a0 error) *MockableControllerRuntimeClient_Get {
	return &MockableControllerRuntimeClient_Get{Call: _m.Call.Return(_a0)}
}

func (_m *MockableControllerRuntimeClient) OnGet(ctx context.Context, key types.NamespacedName, obj client.Object, opts ...client.GetOption) *MockableControllerRuntimeClient_Get {
	c_call := _m.On("Get", ctx, key, obj, opts)
	return &MockableControllerRuntimeClient_Get{Call: c_call}
}

func (_m *MockableControllerRuntimeClient) OnGetMatch(matchers ...interface{}) *MockableControllerRuntimeClient_Get {
	c_call := _m.On("Get", matchers...)
	return &MockableControllerRuntimeClient_Get{Call: c_call}
}

// Get provides a mock function with given fields: ctx, key, obj, opts
func (_m *MockableControllerRuntimeClient) Get(ctx context.Context, key types.NamespacedName, obj client.Object, opts ...client.GetOption) error {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, key, obj)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, types.NamespacedName, client.Object, ...client.GetOption) error); ok {
		r0 = rf(ctx, key, obj, opts...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type MockableControllerRuntimeClient_GroupVersionKindFor struct {
	*mock.Call
}

func (_m MockableControllerRuntimeClient_GroupVersionKindFor) Return(_a0 schema.GroupVersionKind, _a1 error) *MockableControllerRuntimeClient_GroupVersionKindFor {
	return &MockableControllerRuntimeClient_GroupVersionKindFor{Call: _m.Call.Return(_a0, _a1)}
}

func (_m *MockableControllerRuntimeClient) OnGroupVersionKindFor(obj runtime.Object) *MockableControllerRuntimeClient_GroupVersionKindFor {
	c_call := _m.On("GroupVersionKindFor", obj)
	return &MockableControllerRuntimeClient_GroupVersionKindFor{Call: c_call}
}

func (_m *MockableControllerRuntimeClient) OnGroupVersionKindForMatch(matchers ...interface{}) *MockableControllerRuntimeClient_GroupVersionKindFor {
	c_call := _m.On("GroupVersionKindFor", matchers...)
	return &MockableControllerRuntimeClient_GroupVersionKindFor{Call: c_call}
}

// GroupVersionKindFor provides a mock function with given fields: obj
func (_m *MockableControllerRuntimeClient) GroupVersionKindFor(obj runtime.Object) (schema.GroupVersionKind, error) {
	ret := _m.Called(obj)

	var r0 schema.GroupVersionKind
	if rf, ok := ret.Get(0).(func(runtime.Object) schema.GroupVersionKind); ok {
		r0 = rf(obj)
	} else {
		r0 = ret.Get(0).(schema.GroupVersionKind)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(runtime.Object) error); ok {
		r1 = rf(obj)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type MockableControllerRuntimeClient_IsObjectNamespaced struct {
	*mock.Call
}

func (_m MockableControllerRuntimeClient_IsObjectNamespaced) Return(_a0 bool, _a1 error) *MockableControllerRuntimeClient_IsObjectNamespaced {
	return &MockableControllerRuntimeClient_IsObjectNamespaced{Call: _m.Call.Return(_a0, _a1)}
}

func (_m *MockableControllerRuntimeClient) OnIsObjectNamespaced(obj runtime.Object) *MockableControllerRuntimeClient_IsObjectNamespaced {
	c_call := _m.On("IsObjectNamespaced", obj)
	return &MockableControllerRuntimeClient_IsObjectNamespaced{Call: c_call}
}

func (_m *MockableControllerRuntimeClient) OnIsObjectNamespacedMatch(matchers ...interface{}) *MockableControllerRuntimeClient_IsObjectNamespaced {
	c_call := _m.On("IsObjectNamespaced", matchers...)
	return &MockableControllerRuntimeClient_IsObjectNamespaced{Call: c_call}
}

// IsObjectNamespaced provides a mock function with given fields: obj
func (_m *MockableControllerRuntimeClient) IsObjectNamespaced(obj runtime.Object) (bool, error) {
	ret := _m.Called(obj)

	var r0 bool
	if rf, ok := ret.Get(0).(func(runtime.Object) bool); ok {
		r0 = rf(obj)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(runtime.Object) error); ok {
		r1 = rf(obj)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type MockableControllerRuntimeClient_List struct {
	*mock.Call
}

func (_m MockableControllerRuntimeClient_List) Return(_a0 error) *MockableControllerRuntimeClient_List {
	return &MockableControllerRuntimeClient_List{Call: _m.Call.Return(_a0)}
}

func (_m *MockableControllerRuntimeClient) OnList(ctx context.Context, list client.ObjectList, opts ...client.ListOption) *MockableControllerRuntimeClient_List {
	c_call := _m.On("List", ctx, list, opts)
	return &MockableControllerRuntimeClient_List{Call: c_call}
}

func (_m *MockableControllerRuntimeClient) OnListMatch(matchers ...interface{}) *MockableControllerRuntimeClient_List {
	c_call := _m.On("List", matchers...)
	return &MockableControllerRuntimeClient_List{Call: c_call}
}

// List provides a mock function with given fields: ctx, list, opts
func (_m *MockableControllerRuntimeClient) List(ctx context.Context, list client.ObjectList, opts ...client.ListOption) error {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, list)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, client.ObjectList, ...client.ListOption) error); ok {
		r0 = rf(ctx, list, opts...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type MockableControllerRuntimeClient_Patch struct {
	*mock.Call
}

func (_m MockableControllerRuntimeClient_Patch) Return(_a0 error) *MockableControllerRuntimeClient_Patch {
	return &MockableControllerRuntimeClient_Patch{Call: _m.Call.Return(_a0)}
}

func (_m *MockableControllerRuntimeClient) OnPatch(ctx context.Context, obj client.Object, patch client.Patch, opts ...client.PatchOption) *MockableControllerRuntimeClient_Patch {
	c_call := _m.On("Patch", ctx, obj, patch, opts)
	return &MockableControllerRuntimeClient_Patch{Call: c_call}
}

func (_m *MockableControllerRuntimeClient) OnPatchMatch(matchers ...interface{}) *MockableControllerRuntimeClient_Patch {
	c_call := _m.On("Patch", matchers...)
	return &MockableControllerRuntimeClient_Patch{Call: c_call}
}

// Patch provides a mock function with given fields: ctx, obj, patch, opts
func (_m *MockableControllerRuntimeClient) Patch(ctx context.Context, obj client.Object, patch client.Patch, opts ...client.PatchOption) error {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, obj, patch)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, client.Object, client.Patch, ...client.PatchOption) error); ok {
		r0 = rf(ctx, obj, patch, opts...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type MockableControllerRuntimeClient_RESTMapper struct {
	*mock.Call
}

func (_m MockableControllerRuntimeClient_RESTMapper) Return(_a0 meta.RESTMapper) *MockableControllerRuntimeClient_RESTMapper {
	return &MockableControllerRuntimeClient_RESTMapper{Call: _m.Call.Return(_a0)}
}

func (_m *MockableControllerRuntimeClient) OnRESTMapper() *MockableControllerRuntimeClient_RESTMapper {
	c_call := _m.On("RESTMapper")
	return &MockableControllerRuntimeClient_RESTMapper{Call: c_call}
}

func (_m *MockableControllerRuntimeClient) OnRESTMapperMatch(matchers ...interface{}) *MockableControllerRuntimeClient_RESTMapper {
	c_call := _m.On("RESTMapper", matchers...)
	return &MockableControllerRuntimeClient_RESTMapper{Call: c_call}
}

// RESTMapper provides a mock function with given fields:
func (_m *MockableControllerRuntimeClient) RESTMapper() meta.RESTMapper {
	ret := _m.Called()

	var r0 meta.RESTMapper
	if rf, ok := ret.Get(0).(func() meta.RESTMapper); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(meta.RESTMapper)
		}
	}

	return r0
}

type MockableControllerRuntimeClient_Scheme struct {
	*mock.Call
}

func (_m MockableControllerRuntimeClient_Scheme) Return(_a0 *runtime.Scheme) *MockableControllerRuntimeClient_Scheme {
	return &MockableControllerRuntimeClient_Scheme{Call: _m.Call.Return(_a0)}
}

func (_m *MockableControllerRuntimeClient) OnScheme() *MockableControllerRuntimeClient_Scheme {
	c_call := _m.On("Scheme")
	return &MockableControllerRuntimeClient_Scheme{Call: c_call}
}

func (_m *MockableControllerRuntimeClient) OnSchemeMatch(matchers ...interface{}) *MockableControllerRuntimeClient_Scheme {
	c_call := _m.On("Scheme", matchers...)
	return &MockableControllerRuntimeClient_Scheme{Call: c_call}
}

// Scheme provides a mock function with given fields:
func (_m *MockableControllerRuntimeClient) Scheme() *runtime.Scheme {
	ret := _m.Called()

	var r0 *runtime.Scheme
	if rf, ok := ret.Get(0).(func() *runtime.Scheme); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*runtime.Scheme)
		}
	}

	return r0
}

type MockableControllerRuntimeClient_Status struct {
	*mock.Call
}

func (_m MockableControllerRuntimeClient_Status) Return(_a0 client.SubResourceWriter) *MockableControllerRuntimeClient_Status {
	return &MockableControllerRuntimeClient_Status{Call: _m.Call.Return(_a0)}
}

func (_m *MockableControllerRuntimeClient) OnStatus() *MockableControllerRuntimeClient_Status {
	c_call := _m.On("Status")
	return &MockableControllerRuntimeClient_Status{Call: c_call}
}

func (_m *MockableControllerRuntimeClient) OnStatusMatch(matchers ...interface{}) *MockableControllerRuntimeClient_Status {
	c_call := _m.On("Status", matchers...)
	return &MockableControllerRuntimeClient_Status{Call: c_call}
}

// Status provides a mock function with given fields:
func (_m *MockableControllerRuntimeClient) Status() client.SubResourceWriter {
	ret := _m.Called()

	var r0 client.SubResourceWriter
	if rf, ok := ret.Get(0).(func() client.SubResourceWriter); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(client.SubResourceWriter)
		}
	}

	return r0
}

type MockableControllerRuntimeClient_SubResource struct {
	*mock.Call
}

func (_m MockableControllerRuntimeClient_SubResource) Return(_a0 client.SubResourceClient) *MockableControllerRuntimeClient_SubResource {
	return &MockableControllerRuntimeClient_SubResource{Call: _m.Call.Return(_a0)}
}

func (_m *MockableControllerRuntimeClient) OnSubResource(subResource string) *MockableControllerRuntimeClient_SubResource {
	c_call := _m.On("SubResource", subResource)
	return &MockableControllerRuntimeClient_SubResource{Call: c_call}
}

func (_m *MockableControllerRuntimeClient) OnSubResourceMatch(matchers ...interface{}) *MockableControllerRuntimeClient_SubResource {
	c_call := _m.On("SubResource", matchers...)
	return &MockableControllerRuntimeClient_SubResource{Call: c_call}
}

// SubResource provides a mock function with given fields: subResource
func (_m *MockableControllerRuntimeClient) SubResource(subResource string) client.SubResourceClient {
	ret := _m.Called(subResource)

	var r0 client.SubResourceClient
	if rf, ok := ret.Get(0).(func(string) client.SubResourceClient); ok {
		r0 = rf(subResource)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(client.SubResourceClient)
		}
	}

	return r0
}

type MockableControllerRuntimeClient_Update struct {
	*mock.Call
}

func (_m MockableControllerRuntimeClient_Update) Return(_a0 error) *MockableControllerRuntimeClient_Update {
	return &MockableControllerRuntimeClient_Update{Call: _m.Call.Return(_a0)}
}

func (_m *MockableControllerRuntimeClient) OnUpdate(ctx context.Context, obj client.Object, opts ...client.UpdateOption) *MockableControllerRuntimeClient_Update {
	c_call := _m.On("Update", ctx, obj, opts)
	return &MockableControllerRuntimeClient_Update{Call: c_call}
}

func (_m *MockableControllerRuntimeClient) OnUpdateMatch(matchers ...interface{}) *MockableControllerRuntimeClient_Update {
	c_call := _m.On("Update", matchers...)
	return &MockableControllerRuntimeClient_Update{Call: c_call}
}

// Update provides a mock function with given fields: ctx, obj, opts
func (_m *MockableControllerRuntimeClient) Update(ctx context.Context, obj client.Object, opts ...client.UpdateOption) error {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, obj)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, client.Object, ...client.UpdateOption) error); ok {
		r0 = rf(ctx, obj, opts...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}
