package transformers

import (
	"fmt"

	"google.golang.org/protobuf/proto"
	"gorm.io/datatypes"

	"github.com/flyteorg/flyte/v2/gen/go/flyteidl2/common"
	"github.com/flyteorg/flyte/v2/gen/go/flyteidl2/workflow"
	"github.com/flyteorg/flyte/v2/runs/repository/models"
)

// CreateRunRequestToModel converts CreateRunRequest protobuf to Run domain model
// This transforms the API request into a database model
func CreateRunRequestToModel(req *workflow.CreateRunRequest) (*models.Run, error) {
	run := &models.Run{
		ParentActionName: nil,            // Nil indicates this is a root action (run)
		Phase:            "PHASE_QUEUED", // Default initial phase
	}

	// Extract organization, project, domain, and name from request
	if runId := req.GetRunId(); runId != nil {
		// Case 1: Client provided explicit RunId with name
		run.Org = runId.GetOrg()
		run.Project = runId.GetProject()
		run.Domain = runId.GetDomain()
		run.Name = runId.GetName()
	} else if projectId := req.GetProjectId(); projectId != nil {
		// Case 2: Client provided ProjectId, name will be generated by repository
		run.Org = projectId.GetOrganization()
		run.Project = projectId.GetName()
		run.Domain = projectId.GetDomain()
		run.Name = "" // Empty - let repository/database generate unique name
	}

	// Build and serialize ActionSpec
	// ActionSpec contains the task/workflow definition to be executed
	actionSpec := &workflow.ActionSpec{
		RunSpec: req.GetRunSpec(),
	}

	// Set the task information based on request type
	switch taskSpec := req.Task.(type) {
	case *workflow.CreateRunRequest_TaskSpec:
		// Inline task specification provided
		actionSpec.Spec = &workflow.ActionSpec_Task{
			Task: &workflow.TaskAction{
				Spec: taskSpec.TaskSpec,
			},
		}
	case *workflow.CreateRunRequest_TaskId:
		// Task identifier provided (reference to existing task)
		actionSpec.Spec = &workflow.ActionSpec_Task{
			Task: &workflow.TaskAction{
				Id: taskSpec.TaskId,
			},
		}
	}

	// Marshal ActionSpec to protobuf bytes
	actionSpecBytes, err := proto.Marshal(actionSpec)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal ActionSpec: %w", err)
	}
	run.ActionSpec = datatypes.JSON(actionSpecBytes)

	// Initialize ActionDetails with default queued status
	// ActionDetails will be updated as the action progresses
	actionDetails := &workflow.ActionDetails{
		Status: &workflow.ActionStatus{
			Phase: common.ActionPhase_ACTION_PHASE_QUEUED,
		},
		Attempts: []*workflow.ActionAttempt{}, // No attempts yet
	}

	// Marshal ActionDetails to protobuf bytes
	actionDetailsBytes, err := proto.Marshal(actionDetails)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal ActionDetails: %w", err)
	}
	run.ActionDetails = datatypes.JSON(actionDetailsBytes)

	return run, nil
}

// RunModelToRunProto converts Run domain model to workflow.Run protobuf
// This transforms the database model into an API response
func RunModelToRunProto(run *models.Run) (*workflow.Run, error) {
	if run == nil {
		return nil, fmt.Errorf("run model is nil")
	}

	// Build the run identifier
	runID := &common.RunIdentifier{
		Org:     run.Org,
		Project: run.Project,
		Domain:  run.Domain,
		Name:    run.Name,
	}

	// Build the action identifier
	// For root actions (runs), the action name equals the run name
	actionID := &common.ActionIdentifier{
		Run:  runID,
		Name: run.Name,
	}

	// Unmarshal ActionDetails to get the current status
	var actionDetails workflow.ActionDetails
	if len(run.ActionDetails) > 0 {
		if err := proto.Unmarshal(run.ActionDetails, &actionDetails); err != nil {
			return nil, fmt.Errorf("failed to unmarshal ActionDetails: %w", err)
		}
	}

	// Build the action proto with the fields that exist on workflow.Action
	action := &workflow.Action{
		Id:       actionID,
		Status:   actionDetails.Status, // Current phase, timestamps, error info
		Metadata: &workflow.ActionMetadata{
			// TODO:  Populate metadata if needed (created_by, etc.)
		},
	}

	return &workflow.Run{
		Action: action,
	}, nil
}

// RunModelToCreateRunResponse converts Run domain model to CreateRunResponse
// Helper function that wraps RunModelToRunProto for the CreateRun endpoint
func RunModelToCreateRunResponse(run *models.Run) (*workflow.CreateRunResponse, error) {
	runProto, err := RunModelToRunProto(run)
	if err != nil {
		return nil, err
	}

	return &workflow.CreateRunResponse{
		Run: runProto,
	}, nil
}
