// Code generated by mockery v2.40.3. DO NOT EDIT.

package mocks

import mock "github.com/stretchr/testify/mock"

// ControlFlow is an autogenerated mock type for the ControlFlow type
type ControlFlow struct {
	mock.Mock
}

type ControlFlow_Expecter struct {
	mock *mock.Mock
}

func (_m *ControlFlow) EXPECT() *ControlFlow_Expecter {
	return &ControlFlow_Expecter{mock: &_m.Mock}
}

// CurrentNodeExecutionCount provides a mock function with given fields:
func (_m *ControlFlow) CurrentNodeExecutionCount() uint32 {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for CurrentNodeExecutionCount")
	}

	var r0 uint32
	if rf, ok := ret.Get(0).(func() uint32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint32)
	}

	return r0
}

// ControlFlow_CurrentNodeExecutionCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CurrentNodeExecutionCount'
type ControlFlow_CurrentNodeExecutionCount_Call struct {
	*mock.Call
}

// CurrentNodeExecutionCount is a helper method to define mock.On call
func (_e *ControlFlow_Expecter) CurrentNodeExecutionCount() *ControlFlow_CurrentNodeExecutionCount_Call {
	return &ControlFlow_CurrentNodeExecutionCount_Call{Call: _e.mock.On("CurrentNodeExecutionCount")}
}

func (_c *ControlFlow_CurrentNodeExecutionCount_Call) Run(run func()) *ControlFlow_CurrentNodeExecutionCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ControlFlow_CurrentNodeExecutionCount_Call) Return(_a0 uint32) *ControlFlow_CurrentNodeExecutionCount_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ControlFlow_CurrentNodeExecutionCount_Call) RunAndReturn(run func() uint32) *ControlFlow_CurrentNodeExecutionCount_Call {
	_c.Call.Return(run)
	return _c
}

// CurrentParallelism provides a mock function with given fields:
func (_m *ControlFlow) CurrentParallelism() uint32 {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for CurrentParallelism")
	}

	var r0 uint32
	if rf, ok := ret.Get(0).(func() uint32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint32)
	}

	return r0
}

// ControlFlow_CurrentParallelism_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CurrentParallelism'
type ControlFlow_CurrentParallelism_Call struct {
	*mock.Call
}

// CurrentParallelism is a helper method to define mock.On call
func (_e *ControlFlow_Expecter) CurrentParallelism() *ControlFlow_CurrentParallelism_Call {
	return &ControlFlow_CurrentParallelism_Call{Call: _e.mock.On("CurrentParallelism")}
}

func (_c *ControlFlow_CurrentParallelism_Call) Run(run func()) *ControlFlow_CurrentParallelism_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ControlFlow_CurrentParallelism_Call) Return(_a0 uint32) *ControlFlow_CurrentParallelism_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ControlFlow_CurrentParallelism_Call) RunAndReturn(run func() uint32) *ControlFlow_CurrentParallelism_Call {
	_c.Call.Return(run)
	return _c
}

// CurrentTaskExecutionCount provides a mock function with given fields:
func (_m *ControlFlow) CurrentTaskExecutionCount() uint32 {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for CurrentTaskExecutionCount")
	}

	var r0 uint32
	if rf, ok := ret.Get(0).(func() uint32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint32)
	}

	return r0
}

// ControlFlow_CurrentTaskExecutionCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CurrentTaskExecutionCount'
type ControlFlow_CurrentTaskExecutionCount_Call struct {
	*mock.Call
}

// CurrentTaskExecutionCount is a helper method to define mock.On call
func (_e *ControlFlow_Expecter) CurrentTaskExecutionCount() *ControlFlow_CurrentTaskExecutionCount_Call {
	return &ControlFlow_CurrentTaskExecutionCount_Call{Call: _e.mock.On("CurrentTaskExecutionCount")}
}

func (_c *ControlFlow_CurrentTaskExecutionCount_Call) Run(run func()) *ControlFlow_CurrentTaskExecutionCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ControlFlow_CurrentTaskExecutionCount_Call) Return(_a0 uint32) *ControlFlow_CurrentTaskExecutionCount_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ControlFlow_CurrentTaskExecutionCount_Call) RunAndReturn(run func() uint32) *ControlFlow_CurrentTaskExecutionCount_Call {
	_c.Call.Return(run)
	return _c
}

// IncrementNodeExecutionCount provides a mock function with given fields:
func (_m *ControlFlow) IncrementNodeExecutionCount() uint32 {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for IncrementNodeExecutionCount")
	}

	var r0 uint32
	if rf, ok := ret.Get(0).(func() uint32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint32)
	}

	return r0
}

// ControlFlow_IncrementNodeExecutionCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IncrementNodeExecutionCount'
type ControlFlow_IncrementNodeExecutionCount_Call struct {
	*mock.Call
}

// IncrementNodeExecutionCount is a helper method to define mock.On call
func (_e *ControlFlow_Expecter) IncrementNodeExecutionCount() *ControlFlow_IncrementNodeExecutionCount_Call {
	return &ControlFlow_IncrementNodeExecutionCount_Call{Call: _e.mock.On("IncrementNodeExecutionCount")}
}

func (_c *ControlFlow_IncrementNodeExecutionCount_Call) Run(run func()) *ControlFlow_IncrementNodeExecutionCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ControlFlow_IncrementNodeExecutionCount_Call) Return(_a0 uint32) *ControlFlow_IncrementNodeExecutionCount_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ControlFlow_IncrementNodeExecutionCount_Call) RunAndReturn(run func() uint32) *ControlFlow_IncrementNodeExecutionCount_Call {
	_c.Call.Return(run)
	return _c
}

// IncrementParallelism provides a mock function with given fields:
func (_m *ControlFlow) IncrementParallelism() uint32 {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for IncrementParallelism")
	}

	var r0 uint32
	if rf, ok := ret.Get(0).(func() uint32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint32)
	}

	return r0
}

// ControlFlow_IncrementParallelism_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IncrementParallelism'
type ControlFlow_IncrementParallelism_Call struct {
	*mock.Call
}

// IncrementParallelism is a helper method to define mock.On call
func (_e *ControlFlow_Expecter) IncrementParallelism() *ControlFlow_IncrementParallelism_Call {
	return &ControlFlow_IncrementParallelism_Call{Call: _e.mock.On("IncrementParallelism")}
}

func (_c *ControlFlow_IncrementParallelism_Call) Run(run func()) *ControlFlow_IncrementParallelism_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ControlFlow_IncrementParallelism_Call) Return(_a0 uint32) *ControlFlow_IncrementParallelism_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ControlFlow_IncrementParallelism_Call) RunAndReturn(run func() uint32) *ControlFlow_IncrementParallelism_Call {
	_c.Call.Return(run)
	return _c
}

// IncrementTaskExecutionCount provides a mock function with given fields:
func (_m *ControlFlow) IncrementTaskExecutionCount() uint32 {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for IncrementTaskExecutionCount")
	}

	var r0 uint32
	if rf, ok := ret.Get(0).(func() uint32); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(uint32)
	}

	return r0
}

// ControlFlow_IncrementTaskExecutionCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IncrementTaskExecutionCount'
type ControlFlow_IncrementTaskExecutionCount_Call struct {
	*mock.Call
}

// IncrementTaskExecutionCount is a helper method to define mock.On call
func (_e *ControlFlow_Expecter) IncrementTaskExecutionCount() *ControlFlow_IncrementTaskExecutionCount_Call {
	return &ControlFlow_IncrementTaskExecutionCount_Call{Call: _e.mock.On("IncrementTaskExecutionCount")}
}

func (_c *ControlFlow_IncrementTaskExecutionCount_Call) Run(run func()) *ControlFlow_IncrementTaskExecutionCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ControlFlow_IncrementTaskExecutionCount_Call) Return(_a0 uint32) *ControlFlow_IncrementTaskExecutionCount_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ControlFlow_IncrementTaskExecutionCount_Call) RunAndReturn(run func() uint32) *ControlFlow_IncrementTaskExecutionCount_Call {
	_c.Call.Return(run)
	return _c
}

// NewControlFlow creates a new instance of ControlFlow. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewControlFlow(t interface {
	mock.TestingT
	Cleanup(func())
}) *ControlFlow {
	mock := &ControlFlow{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
