// Code generated by mockery v1.0.1. DO NOT EDIT.

package mocks

import (
	context "context"

	core "github.com/flyteorg/flyte/flyteidl/gen/pb-go/flyteidl/core"

	mock "github.com/stretchr/testify/mock"

	storage "github.com/flyteorg/flyte/flytestdlib/storage"

	task "github.com/flyteorg/flyte/flytepropeller/pkg/controller/nodes/task"

	v1alpha1 "github.com/flyteorg/flyte/flytepropeller/pkg/apis/flyteworkflow/v1alpha1"
)

// FutureFileReaderInterface is an autogenerated mock type for the FutureFileReaderInterface type
type FutureFileReaderInterface struct {
	mock.Mock
}

type FutureFileReaderInterface_Cache struct {
	*mock.Call
}

func (_m FutureFileReaderInterface_Cache) Return(_a0 error) *FutureFileReaderInterface_Cache {
	return &FutureFileReaderInterface_Cache{Call: _m.Call.Return(_a0)}
}

func (_m *FutureFileReaderInterface) OnCache(ctx context.Context, wf *v1alpha1.FlyteWorkflow, workflowClosure *core.CompiledWorkflowClosure) *FutureFileReaderInterface_Cache {
	c_call := _m.On("Cache", ctx, wf, workflowClosure)
	return &FutureFileReaderInterface_Cache{Call: c_call}
}

func (_m *FutureFileReaderInterface) OnCacheMatch(matchers ...interface{}) *FutureFileReaderInterface_Cache {
	c_call := _m.On("Cache", matchers...)
	return &FutureFileReaderInterface_Cache{Call: c_call}
}

// Cache provides a mock function with given fields: ctx, wf, workflowClosure
func (_m *FutureFileReaderInterface) Cache(ctx context.Context, wf *v1alpha1.FlyteWorkflow, workflowClosure *core.CompiledWorkflowClosure) error {
	ret := _m.Called(ctx, wf, workflowClosure)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *v1alpha1.FlyteWorkflow, *core.CompiledWorkflowClosure) error); ok {
		r0 = rf(ctx, wf, workflowClosure)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type FutureFileReaderInterface_CacheExists struct {
	*mock.Call
}

func (_m FutureFileReaderInterface_CacheExists) Return(_a0 bool, _a1 error) *FutureFileReaderInterface_CacheExists {
	return &FutureFileReaderInterface_CacheExists{Call: _m.Call.Return(_a0, _a1)}
}

func (_m *FutureFileReaderInterface) OnCacheExists(ctx context.Context) *FutureFileReaderInterface_CacheExists {
	c_call := _m.On("CacheExists", ctx)
	return &FutureFileReaderInterface_CacheExists{Call: c_call}
}

func (_m *FutureFileReaderInterface) OnCacheExistsMatch(matchers ...interface{}) *FutureFileReaderInterface_CacheExists {
	c_call := _m.On("CacheExists", matchers...)
	return &FutureFileReaderInterface_CacheExists{Call: c_call}
}

// CacheExists provides a mock function with given fields: ctx
func (_m *FutureFileReaderInterface) CacheExists(ctx context.Context) (bool, error) {
	ret := _m.Called(ctx)

	var r0 bool
	if rf, ok := ret.Get(0).(func(context.Context) bool); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type FutureFileReaderInterface_Exists struct {
	*mock.Call
}

func (_m FutureFileReaderInterface_Exists) Return(_a0 bool, _a1 error) *FutureFileReaderInterface_Exists {
	return &FutureFileReaderInterface_Exists{Call: _m.Call.Return(_a0, _a1)}
}

func (_m *FutureFileReaderInterface) OnExists(ctx context.Context) *FutureFileReaderInterface_Exists {
	c_call := _m.On("Exists", ctx)
	return &FutureFileReaderInterface_Exists{Call: c_call}
}

func (_m *FutureFileReaderInterface) OnExistsMatch(matchers ...interface{}) *FutureFileReaderInterface_Exists {
	c_call := _m.On("Exists", matchers...)
	return &FutureFileReaderInterface_Exists{Call: c_call}
}

// Exists provides a mock function with given fields: ctx
func (_m *FutureFileReaderInterface) Exists(ctx context.Context) (bool, error) {
	ret := _m.Called(ctx)

	var r0 bool
	if rf, ok := ret.Get(0).(func(context.Context) bool); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type FutureFileReaderInterface_GetLoc struct {
	*mock.Call
}

func (_m FutureFileReaderInterface_GetLoc) Return(_a0 storage.DataReference) *FutureFileReaderInterface_GetLoc {
	return &FutureFileReaderInterface_GetLoc{Call: _m.Call.Return(_a0)}
}

func (_m *FutureFileReaderInterface) OnGetLoc() *FutureFileReaderInterface_GetLoc {
	c_call := _m.On("GetLoc")
	return &FutureFileReaderInterface_GetLoc{Call: c_call}
}

func (_m *FutureFileReaderInterface) OnGetLocMatch(matchers ...interface{}) *FutureFileReaderInterface_GetLoc {
	c_call := _m.On("GetLoc", matchers...)
	return &FutureFileReaderInterface_GetLoc{Call: c_call}
}

// GetLoc provides a mock function with given fields:
func (_m *FutureFileReaderInterface) GetLoc() storage.DataReference {
	ret := _m.Called()

	var r0 storage.DataReference
	if rf, ok := ret.Get(0).(func() storage.DataReference); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(storage.DataReference)
	}

	return r0
}

type FutureFileReaderInterface_Read struct {
	*mock.Call
}

func (_m FutureFileReaderInterface_Read) Return(_a0 *core.DynamicJobSpec, _a1 error) *FutureFileReaderInterface_Read {
	return &FutureFileReaderInterface_Read{Call: _m.Call.Return(_a0, _a1)}
}

func (_m *FutureFileReaderInterface) OnRead(ctx context.Context) *FutureFileReaderInterface_Read {
	c_call := _m.On("Read", ctx)
	return &FutureFileReaderInterface_Read{Call: c_call}
}

func (_m *FutureFileReaderInterface) OnReadMatch(matchers ...interface{}) *FutureFileReaderInterface_Read {
	c_call := _m.On("Read", matchers...)
	return &FutureFileReaderInterface_Read{Call: c_call}
}

// Read provides a mock function with given fields: ctx
func (_m *FutureFileReaderInterface) Read(ctx context.Context) (*core.DynamicJobSpec, error) {
	ret := _m.Called(ctx)

	var r0 *core.DynamicJobSpec
	if rf, ok := ret.Get(0).(func(context.Context) *core.DynamicJobSpec); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.DynamicJobSpec)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type FutureFileReaderInterface_RetrieveCache struct {
	*mock.Call
}

func (_m FutureFileReaderInterface_RetrieveCache) Return(_a0 task.CacheContents, _a1 error) *FutureFileReaderInterface_RetrieveCache {
	return &FutureFileReaderInterface_RetrieveCache{Call: _m.Call.Return(_a0, _a1)}
}

func (_m *FutureFileReaderInterface) OnRetrieveCache(ctx context.Context) *FutureFileReaderInterface_RetrieveCache {
	c_call := _m.On("RetrieveCache", ctx)
	return &FutureFileReaderInterface_RetrieveCache{Call: c_call}
}

func (_m *FutureFileReaderInterface) OnRetrieveCacheMatch(matchers ...interface{}) *FutureFileReaderInterface_RetrieveCache {
	c_call := _m.On("RetrieveCache", matchers...)
	return &FutureFileReaderInterface_RetrieveCache{Call: c_call}
}

// RetrieveCache provides a mock function with given fields: ctx
func (_m *FutureFileReaderInterface) RetrieveCache(ctx context.Context) (task.CacheContents, error) {
	ret := _m.Called(ctx)

	var r0 task.CacheContents
	if rf, ok := ret.Get(0).(func(context.Context) task.CacheContents); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(task.CacheContents)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}
