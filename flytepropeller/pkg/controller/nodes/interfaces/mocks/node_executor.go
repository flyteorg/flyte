// Code generated by mockery v1.0.1. DO NOT EDIT.

package mocks

import (
	context "context"

	executors "github.com/flyteorg/flytepropeller/pkg/controller/executors"
	interfaces "github.com/flyteorg/flytepropeller/pkg/controller/nodes/interfaces"

	mock "github.com/stretchr/testify/mock"
)

// NodeExecutor is an autogenerated mock type for the NodeExecutor type
type NodeExecutor struct {
	mock.Mock
}

type NodeExecutor_Abort struct {
	*mock.Call
}

func (_m NodeExecutor_Abort) Return(_a0 error) *NodeExecutor_Abort {
	return &NodeExecutor_Abort{Call: _m.Call.Return(_a0)}
}

func (_m *NodeExecutor) OnAbort(ctx context.Context, h interfaces.NodeHandler, nCtx interfaces.NodeExecutionContext, reason string, finalTransition bool) *NodeExecutor_Abort {
	c_call := _m.On("Abort", ctx, h, nCtx, reason, finalTransition)
	return &NodeExecutor_Abort{Call: c_call}
}

func (_m *NodeExecutor) OnAbortMatch(matchers ...interface{}) *NodeExecutor_Abort {
	c_call := _m.On("Abort", matchers...)
	return &NodeExecutor_Abort{Call: c_call}
}

// Abort provides a mock function with given fields: ctx, h, nCtx, reason, finalTransition
func (_m *NodeExecutor) Abort(ctx context.Context, h interfaces.NodeHandler, nCtx interfaces.NodeExecutionContext, reason string, finalTransition bool) error {
	ret := _m.Called(ctx, h, nCtx, reason, finalTransition)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, interfaces.NodeHandler, interfaces.NodeExecutionContext, string, bool) error); ok {
		r0 = rf(ctx, h, nCtx, reason, finalTransition)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type NodeExecutor_Finalize struct {
	*mock.Call
}

func (_m NodeExecutor_Finalize) Return(_a0 error) *NodeExecutor_Finalize {
	return &NodeExecutor_Finalize{Call: _m.Call.Return(_a0)}
}

func (_m *NodeExecutor) OnFinalize(ctx context.Context, h interfaces.NodeHandler, nCtx interfaces.NodeExecutionContext) *NodeExecutor_Finalize {
	c_call := _m.On("Finalize", ctx, h, nCtx)
	return &NodeExecutor_Finalize{Call: c_call}
}

func (_m *NodeExecutor) OnFinalizeMatch(matchers ...interface{}) *NodeExecutor_Finalize {
	c_call := _m.On("Finalize", matchers...)
	return &NodeExecutor_Finalize{Call: c_call}
}

// Finalize provides a mock function with given fields: ctx, h, nCtx
func (_m *NodeExecutor) Finalize(ctx context.Context, h interfaces.NodeHandler, nCtx interfaces.NodeExecutionContext) error {
	ret := _m.Called(ctx, h, nCtx)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, interfaces.NodeHandler, interfaces.NodeExecutionContext) error); ok {
		r0 = rf(ctx, h, nCtx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type NodeExecutor_HandleNode struct {
	*mock.Call
}

func (_m NodeExecutor_HandleNode) Return(_a0 interfaces.NodeStatus, _a1 error) *NodeExecutor_HandleNode {
	return &NodeExecutor_HandleNode{Call: _m.Call.Return(_a0, _a1)}
}

func (_m *NodeExecutor) OnHandleNode(ctx context.Context, dag executors.DAGStructure, nCtx interfaces.NodeExecutionContext, h interfaces.NodeHandler) *NodeExecutor_HandleNode {
	c_call := _m.On("HandleNode", ctx, dag, nCtx, h)
	return &NodeExecutor_HandleNode{Call: c_call}
}

func (_m *NodeExecutor) OnHandleNodeMatch(matchers ...interface{}) *NodeExecutor_HandleNode {
	c_call := _m.On("HandleNode", matchers...)
	return &NodeExecutor_HandleNode{Call: c_call}
}

// HandleNode provides a mock function with given fields: ctx, dag, nCtx, h
func (_m *NodeExecutor) HandleNode(ctx context.Context, dag executors.DAGStructure, nCtx interfaces.NodeExecutionContext, h interfaces.NodeHandler) (interfaces.NodeStatus, error) {
	ret := _m.Called(ctx, dag, nCtx, h)

	var r0 interfaces.NodeStatus
	if rf, ok := ret.Get(0).(func(context.Context, executors.DAGStructure, interfaces.NodeExecutionContext, interfaces.NodeHandler) interfaces.NodeStatus); ok {
		r0 = rf(ctx, dag, nCtx, h)
	} else {
		r0 = ret.Get(0).(interfaces.NodeStatus)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, executors.DAGStructure, interfaces.NodeExecutionContext, interfaces.NodeHandler) error); ok {
		r1 = rf(ctx, dag, nCtx, h)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}
