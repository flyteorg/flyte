// Code generated by mockery v1.0.1. DO NOT EDIT.

package mocks

import (
	context "context"

	core "github.com/flyteorg/flyte/flyteidl/gen/pb-go/flyteidl/core"
	mock "github.com/stretchr/testify/mock"

	types "k8s.io/apimachinery/pkg/types"

	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"

	v1alpha1 "github.com/flyteorg/flyte/flytepropeller/pkg/apis/flyteworkflow/v1alpha1"
)

// ExecutableWorkflow is an autogenerated mock type for the ExecutableWorkflow type
type ExecutableWorkflow struct {
	mock.Mock
}

type ExecutableWorkflow_FindSubWorkflow struct {
	*mock.Call
}

func (_m ExecutableWorkflow_FindSubWorkflow) Return(_a0 v1alpha1.ExecutableSubWorkflow) *ExecutableWorkflow_FindSubWorkflow {
	return &ExecutableWorkflow_FindSubWorkflow{Call: _m.Call.Return(_a0)}
}

func (_m *ExecutableWorkflow) OnFindSubWorkflow(subID string) *ExecutableWorkflow_FindSubWorkflow {
	c_call := _m.On("FindSubWorkflow", subID)
	return &ExecutableWorkflow_FindSubWorkflow{Call: c_call}
}

func (_m *ExecutableWorkflow) OnFindSubWorkflowMatch(matchers ...interface{}) *ExecutableWorkflow_FindSubWorkflow {
	c_call := _m.On("FindSubWorkflow", matchers...)
	return &ExecutableWorkflow_FindSubWorkflow{Call: c_call}
}

// FindSubWorkflow provides a mock function with given fields: subID
func (_m *ExecutableWorkflow) FindSubWorkflow(subID string) v1alpha1.ExecutableSubWorkflow {
	ret := _m.Called(subID)

	var r0 v1alpha1.ExecutableSubWorkflow
	if rf, ok := ret.Get(0).(func(string) v1alpha1.ExecutableSubWorkflow); ok {
		r0 = rf(subID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(v1alpha1.ExecutableSubWorkflow)
		}
	}

	return r0
}

type ExecutableWorkflow_FromNode struct {
	*mock.Call
}

func (_m ExecutableWorkflow_FromNode) Return(_a0 []string, _a1 error) *ExecutableWorkflow_FromNode {
	return &ExecutableWorkflow_FromNode{Call: _m.Call.Return(_a0, _a1)}
}

func (_m *ExecutableWorkflow) OnFromNode(name string) *ExecutableWorkflow_FromNode {
	c_call := _m.On("FromNode", name)
	return &ExecutableWorkflow_FromNode{Call: c_call}
}

func (_m *ExecutableWorkflow) OnFromNodeMatch(matchers ...interface{}) *ExecutableWorkflow_FromNode {
	c_call := _m.On("FromNode", matchers...)
	return &ExecutableWorkflow_FromNode{Call: c_call}
}

// FromNode provides a mock function with given fields: name
func (_m *ExecutableWorkflow) FromNode(name string) ([]string, error) {
	ret := _m.Called(name)

	var r0 []string
	if rf, ok := ret.Get(0).(func(string) []string); ok {
		r0 = rf(name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type ExecutableWorkflow_GetAnnotations struct {
	*mock.Call
}

func (_m ExecutableWorkflow_GetAnnotations) Return(_a0 map[string]string) *ExecutableWorkflow_GetAnnotations {
	return &ExecutableWorkflow_GetAnnotations{Call: _m.Call.Return(_a0)}
}

func (_m *ExecutableWorkflow) OnGetAnnotations() *ExecutableWorkflow_GetAnnotations {
	c_call := _m.On("GetAnnotations")
	return &ExecutableWorkflow_GetAnnotations{Call: c_call}
}

func (_m *ExecutableWorkflow) OnGetAnnotationsMatch(matchers ...interface{}) *ExecutableWorkflow_GetAnnotations {
	c_call := _m.On("GetAnnotations", matchers...)
	return &ExecutableWorkflow_GetAnnotations{Call: c_call}
}

// GetAnnotations provides a mock function with given fields:
func (_m *ExecutableWorkflow) GetAnnotations() map[string]string {
	ret := _m.Called()

	var r0 map[string]string
	if rf, ok := ret.Get(0).(func() map[string]string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]string)
		}
	}

	return r0
}

type ExecutableWorkflow_GetConnections struct {
	*mock.Call
}

func (_m ExecutableWorkflow_GetConnections) Return(_a0 *v1alpha1.Connections) *ExecutableWorkflow_GetConnections {
	return &ExecutableWorkflow_GetConnections{Call: _m.Call.Return(_a0)}
}

func (_m *ExecutableWorkflow) OnGetConnections() *ExecutableWorkflow_GetConnections {
	c_call := _m.On("GetConnections")
	return &ExecutableWorkflow_GetConnections{Call: c_call}
}

func (_m *ExecutableWorkflow) OnGetConnectionsMatch(matchers ...interface{}) *ExecutableWorkflow_GetConnections {
	c_call := _m.On("GetConnections", matchers...)
	return &ExecutableWorkflow_GetConnections{Call: c_call}
}

// GetConnections provides a mock function with given fields:
func (_m *ExecutableWorkflow) GetConnections() *v1alpha1.Connections {
	ret := _m.Called()

	var r0 *v1alpha1.Connections
	if rf, ok := ret.Get(0).(func() *v1alpha1.Connections); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1alpha1.Connections)
		}
	}

	return r0
}

type ExecutableWorkflow_GetConsoleURL struct {
	*mock.Call
}

func (_m ExecutableWorkflow_GetConsoleURL) Return(_a0 string) *ExecutableWorkflow_GetConsoleURL {
	return &ExecutableWorkflow_GetConsoleURL{Call: _m.Call.Return(_a0)}
}

func (_m *ExecutableWorkflow) OnGetConsoleURL() *ExecutableWorkflow_GetConsoleURL {
	c_call := _m.On("GetConsoleURL")
	return &ExecutableWorkflow_GetConsoleURL{Call: c_call}
}

func (_m *ExecutableWorkflow) OnGetConsoleURLMatch(matchers ...interface{}) *ExecutableWorkflow_GetConsoleURL {
	c_call := _m.On("GetConsoleURL", matchers...)
	return &ExecutableWorkflow_GetConsoleURL{Call: c_call}
}

// GetConsoleURL provides a mock function with given fields:
func (_m *ExecutableWorkflow) GetConsoleURL() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

type ExecutableWorkflow_GetCreationTimestamp struct {
	*mock.Call
}

func (_m ExecutableWorkflow_GetCreationTimestamp) Return(_a0 v1.Time) *ExecutableWorkflow_GetCreationTimestamp {
	return &ExecutableWorkflow_GetCreationTimestamp{Call: _m.Call.Return(_a0)}
}

func (_m *ExecutableWorkflow) OnGetCreationTimestamp() *ExecutableWorkflow_GetCreationTimestamp {
	c_call := _m.On("GetCreationTimestamp")
	return &ExecutableWorkflow_GetCreationTimestamp{Call: c_call}
}

func (_m *ExecutableWorkflow) OnGetCreationTimestampMatch(matchers ...interface{}) *ExecutableWorkflow_GetCreationTimestamp {
	c_call := _m.On("GetCreationTimestamp", matchers...)
	return &ExecutableWorkflow_GetCreationTimestamp{Call: c_call}
}

// GetCreationTimestamp provides a mock function with given fields:
func (_m *ExecutableWorkflow) GetCreationTimestamp() v1.Time {
	ret := _m.Called()

	var r0 v1.Time
	if rf, ok := ret.Get(0).(func() v1.Time); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(v1.Time)
	}

	return r0
}

type ExecutableWorkflow_GetDefinitionVersion struct {
	*mock.Call
}

func (_m ExecutableWorkflow_GetDefinitionVersion) Return(_a0 v1alpha1.WorkflowDefinitionVersion) *ExecutableWorkflow_GetDefinitionVersion {
	return &ExecutableWorkflow_GetDefinitionVersion{Call: _m.Call.Return(_a0)}
}

func (_m *ExecutableWorkflow) OnGetDefinitionVersion() *ExecutableWorkflow_GetDefinitionVersion {
	c_call := _m.On("GetDefinitionVersion")
	return &ExecutableWorkflow_GetDefinitionVersion{Call: c_call}
}

func (_m *ExecutableWorkflow) OnGetDefinitionVersionMatch(matchers ...interface{}) *ExecutableWorkflow_GetDefinitionVersion {
	c_call := _m.On("GetDefinitionVersion", matchers...)
	return &ExecutableWorkflow_GetDefinitionVersion{Call: c_call}
}

// GetDefinitionVersion provides a mock function with given fields:
func (_m *ExecutableWorkflow) GetDefinitionVersion() v1alpha1.WorkflowDefinitionVersion {
	ret := _m.Called()

	var r0 v1alpha1.WorkflowDefinitionVersion
	if rf, ok := ret.Get(0).(func() v1alpha1.WorkflowDefinitionVersion); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(v1alpha1.WorkflowDefinitionVersion)
	}

	return r0
}

type ExecutableWorkflow_GetEventVersion struct {
	*mock.Call
}

func (_m ExecutableWorkflow_GetEventVersion) Return(_a0 v1alpha1.EventVersion) *ExecutableWorkflow_GetEventVersion {
	return &ExecutableWorkflow_GetEventVersion{Call: _m.Call.Return(_a0)}
}

func (_m *ExecutableWorkflow) OnGetEventVersion() *ExecutableWorkflow_GetEventVersion {
	c_call := _m.On("GetEventVersion")
	return &ExecutableWorkflow_GetEventVersion{Call: c_call}
}

func (_m *ExecutableWorkflow) OnGetEventVersionMatch(matchers ...interface{}) *ExecutableWorkflow_GetEventVersion {
	c_call := _m.On("GetEventVersion", matchers...)
	return &ExecutableWorkflow_GetEventVersion{Call: c_call}
}

// GetEventVersion provides a mock function with given fields:
func (_m *ExecutableWorkflow) GetEventVersion() v1alpha1.EventVersion {
	ret := _m.Called()

	var r0 v1alpha1.EventVersion
	if rf, ok := ret.Get(0).(func() v1alpha1.EventVersion); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(v1alpha1.EventVersion)
	}

	return r0
}

type ExecutableWorkflow_GetExecutionConfig struct {
	*mock.Call
}

func (_m ExecutableWorkflow_GetExecutionConfig) Return(_a0 v1alpha1.ExecutionConfig) *ExecutableWorkflow_GetExecutionConfig {
	return &ExecutableWorkflow_GetExecutionConfig{Call: _m.Call.Return(_a0)}
}

func (_m *ExecutableWorkflow) OnGetExecutionConfig() *ExecutableWorkflow_GetExecutionConfig {
	c_call := _m.On("GetExecutionConfig")
	return &ExecutableWorkflow_GetExecutionConfig{Call: c_call}
}

func (_m *ExecutableWorkflow) OnGetExecutionConfigMatch(matchers ...interface{}) *ExecutableWorkflow_GetExecutionConfig {
	c_call := _m.On("GetExecutionConfig", matchers...)
	return &ExecutableWorkflow_GetExecutionConfig{Call: c_call}
}

// GetExecutionConfig provides a mock function with given fields:
func (_m *ExecutableWorkflow) GetExecutionConfig() v1alpha1.ExecutionConfig {
	ret := _m.Called()

	var r0 v1alpha1.ExecutionConfig
	if rf, ok := ret.Get(0).(func() v1alpha1.ExecutionConfig); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(v1alpha1.ExecutionConfig)
	}

	return r0
}

type ExecutableWorkflow_GetExecutionID struct {
	*mock.Call
}

func (_m ExecutableWorkflow_GetExecutionID) Return(_a0 v1alpha1.WorkflowExecutionIdentifier) *ExecutableWorkflow_GetExecutionID {
	return &ExecutableWorkflow_GetExecutionID{Call: _m.Call.Return(_a0)}
}

func (_m *ExecutableWorkflow) OnGetExecutionID() *ExecutableWorkflow_GetExecutionID {
	c_call := _m.On("GetExecutionID")
	return &ExecutableWorkflow_GetExecutionID{Call: c_call}
}

func (_m *ExecutableWorkflow) OnGetExecutionIDMatch(matchers ...interface{}) *ExecutableWorkflow_GetExecutionID {
	c_call := _m.On("GetExecutionID", matchers...)
	return &ExecutableWorkflow_GetExecutionID{Call: c_call}
}

// GetExecutionID provides a mock function with given fields:
func (_m *ExecutableWorkflow) GetExecutionID() v1alpha1.WorkflowExecutionIdentifier {
	ret := _m.Called()

	var r0 v1alpha1.WorkflowExecutionIdentifier
	if rf, ok := ret.Get(0).(func() v1alpha1.WorkflowExecutionIdentifier); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(v1alpha1.WorkflowExecutionIdentifier)
	}

	return r0
}

type ExecutableWorkflow_GetExecutionStatus struct {
	*mock.Call
}

func (_m ExecutableWorkflow_GetExecutionStatus) Return(_a0 v1alpha1.ExecutableWorkflowStatus) *ExecutableWorkflow_GetExecutionStatus {
	return &ExecutableWorkflow_GetExecutionStatus{Call: _m.Call.Return(_a0)}
}

func (_m *ExecutableWorkflow) OnGetExecutionStatus() *ExecutableWorkflow_GetExecutionStatus {
	c_call := _m.On("GetExecutionStatus")
	return &ExecutableWorkflow_GetExecutionStatus{Call: c_call}
}

func (_m *ExecutableWorkflow) OnGetExecutionStatusMatch(matchers ...interface{}) *ExecutableWorkflow_GetExecutionStatus {
	c_call := _m.On("GetExecutionStatus", matchers...)
	return &ExecutableWorkflow_GetExecutionStatus{Call: c_call}
}

// GetExecutionStatus provides a mock function with given fields:
func (_m *ExecutableWorkflow) GetExecutionStatus() v1alpha1.ExecutableWorkflowStatus {
	ret := _m.Called()

	var r0 v1alpha1.ExecutableWorkflowStatus
	if rf, ok := ret.Get(0).(func() v1alpha1.ExecutableWorkflowStatus); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(v1alpha1.ExecutableWorkflowStatus)
		}
	}

	return r0
}

type ExecutableWorkflow_GetID struct {
	*mock.Call
}

func (_m ExecutableWorkflow_GetID) Return(_a0 string) *ExecutableWorkflow_GetID {
	return &ExecutableWorkflow_GetID{Call: _m.Call.Return(_a0)}
}

func (_m *ExecutableWorkflow) OnGetID() *ExecutableWorkflow_GetID {
	c_call := _m.On("GetID")
	return &ExecutableWorkflow_GetID{Call: c_call}
}

func (_m *ExecutableWorkflow) OnGetIDMatch(matchers ...interface{}) *ExecutableWorkflow_GetID {
	c_call := _m.On("GetID", matchers...)
	return &ExecutableWorkflow_GetID{Call: c_call}
}

// GetID provides a mock function with given fields:
func (_m *ExecutableWorkflow) GetID() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

type ExecutableWorkflow_GetK8sWorkflowID struct {
	*mock.Call
}

func (_m ExecutableWorkflow_GetK8sWorkflowID) Return(_a0 types.NamespacedName) *ExecutableWorkflow_GetK8sWorkflowID {
	return &ExecutableWorkflow_GetK8sWorkflowID{Call: _m.Call.Return(_a0)}
}

func (_m *ExecutableWorkflow) OnGetK8sWorkflowID() *ExecutableWorkflow_GetK8sWorkflowID {
	c_call := _m.On("GetK8sWorkflowID")
	return &ExecutableWorkflow_GetK8sWorkflowID{Call: c_call}
}

func (_m *ExecutableWorkflow) OnGetK8sWorkflowIDMatch(matchers ...interface{}) *ExecutableWorkflow_GetK8sWorkflowID {
	c_call := _m.On("GetK8sWorkflowID", matchers...)
	return &ExecutableWorkflow_GetK8sWorkflowID{Call: c_call}
}

// GetK8sWorkflowID provides a mock function with given fields:
func (_m *ExecutableWorkflow) GetK8sWorkflowID() types.NamespacedName {
	ret := _m.Called()

	var r0 types.NamespacedName
	if rf, ok := ret.Get(0).(func() types.NamespacedName); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(types.NamespacedName)
	}

	return r0
}

type ExecutableWorkflow_GetLabels struct {
	*mock.Call
}

func (_m ExecutableWorkflow_GetLabels) Return(_a0 map[string]string) *ExecutableWorkflow_GetLabels {
	return &ExecutableWorkflow_GetLabels{Call: _m.Call.Return(_a0)}
}

func (_m *ExecutableWorkflow) OnGetLabels() *ExecutableWorkflow_GetLabels {
	c_call := _m.On("GetLabels")
	return &ExecutableWorkflow_GetLabels{Call: c_call}
}

func (_m *ExecutableWorkflow) OnGetLabelsMatch(matchers ...interface{}) *ExecutableWorkflow_GetLabels {
	c_call := _m.On("GetLabels", matchers...)
	return &ExecutableWorkflow_GetLabels{Call: c_call}
}

// GetLabels provides a mock function with given fields:
func (_m *ExecutableWorkflow) GetLabels() map[string]string {
	ret := _m.Called()

	var r0 map[string]string
	if rf, ok := ret.Get(0).(func() map[string]string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]string)
		}
	}

	return r0
}

type ExecutableWorkflow_GetName struct {
	*mock.Call
}

func (_m ExecutableWorkflow_GetName) Return(_a0 string) *ExecutableWorkflow_GetName {
	return &ExecutableWorkflow_GetName{Call: _m.Call.Return(_a0)}
}

func (_m *ExecutableWorkflow) OnGetName() *ExecutableWorkflow_GetName {
	c_call := _m.On("GetName")
	return &ExecutableWorkflow_GetName{Call: c_call}
}

func (_m *ExecutableWorkflow) OnGetNameMatch(matchers ...interface{}) *ExecutableWorkflow_GetName {
	c_call := _m.On("GetName", matchers...)
	return &ExecutableWorkflow_GetName{Call: c_call}
}

// GetName provides a mock function with given fields:
func (_m *ExecutableWorkflow) GetName() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

type ExecutableWorkflow_GetNamespace struct {
	*mock.Call
}

func (_m ExecutableWorkflow_GetNamespace) Return(_a0 string) *ExecutableWorkflow_GetNamespace {
	return &ExecutableWorkflow_GetNamespace{Call: _m.Call.Return(_a0)}
}

func (_m *ExecutableWorkflow) OnGetNamespace() *ExecutableWorkflow_GetNamespace {
	c_call := _m.On("GetNamespace")
	return &ExecutableWorkflow_GetNamespace{Call: c_call}
}

func (_m *ExecutableWorkflow) OnGetNamespaceMatch(matchers ...interface{}) *ExecutableWorkflow_GetNamespace {
	c_call := _m.On("GetNamespace", matchers...)
	return &ExecutableWorkflow_GetNamespace{Call: c_call}
}

// GetNamespace provides a mock function with given fields:
func (_m *ExecutableWorkflow) GetNamespace() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

type ExecutableWorkflow_GetNode struct {
	*mock.Call
}

func (_m ExecutableWorkflow_GetNode) Return(_a0 v1alpha1.ExecutableNode, _a1 bool) *ExecutableWorkflow_GetNode {
	return &ExecutableWorkflow_GetNode{Call: _m.Call.Return(_a0, _a1)}
}

func (_m *ExecutableWorkflow) OnGetNode(nodeID string) *ExecutableWorkflow_GetNode {
	c_call := _m.On("GetNode", nodeID)
	return &ExecutableWorkflow_GetNode{Call: c_call}
}

func (_m *ExecutableWorkflow) OnGetNodeMatch(matchers ...interface{}) *ExecutableWorkflow_GetNode {
	c_call := _m.On("GetNode", matchers...)
	return &ExecutableWorkflow_GetNode{Call: c_call}
}

// GetNode provides a mock function with given fields: nodeID
func (_m *ExecutableWorkflow) GetNode(nodeID string) (v1alpha1.ExecutableNode, bool) {
	ret := _m.Called(nodeID)

	var r0 v1alpha1.ExecutableNode
	if rf, ok := ret.Get(0).(func(string) v1alpha1.ExecutableNode); ok {
		r0 = rf(nodeID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(v1alpha1.ExecutableNode)
		}
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func(string) bool); ok {
		r1 = rf(nodeID)
	} else {
		r1 = ret.Get(1).(bool)
	}

	return r0, r1
}

type ExecutableWorkflow_GetNodeExecutionStatus struct {
	*mock.Call
}

func (_m ExecutableWorkflow_GetNodeExecutionStatus) Return(_a0 v1alpha1.ExecutableNodeStatus) *ExecutableWorkflow_GetNodeExecutionStatus {
	return &ExecutableWorkflow_GetNodeExecutionStatus{Call: _m.Call.Return(_a0)}
}

func (_m *ExecutableWorkflow) OnGetNodeExecutionStatus(ctx context.Context, id string) *ExecutableWorkflow_GetNodeExecutionStatus {
	c_call := _m.On("GetNodeExecutionStatus", ctx, id)
	return &ExecutableWorkflow_GetNodeExecutionStatus{Call: c_call}
}

func (_m *ExecutableWorkflow) OnGetNodeExecutionStatusMatch(matchers ...interface{}) *ExecutableWorkflow_GetNodeExecutionStatus {
	c_call := _m.On("GetNodeExecutionStatus", matchers...)
	return &ExecutableWorkflow_GetNodeExecutionStatus{Call: c_call}
}

// GetNodeExecutionStatus provides a mock function with given fields: ctx, id
func (_m *ExecutableWorkflow) GetNodeExecutionStatus(ctx context.Context, id string) v1alpha1.ExecutableNodeStatus {
	ret := _m.Called(ctx, id)

	var r0 v1alpha1.ExecutableNodeStatus
	if rf, ok := ret.Get(0).(func(context.Context, string) v1alpha1.ExecutableNodeStatus); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(v1alpha1.ExecutableNodeStatus)
		}
	}

	return r0
}

type ExecutableWorkflow_GetNodes struct {
	*mock.Call
}

func (_m ExecutableWorkflow_GetNodes) Return(_a0 []string) *ExecutableWorkflow_GetNodes {
	return &ExecutableWorkflow_GetNodes{Call: _m.Call.Return(_a0)}
}

func (_m *ExecutableWorkflow) OnGetNodes() *ExecutableWorkflow_GetNodes {
	c_call := _m.On("GetNodes")
	return &ExecutableWorkflow_GetNodes{Call: c_call}
}

func (_m *ExecutableWorkflow) OnGetNodesMatch(matchers ...interface{}) *ExecutableWorkflow_GetNodes {
	c_call := _m.On("GetNodes", matchers...)
	return &ExecutableWorkflow_GetNodes{Call: c_call}
}

// GetNodes provides a mock function with given fields:
func (_m *ExecutableWorkflow) GetNodes() []string {
	ret := _m.Called()

	var r0 []string
	if rf, ok := ret.Get(0).(func() []string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	return r0
}

type ExecutableWorkflow_GetOnFailureNode struct {
	*mock.Call
}

func (_m ExecutableWorkflow_GetOnFailureNode) Return(_a0 v1alpha1.ExecutableNode) *ExecutableWorkflow_GetOnFailureNode {
	return &ExecutableWorkflow_GetOnFailureNode{Call: _m.Call.Return(_a0)}
}

func (_m *ExecutableWorkflow) OnGetOnFailureNode() *ExecutableWorkflow_GetOnFailureNode {
	c_call := _m.On("GetOnFailureNode")
	return &ExecutableWorkflow_GetOnFailureNode{Call: c_call}
}

func (_m *ExecutableWorkflow) OnGetOnFailureNodeMatch(matchers ...interface{}) *ExecutableWorkflow_GetOnFailureNode {
	c_call := _m.On("GetOnFailureNode", matchers...)
	return &ExecutableWorkflow_GetOnFailureNode{Call: c_call}
}

// GetOnFailureNode provides a mock function with given fields:
func (_m *ExecutableWorkflow) GetOnFailureNode() v1alpha1.ExecutableNode {
	ret := _m.Called()

	var r0 v1alpha1.ExecutableNode
	if rf, ok := ret.Get(0).(func() v1alpha1.ExecutableNode); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(v1alpha1.ExecutableNode)
		}
	}

	return r0
}

type ExecutableWorkflow_GetOnFailurePolicy struct {
	*mock.Call
}

func (_m ExecutableWorkflow_GetOnFailurePolicy) Return(_a0 v1alpha1.WorkflowOnFailurePolicy) *ExecutableWorkflow_GetOnFailurePolicy {
	return &ExecutableWorkflow_GetOnFailurePolicy{Call: _m.Call.Return(_a0)}
}

func (_m *ExecutableWorkflow) OnGetOnFailurePolicy() *ExecutableWorkflow_GetOnFailurePolicy {
	c_call := _m.On("GetOnFailurePolicy")
	return &ExecutableWorkflow_GetOnFailurePolicy{Call: c_call}
}

func (_m *ExecutableWorkflow) OnGetOnFailurePolicyMatch(matchers ...interface{}) *ExecutableWorkflow_GetOnFailurePolicy {
	c_call := _m.On("GetOnFailurePolicy", matchers...)
	return &ExecutableWorkflow_GetOnFailurePolicy{Call: c_call}
}

// GetOnFailurePolicy provides a mock function with given fields:
func (_m *ExecutableWorkflow) GetOnFailurePolicy() v1alpha1.WorkflowOnFailurePolicy {
	ret := _m.Called()

	var r0 v1alpha1.WorkflowOnFailurePolicy
	if rf, ok := ret.Get(0).(func() v1alpha1.WorkflowOnFailurePolicy); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(v1alpha1.WorkflowOnFailurePolicy)
	}

	return r0
}

type ExecutableWorkflow_GetOutputBindings struct {
	*mock.Call
}

func (_m ExecutableWorkflow_GetOutputBindings) Return(_a0 []*v1alpha1.Binding) *ExecutableWorkflow_GetOutputBindings {
	return &ExecutableWorkflow_GetOutputBindings{Call: _m.Call.Return(_a0)}
}

func (_m *ExecutableWorkflow) OnGetOutputBindings() *ExecutableWorkflow_GetOutputBindings {
	c_call := _m.On("GetOutputBindings")
	return &ExecutableWorkflow_GetOutputBindings{Call: c_call}
}

func (_m *ExecutableWorkflow) OnGetOutputBindingsMatch(matchers ...interface{}) *ExecutableWorkflow_GetOutputBindings {
	c_call := _m.On("GetOutputBindings", matchers...)
	return &ExecutableWorkflow_GetOutputBindings{Call: c_call}
}

// GetOutputBindings provides a mock function with given fields:
func (_m *ExecutableWorkflow) GetOutputBindings() []*v1alpha1.Binding {
	ret := _m.Called()

	var r0 []*v1alpha1.Binding
	if rf, ok := ret.Get(0).(func() []*v1alpha1.Binding); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*v1alpha1.Binding)
		}
	}

	return r0
}

type ExecutableWorkflow_GetOutputs struct {
	*mock.Call
}

func (_m ExecutableWorkflow_GetOutputs) Return(_a0 *v1alpha1.OutputVarMap) *ExecutableWorkflow_GetOutputs {
	return &ExecutableWorkflow_GetOutputs{Call: _m.Call.Return(_a0)}
}

func (_m *ExecutableWorkflow) OnGetOutputs() *ExecutableWorkflow_GetOutputs {
	c_call := _m.On("GetOutputs")
	return &ExecutableWorkflow_GetOutputs{Call: c_call}
}

func (_m *ExecutableWorkflow) OnGetOutputsMatch(matchers ...interface{}) *ExecutableWorkflow_GetOutputs {
	c_call := _m.On("GetOutputs", matchers...)
	return &ExecutableWorkflow_GetOutputs{Call: c_call}
}

// GetOutputs provides a mock function with given fields:
func (_m *ExecutableWorkflow) GetOutputs() *v1alpha1.OutputVarMap {
	ret := _m.Called()

	var r0 *v1alpha1.OutputVarMap
	if rf, ok := ret.Get(0).(func() *v1alpha1.OutputVarMap); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1alpha1.OutputVarMap)
		}
	}

	return r0
}

type ExecutableWorkflow_GetOwnerReference struct {
	*mock.Call
}

func (_m ExecutableWorkflow_GetOwnerReference) Return(_a0 v1.OwnerReference) *ExecutableWorkflow_GetOwnerReference {
	return &ExecutableWorkflow_GetOwnerReference{Call: _m.Call.Return(_a0)}
}

func (_m *ExecutableWorkflow) OnGetOwnerReference() *ExecutableWorkflow_GetOwnerReference {
	c_call := _m.On("GetOwnerReference")
	return &ExecutableWorkflow_GetOwnerReference{Call: c_call}
}

func (_m *ExecutableWorkflow) OnGetOwnerReferenceMatch(matchers ...interface{}) *ExecutableWorkflow_GetOwnerReference {
	c_call := _m.On("GetOwnerReference", matchers...)
	return &ExecutableWorkflow_GetOwnerReference{Call: c_call}
}

// GetOwnerReference provides a mock function with given fields:
func (_m *ExecutableWorkflow) GetOwnerReference() v1.OwnerReference {
	ret := _m.Called()

	var r0 v1.OwnerReference
	if rf, ok := ret.Get(0).(func() v1.OwnerReference); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(v1.OwnerReference)
	}

	return r0
}

type ExecutableWorkflow_GetRawOutputDataConfig struct {
	*mock.Call
}

func (_m ExecutableWorkflow_GetRawOutputDataConfig) Return(_a0 v1alpha1.RawOutputDataConfig) *ExecutableWorkflow_GetRawOutputDataConfig {
	return &ExecutableWorkflow_GetRawOutputDataConfig{Call: _m.Call.Return(_a0)}
}

func (_m *ExecutableWorkflow) OnGetRawOutputDataConfig() *ExecutableWorkflow_GetRawOutputDataConfig {
	c_call := _m.On("GetRawOutputDataConfig")
	return &ExecutableWorkflow_GetRawOutputDataConfig{Call: c_call}
}

func (_m *ExecutableWorkflow) OnGetRawOutputDataConfigMatch(matchers ...interface{}) *ExecutableWorkflow_GetRawOutputDataConfig {
	c_call := _m.On("GetRawOutputDataConfig", matchers...)
	return &ExecutableWorkflow_GetRawOutputDataConfig{Call: c_call}
}

// GetRawOutputDataConfig provides a mock function with given fields:
func (_m *ExecutableWorkflow) GetRawOutputDataConfig() v1alpha1.RawOutputDataConfig {
	ret := _m.Called()

	var r0 v1alpha1.RawOutputDataConfig
	if rf, ok := ret.Get(0).(func() v1alpha1.RawOutputDataConfig); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(v1alpha1.RawOutputDataConfig)
	}

	return r0
}

type ExecutableWorkflow_GetSecurityContext struct {
	*mock.Call
}

func (_m ExecutableWorkflow_GetSecurityContext) Return(_a0 core.SecurityContext) *ExecutableWorkflow_GetSecurityContext {
	return &ExecutableWorkflow_GetSecurityContext{Call: _m.Call.Return(_a0)}
}

func (_m *ExecutableWorkflow) OnGetSecurityContext() *ExecutableWorkflow_GetSecurityContext {
	c_call := _m.On("GetSecurityContext")
	return &ExecutableWorkflow_GetSecurityContext{Call: c_call}
}

func (_m *ExecutableWorkflow) OnGetSecurityContextMatch(matchers ...interface{}) *ExecutableWorkflow_GetSecurityContext {
	c_call := _m.On("GetSecurityContext", matchers...)
	return &ExecutableWorkflow_GetSecurityContext{Call: c_call}
}

// GetSecurityContext provides a mock function with given fields:
func (_m *ExecutableWorkflow) GetSecurityContext() core.SecurityContext {
	ret := _m.Called()

	var r0 core.SecurityContext
	if rf, ok := ret.Get(0).(func() core.SecurityContext); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(core.SecurityContext)
	}

	return r0
}

type ExecutableWorkflow_GetServiceAccountName struct {
	*mock.Call
}

func (_m ExecutableWorkflow_GetServiceAccountName) Return(_a0 string) *ExecutableWorkflow_GetServiceAccountName {
	return &ExecutableWorkflow_GetServiceAccountName{Call: _m.Call.Return(_a0)}
}

func (_m *ExecutableWorkflow) OnGetServiceAccountName() *ExecutableWorkflow_GetServiceAccountName {
	c_call := _m.On("GetServiceAccountName")
	return &ExecutableWorkflow_GetServiceAccountName{Call: c_call}
}

func (_m *ExecutableWorkflow) OnGetServiceAccountNameMatch(matchers ...interface{}) *ExecutableWorkflow_GetServiceAccountName {
	c_call := _m.On("GetServiceAccountName", matchers...)
	return &ExecutableWorkflow_GetServiceAccountName{Call: c_call}
}

// GetServiceAccountName provides a mock function with given fields:
func (_m *ExecutableWorkflow) GetServiceAccountName() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

type ExecutableWorkflow_GetTask struct {
	*mock.Call
}

func (_m ExecutableWorkflow_GetTask) Return(_a0 v1alpha1.ExecutableTask, _a1 error) *ExecutableWorkflow_GetTask {
	return &ExecutableWorkflow_GetTask{Call: _m.Call.Return(_a0, _a1)}
}

func (_m *ExecutableWorkflow) OnGetTask(id string) *ExecutableWorkflow_GetTask {
	c_call := _m.On("GetTask", id)
	return &ExecutableWorkflow_GetTask{Call: c_call}
}

func (_m *ExecutableWorkflow) OnGetTaskMatch(matchers ...interface{}) *ExecutableWorkflow_GetTask {
	c_call := _m.On("GetTask", matchers...)
	return &ExecutableWorkflow_GetTask{Call: c_call}
}

// GetTask provides a mock function with given fields: id
func (_m *ExecutableWorkflow) GetTask(id string) (v1alpha1.ExecutableTask, error) {
	ret := _m.Called(id)

	var r0 v1alpha1.ExecutableTask
	if rf, ok := ret.Get(0).(func(string) v1alpha1.ExecutableTask); ok {
		r0 = rf(id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(v1alpha1.ExecutableTask)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type ExecutableWorkflow_IsInterruptible struct {
	*mock.Call
}

func (_m ExecutableWorkflow_IsInterruptible) Return(_a0 bool) *ExecutableWorkflow_IsInterruptible {
	return &ExecutableWorkflow_IsInterruptible{Call: _m.Call.Return(_a0)}
}

func (_m *ExecutableWorkflow) OnIsInterruptible() *ExecutableWorkflow_IsInterruptible {
	c_call := _m.On("IsInterruptible")
	return &ExecutableWorkflow_IsInterruptible{Call: c_call}
}

func (_m *ExecutableWorkflow) OnIsInterruptibleMatch(matchers ...interface{}) *ExecutableWorkflow_IsInterruptible {
	c_call := _m.On("IsInterruptible", matchers...)
	return &ExecutableWorkflow_IsInterruptible{Call: c_call}
}

// IsInterruptible provides a mock function with given fields:
func (_m *ExecutableWorkflow) IsInterruptible() bool {
	ret := _m.Called()

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

type ExecutableWorkflow_StartNode struct {
	*mock.Call
}

func (_m ExecutableWorkflow_StartNode) Return(_a0 v1alpha1.ExecutableNode) *ExecutableWorkflow_StartNode {
	return &ExecutableWorkflow_StartNode{Call: _m.Call.Return(_a0)}
}

func (_m *ExecutableWorkflow) OnStartNode() *ExecutableWorkflow_StartNode {
	c_call := _m.On("StartNode")
	return &ExecutableWorkflow_StartNode{Call: c_call}
}

func (_m *ExecutableWorkflow) OnStartNodeMatch(matchers ...interface{}) *ExecutableWorkflow_StartNode {
	c_call := _m.On("StartNode", matchers...)
	return &ExecutableWorkflow_StartNode{Call: c_call}
}

// StartNode provides a mock function with given fields:
func (_m *ExecutableWorkflow) StartNode() v1alpha1.ExecutableNode {
	ret := _m.Called()

	var r0 v1alpha1.ExecutableNode
	if rf, ok := ret.Get(0).(func() v1alpha1.ExecutableNode); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(v1alpha1.ExecutableNode)
		}
	}

	return r0
}

type ExecutableWorkflow_ToNode struct {
	*mock.Call
}

func (_m ExecutableWorkflow_ToNode) Return(_a0 []string, _a1 error) *ExecutableWorkflow_ToNode {
	return &ExecutableWorkflow_ToNode{Call: _m.Call.Return(_a0, _a1)}
}

func (_m *ExecutableWorkflow) OnToNode(name string) *ExecutableWorkflow_ToNode {
	c_call := _m.On("ToNode", name)
	return &ExecutableWorkflow_ToNode{Call: c_call}
}

func (_m *ExecutableWorkflow) OnToNodeMatch(matchers ...interface{}) *ExecutableWorkflow_ToNode {
	c_call := _m.On("ToNode", matchers...)
	return &ExecutableWorkflow_ToNode{Call: c_call}
}

// ToNode provides a mock function with given fields: name
func (_m *ExecutableWorkflow) ToNode(name string) ([]string, error) {
	ret := _m.Called(name)

	var r0 []string
	if rf, ok := ret.Get(0).(func(string) []string); ok {
		r0 = rf(name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}
