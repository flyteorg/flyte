// Code generated by mockery v1.0.1. DO NOT EDIT.

package mocks

import (
	core "github.com/flyteorg/flyte/flyteidl/gen/pb-go/flyteidl/core"
	mock "github.com/stretchr/testify/mock"

	v1alpha1 "github.com/flyteorg/flyte/flytepropeller/pkg/apis/flyteworkflow/v1alpha1"
)

// ExecutableArrayNode is an autogenerated mock type for the ExecutableArrayNode type
type ExecutableArrayNode struct {
	mock.Mock
}

type ExecutableArrayNode_GetBoundInputs struct {
	*mock.Call
}

func (_m ExecutableArrayNode_GetBoundInputs) Return(_a0 []string) *ExecutableArrayNode_GetBoundInputs {
	return &ExecutableArrayNode_GetBoundInputs{Call: _m.Call.Return(_a0)}
}

func (_m *ExecutableArrayNode) OnGetBoundInputs() *ExecutableArrayNode_GetBoundInputs {
	c_call := _m.On("GetBoundInputs")
	return &ExecutableArrayNode_GetBoundInputs{Call: c_call}
}

func (_m *ExecutableArrayNode) OnGetBoundInputsMatch(matchers ...interface{}) *ExecutableArrayNode_GetBoundInputs {
	c_call := _m.On("GetBoundInputs", matchers...)
	return &ExecutableArrayNode_GetBoundInputs{Call: c_call}
}

// GetBoundInputs provides a mock function with given fields:
func (_m *ExecutableArrayNode) GetBoundInputs() []string {
	ret := _m.Called()

	var r0 []string
	if rf, ok := ret.Get(0).(func() []string); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	return r0
}

type ExecutableArrayNode_GetDataMode struct {
	*mock.Call
}

func (_m ExecutableArrayNode_GetDataMode) Return(_a0 core.ArrayNode_DataMode) *ExecutableArrayNode_GetDataMode {
	return &ExecutableArrayNode_GetDataMode{Call: _m.Call.Return(_a0)}
}

func (_m *ExecutableArrayNode) OnGetDataMode() *ExecutableArrayNode_GetDataMode {
	c_call := _m.On("GetDataMode")
	return &ExecutableArrayNode_GetDataMode{Call: c_call}
}

func (_m *ExecutableArrayNode) OnGetDataModeMatch(matchers ...interface{}) *ExecutableArrayNode_GetDataMode {
	c_call := _m.On("GetDataMode", matchers...)
	return &ExecutableArrayNode_GetDataMode{Call: c_call}
}

// GetDataMode provides a mock function with given fields:
func (_m *ExecutableArrayNode) GetDataMode() core.ArrayNode_DataMode {
	ret := _m.Called()

	var r0 core.ArrayNode_DataMode
	if rf, ok := ret.Get(0).(func() core.ArrayNode_DataMode); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(core.ArrayNode_DataMode)
	}

	return r0
}

type ExecutableArrayNode_GetExecutionMode struct {
	*mock.Call
}

func (_m ExecutableArrayNode_GetExecutionMode) Return(_a0 core.ArrayNode_ExecutionMode) *ExecutableArrayNode_GetExecutionMode {
	return &ExecutableArrayNode_GetExecutionMode{Call: _m.Call.Return(_a0)}
}

func (_m *ExecutableArrayNode) OnGetExecutionMode() *ExecutableArrayNode_GetExecutionMode {
	c_call := _m.On("GetExecutionMode")
	return &ExecutableArrayNode_GetExecutionMode{Call: c_call}
}

func (_m *ExecutableArrayNode) OnGetExecutionModeMatch(matchers ...interface{}) *ExecutableArrayNode_GetExecutionMode {
	c_call := _m.On("GetExecutionMode", matchers...)
	return &ExecutableArrayNode_GetExecutionMode{Call: c_call}
}

// GetExecutionMode provides a mock function with given fields:
func (_m *ExecutableArrayNode) GetExecutionMode() core.ArrayNode_ExecutionMode {
	ret := _m.Called()

	var r0 core.ArrayNode_ExecutionMode
	if rf, ok := ret.Get(0).(func() core.ArrayNode_ExecutionMode); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(core.ArrayNode_ExecutionMode)
	}

	return r0
}

type ExecutableArrayNode_GetMinSuccessRatio struct {
	*mock.Call
}

func (_m ExecutableArrayNode_GetMinSuccessRatio) Return(_a0 *float32) *ExecutableArrayNode_GetMinSuccessRatio {
	return &ExecutableArrayNode_GetMinSuccessRatio{Call: _m.Call.Return(_a0)}
}

func (_m *ExecutableArrayNode) OnGetMinSuccessRatio() *ExecutableArrayNode_GetMinSuccessRatio {
	c_call := _m.On("GetMinSuccessRatio")
	return &ExecutableArrayNode_GetMinSuccessRatio{Call: c_call}
}

func (_m *ExecutableArrayNode) OnGetMinSuccessRatioMatch(matchers ...interface{}) *ExecutableArrayNode_GetMinSuccessRatio {
	c_call := _m.On("GetMinSuccessRatio", matchers...)
	return &ExecutableArrayNode_GetMinSuccessRatio{Call: c_call}
}

// GetMinSuccessRatio provides a mock function with given fields:
func (_m *ExecutableArrayNode) GetMinSuccessRatio() *float32 {
	ret := _m.Called()

	var r0 *float32
	if rf, ok := ret.Get(0).(func() *float32); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*float32)
		}
	}

	return r0
}

type ExecutableArrayNode_GetMinSuccesses struct {
	*mock.Call
}

func (_m ExecutableArrayNode_GetMinSuccesses) Return(_a0 *uint32) *ExecutableArrayNode_GetMinSuccesses {
	return &ExecutableArrayNode_GetMinSuccesses{Call: _m.Call.Return(_a0)}
}

func (_m *ExecutableArrayNode) OnGetMinSuccesses() *ExecutableArrayNode_GetMinSuccesses {
	c_call := _m.On("GetMinSuccesses")
	return &ExecutableArrayNode_GetMinSuccesses{Call: c_call}
}

func (_m *ExecutableArrayNode) OnGetMinSuccessesMatch(matchers ...interface{}) *ExecutableArrayNode_GetMinSuccesses {
	c_call := _m.On("GetMinSuccesses", matchers...)
	return &ExecutableArrayNode_GetMinSuccesses{Call: c_call}
}

// GetMinSuccesses provides a mock function with given fields:
func (_m *ExecutableArrayNode) GetMinSuccesses() *uint32 {
	ret := _m.Called()

	var r0 *uint32
	if rf, ok := ret.Get(0).(func() *uint32); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*uint32)
		}
	}

	return r0
}

type ExecutableArrayNode_GetParallelism struct {
	*mock.Call
}

func (_m ExecutableArrayNode_GetParallelism) Return(_a0 *uint32) *ExecutableArrayNode_GetParallelism {
	return &ExecutableArrayNode_GetParallelism{Call: _m.Call.Return(_a0)}
}

func (_m *ExecutableArrayNode) OnGetParallelism() *ExecutableArrayNode_GetParallelism {
	c_call := _m.On("GetParallelism")
	return &ExecutableArrayNode_GetParallelism{Call: c_call}
}

func (_m *ExecutableArrayNode) OnGetParallelismMatch(matchers ...interface{}) *ExecutableArrayNode_GetParallelism {
	c_call := _m.On("GetParallelism", matchers...)
	return &ExecutableArrayNode_GetParallelism{Call: c_call}
}

// GetParallelism provides a mock function with given fields:
func (_m *ExecutableArrayNode) GetParallelism() *uint32 {
	ret := _m.Called()

	var r0 *uint32
	if rf, ok := ret.Get(0).(func() *uint32); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*uint32)
		}
	}

	return r0
}

type ExecutableArrayNode_GetSubNodeSpec struct {
	*mock.Call
}

func (_m ExecutableArrayNode_GetSubNodeSpec) Return(_a0 *v1alpha1.NodeSpec) *ExecutableArrayNode_GetSubNodeSpec {
	return &ExecutableArrayNode_GetSubNodeSpec{Call: _m.Call.Return(_a0)}
}

func (_m *ExecutableArrayNode) OnGetSubNodeSpec() *ExecutableArrayNode_GetSubNodeSpec {
	c_call := _m.On("GetSubNodeSpec")
	return &ExecutableArrayNode_GetSubNodeSpec{Call: c_call}
}

func (_m *ExecutableArrayNode) OnGetSubNodeSpecMatch(matchers ...interface{}) *ExecutableArrayNode_GetSubNodeSpec {
	c_call := _m.On("GetSubNodeSpec", matchers...)
	return &ExecutableArrayNode_GetSubNodeSpec{Call: c_call}
}

// GetSubNodeSpec provides a mock function with given fields:
func (_m *ExecutableArrayNode) GetSubNodeSpec() *v1alpha1.NodeSpec {
	ret := _m.Called()

	var r0 *v1alpha1.NodeSpec
	if rf, ok := ret.Get(0).(func() *v1alpha1.NodeSpec); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1alpha1.NodeSpec)
		}
	}

	return r0
}
