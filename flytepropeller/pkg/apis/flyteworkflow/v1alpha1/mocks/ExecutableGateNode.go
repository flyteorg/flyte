// Code generated by mockery v2.40.3. DO NOT EDIT.

package mocks

import (
	core "github.com/flyteorg/flyte/flyteidl/gen/pb-go/flyteidl/core"
	mock "github.com/stretchr/testify/mock"

	v1alpha1 "github.com/flyteorg/flyte/flytepropeller/pkg/apis/flyteworkflow/v1alpha1"
)

// ExecutableGateNode is an autogenerated mock type for the ExecutableGateNode type
type ExecutableGateNode struct {
	mock.Mock
}

type ExecutableGateNode_Expecter struct {
	mock *mock.Mock
}

func (_m *ExecutableGateNode) EXPECT() *ExecutableGateNode_Expecter {
	return &ExecutableGateNode_Expecter{mock: &_m.Mock}
}

// GetApprove provides a mock function with given fields:
func (_m *ExecutableGateNode) GetApprove() *core.ApproveCondition {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetApprove")
	}

	var r0 *core.ApproveCondition
	if rf, ok := ret.Get(0).(func() *core.ApproveCondition); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.ApproveCondition)
		}
	}

	return r0
}

// ExecutableGateNode_GetApprove_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetApprove'
type ExecutableGateNode_GetApprove_Call struct {
	*mock.Call
}

// GetApprove is a helper method to define mock.On call
func (_e *ExecutableGateNode_Expecter) GetApprove() *ExecutableGateNode_GetApprove_Call {
	return &ExecutableGateNode_GetApprove_Call{Call: _e.mock.On("GetApprove")}
}

func (_c *ExecutableGateNode_GetApprove_Call) Run(run func()) *ExecutableGateNode_GetApprove_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ExecutableGateNode_GetApprove_Call) Return(_a0 *core.ApproveCondition) *ExecutableGateNode_GetApprove_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ExecutableGateNode_GetApprove_Call) RunAndReturn(run func() *core.ApproveCondition) *ExecutableGateNode_GetApprove_Call {
	_c.Call.Return(run)
	return _c
}

// GetKind provides a mock function with given fields:
func (_m *ExecutableGateNode) GetKind() v1alpha1.ConditionKind {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetKind")
	}

	var r0 v1alpha1.ConditionKind
	if rf, ok := ret.Get(0).(func() v1alpha1.ConditionKind); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(v1alpha1.ConditionKind)
	}

	return r0
}

// ExecutableGateNode_GetKind_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetKind'
type ExecutableGateNode_GetKind_Call struct {
	*mock.Call
}

// GetKind is a helper method to define mock.On call
func (_e *ExecutableGateNode_Expecter) GetKind() *ExecutableGateNode_GetKind_Call {
	return &ExecutableGateNode_GetKind_Call{Call: _e.mock.On("GetKind")}
}

func (_c *ExecutableGateNode_GetKind_Call) Run(run func()) *ExecutableGateNode_GetKind_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ExecutableGateNode_GetKind_Call) Return(_a0 v1alpha1.ConditionKind) *ExecutableGateNode_GetKind_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ExecutableGateNode_GetKind_Call) RunAndReturn(run func() v1alpha1.ConditionKind) *ExecutableGateNode_GetKind_Call {
	_c.Call.Return(run)
	return _c
}

// GetSignal provides a mock function with given fields:
func (_m *ExecutableGateNode) GetSignal() *core.SignalCondition {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetSignal")
	}

	var r0 *core.SignalCondition
	if rf, ok := ret.Get(0).(func() *core.SignalCondition); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.SignalCondition)
		}
	}

	return r0
}

// ExecutableGateNode_GetSignal_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSignal'
type ExecutableGateNode_GetSignal_Call struct {
	*mock.Call
}

// GetSignal is a helper method to define mock.On call
func (_e *ExecutableGateNode_Expecter) GetSignal() *ExecutableGateNode_GetSignal_Call {
	return &ExecutableGateNode_GetSignal_Call{Call: _e.mock.On("GetSignal")}
}

func (_c *ExecutableGateNode_GetSignal_Call) Run(run func()) *ExecutableGateNode_GetSignal_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ExecutableGateNode_GetSignal_Call) Return(_a0 *core.SignalCondition) *ExecutableGateNode_GetSignal_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ExecutableGateNode_GetSignal_Call) RunAndReturn(run func() *core.SignalCondition) *ExecutableGateNode_GetSignal_Call {
	_c.Call.Return(run)
	return _c
}

// GetSleep provides a mock function with given fields:
func (_m *ExecutableGateNode) GetSleep() *core.SleepCondition {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for GetSleep")
	}

	var r0 *core.SleepCondition
	if rf, ok := ret.Get(0).(func() *core.SleepCondition); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*core.SleepCondition)
		}
	}

	return r0
}

// ExecutableGateNode_GetSleep_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSleep'
type ExecutableGateNode_GetSleep_Call struct {
	*mock.Call
}

// GetSleep is a helper method to define mock.On call
func (_e *ExecutableGateNode_Expecter) GetSleep() *ExecutableGateNode_GetSleep_Call {
	return &ExecutableGateNode_GetSleep_Call{Call: _e.mock.On("GetSleep")}
}

func (_c *ExecutableGateNode_GetSleep_Call) Run(run func()) *ExecutableGateNode_GetSleep_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *ExecutableGateNode_GetSleep_Call) Return(_a0 *core.SleepCondition) *ExecutableGateNode_GetSleep_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *ExecutableGateNode_GetSleep_Call) RunAndReturn(run func() *core.SleepCondition) *ExecutableGateNode_GetSleep_Call {
	_c.Call.Return(run)
	return _c
}

// NewExecutableGateNode creates a new instance of ExecutableGateNode. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewExecutableGateNode(t interface {
	mock.TestingT
	Cleanup(func())
}) *ExecutableGateNode {
	mock := &ExecutableGateNode{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
