// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: flyteidl/core/identifier.proto

#ifndef PROTOBUF_INCLUDED_flyteidl_2fcore_2fidentifier_2eproto
#define PROTOBUF_INCLUDED_flyteidl_2fcore_2fidentifier_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_flyteidl_2fcore_2fidentifier_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_flyteidl_2fcore_2fidentifier_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[14]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_flyteidl_2fcore_2fidentifier_2eproto();
namespace flyteidl {
namespace core {
class ArtifactBindingData;
class ArtifactBindingDataDefaultTypeInternal;
extern ArtifactBindingDataDefaultTypeInternal _ArtifactBindingData_default_instance_;
class ArtifactID;
class ArtifactIDDefaultTypeInternal;
extern ArtifactIDDefaultTypeInternal _ArtifactID_default_instance_;
class ArtifactKey;
class ArtifactKeyDefaultTypeInternal;
extern ArtifactKeyDefaultTypeInternal _ArtifactKey_default_instance_;
class ArtifactQuery;
class ArtifactQueryDefaultTypeInternal;
extern ArtifactQueryDefaultTypeInternal _ArtifactQuery_default_instance_;
class ArtifactTag;
class ArtifactTagDefaultTypeInternal;
extern ArtifactTagDefaultTypeInternal _ArtifactTag_default_instance_;
class Identifier;
class IdentifierDefaultTypeInternal;
extern IdentifierDefaultTypeInternal _Identifier_default_instance_;
class NodeExecutionIdentifier;
class NodeExecutionIdentifierDefaultTypeInternal;
extern NodeExecutionIdentifierDefaultTypeInternal _NodeExecutionIdentifier_default_instance_;
class PartitionValue;
class PartitionValueDefaultTypeInternal;
extern PartitionValueDefaultTypeInternal _PartitionValue_default_instance_;
class Partitions;
class PartitionsDefaultTypeInternal;
extern PartitionsDefaultTypeInternal _Partitions_default_instance_;
class Partitions_ValueEntry_DoNotUse;
class Partitions_ValueEntry_DoNotUseDefaultTypeInternal;
extern Partitions_ValueEntry_DoNotUseDefaultTypeInternal _Partitions_ValueEntry_DoNotUse_default_instance_;
class SignalIdentifier;
class SignalIdentifierDefaultTypeInternal;
extern SignalIdentifierDefaultTypeInternal _SignalIdentifier_default_instance_;
class TaskExecutionIdentifier;
class TaskExecutionIdentifierDefaultTypeInternal;
extern TaskExecutionIdentifierDefaultTypeInternal _TaskExecutionIdentifier_default_instance_;
class Trigger;
class TriggerDefaultTypeInternal;
extern TriggerDefaultTypeInternal _Trigger_default_instance_;
class WorkflowExecutionIdentifier;
class WorkflowExecutionIdentifierDefaultTypeInternal;
extern WorkflowExecutionIdentifierDefaultTypeInternal _WorkflowExecutionIdentifier_default_instance_;
}  // namespace core
}  // namespace flyteidl
namespace google {
namespace protobuf {
template<> ::flyteidl::core::ArtifactBindingData* Arena::CreateMaybeMessage<::flyteidl::core::ArtifactBindingData>(Arena*);
template<> ::flyteidl::core::ArtifactID* Arena::CreateMaybeMessage<::flyteidl::core::ArtifactID>(Arena*);
template<> ::flyteidl::core::ArtifactKey* Arena::CreateMaybeMessage<::flyteidl::core::ArtifactKey>(Arena*);
template<> ::flyteidl::core::ArtifactQuery* Arena::CreateMaybeMessage<::flyteidl::core::ArtifactQuery>(Arena*);
template<> ::flyteidl::core::ArtifactTag* Arena::CreateMaybeMessage<::flyteidl::core::ArtifactTag>(Arena*);
template<> ::flyteidl::core::Identifier* Arena::CreateMaybeMessage<::flyteidl::core::Identifier>(Arena*);
template<> ::flyteidl::core::NodeExecutionIdentifier* Arena::CreateMaybeMessage<::flyteidl::core::NodeExecutionIdentifier>(Arena*);
template<> ::flyteidl::core::PartitionValue* Arena::CreateMaybeMessage<::flyteidl::core::PartitionValue>(Arena*);
template<> ::flyteidl::core::Partitions* Arena::CreateMaybeMessage<::flyteidl::core::Partitions>(Arena*);
template<> ::flyteidl::core::Partitions_ValueEntry_DoNotUse* Arena::CreateMaybeMessage<::flyteidl::core::Partitions_ValueEntry_DoNotUse>(Arena*);
template<> ::flyteidl::core::SignalIdentifier* Arena::CreateMaybeMessage<::flyteidl::core::SignalIdentifier>(Arena*);
template<> ::flyteidl::core::TaskExecutionIdentifier* Arena::CreateMaybeMessage<::flyteidl::core::TaskExecutionIdentifier>(Arena*);
template<> ::flyteidl::core::Trigger* Arena::CreateMaybeMessage<::flyteidl::core::Trigger>(Arena*);
template<> ::flyteidl::core::WorkflowExecutionIdentifier* Arena::CreateMaybeMessage<::flyteidl::core::WorkflowExecutionIdentifier>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace flyteidl {
namespace core {

enum ResourceType {
  UNSPECIFIED = 0,
  TASK = 1,
  WORKFLOW = 2,
  LAUNCH_PLAN = 3,
  DATASET = 4,
  ResourceType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  ResourceType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool ResourceType_IsValid(int value);
const ResourceType ResourceType_MIN = UNSPECIFIED;
const ResourceType ResourceType_MAX = DATASET;
const int ResourceType_ARRAYSIZE = ResourceType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResourceType_descriptor();
inline const ::std::string& ResourceType_Name(ResourceType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResourceType_descriptor(), value);
}
inline bool ResourceType_Parse(
    const ::std::string& name, ResourceType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResourceType>(
    ResourceType_descriptor(), name, value);
}
// ===================================================================

class Identifier final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.Identifier) */ {
 public:
  Identifier();
  virtual ~Identifier();

  Identifier(const Identifier& from);

  inline Identifier& operator=(const Identifier& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Identifier(Identifier&& from) noexcept
    : Identifier() {
    *this = ::std::move(from);
  }

  inline Identifier& operator=(Identifier&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Identifier& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Identifier* internal_default_instance() {
    return reinterpret_cast<const Identifier*>(
               &_Identifier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Identifier* other);
  friend void swap(Identifier& a, Identifier& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Identifier* New() const final {
    return CreateMaybeMessage<Identifier>(nullptr);
  }

  Identifier* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Identifier>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Identifier& from);
  void MergeFrom(const Identifier& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Identifier* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string project = 2;
  void clear_project();
  static const int kProjectFieldNumber = 2;
  const ::std::string& project() const;
  void set_project(const ::std::string& value);
  #if LANG_CXX11
  void set_project(::std::string&& value);
  #endif
  void set_project(const char* value);
  void set_project(const char* value, size_t size);
  ::std::string* mutable_project();
  ::std::string* release_project();
  void set_allocated_project(::std::string* project);

  // string domain = 3;
  void clear_domain();
  static const int kDomainFieldNumber = 3;
  const ::std::string& domain() const;
  void set_domain(const ::std::string& value);
  #if LANG_CXX11
  void set_domain(::std::string&& value);
  #endif
  void set_domain(const char* value);
  void set_domain(const char* value, size_t size);
  ::std::string* mutable_domain();
  ::std::string* release_domain();
  void set_allocated_domain(::std::string* domain);

  // string name = 4;
  void clear_name();
  static const int kNameFieldNumber = 4;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string version = 5;
  void clear_version();
  static const int kVersionFieldNumber = 5;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // .flyteidl.core.ResourceType resource_type = 1;
  void clear_resource_type();
  static const int kResourceTypeFieldNumber = 1;
  ::flyteidl::core::ResourceType resource_type() const;
  void set_resource_type(::flyteidl::core::ResourceType value);

  // @@protoc_insertion_point(class_scope:flyteidl.core.Identifier)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr project_;
  ::google::protobuf::internal::ArenaStringPtr domain_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  int resource_type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2fidentifier_2eproto;
};
// -------------------------------------------------------------------

class WorkflowExecutionIdentifier final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.WorkflowExecutionIdentifier) */ {
 public:
  WorkflowExecutionIdentifier();
  virtual ~WorkflowExecutionIdentifier();

  WorkflowExecutionIdentifier(const WorkflowExecutionIdentifier& from);

  inline WorkflowExecutionIdentifier& operator=(const WorkflowExecutionIdentifier& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WorkflowExecutionIdentifier(WorkflowExecutionIdentifier&& from) noexcept
    : WorkflowExecutionIdentifier() {
    *this = ::std::move(from);
  }

  inline WorkflowExecutionIdentifier& operator=(WorkflowExecutionIdentifier&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const WorkflowExecutionIdentifier& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WorkflowExecutionIdentifier* internal_default_instance() {
    return reinterpret_cast<const WorkflowExecutionIdentifier*>(
               &_WorkflowExecutionIdentifier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(WorkflowExecutionIdentifier* other);
  friend void swap(WorkflowExecutionIdentifier& a, WorkflowExecutionIdentifier& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WorkflowExecutionIdentifier* New() const final {
    return CreateMaybeMessage<WorkflowExecutionIdentifier>(nullptr);
  }

  WorkflowExecutionIdentifier* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WorkflowExecutionIdentifier>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WorkflowExecutionIdentifier& from);
  void MergeFrom(const WorkflowExecutionIdentifier& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkflowExecutionIdentifier* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string project = 1;
  void clear_project();
  static const int kProjectFieldNumber = 1;
  const ::std::string& project() const;
  void set_project(const ::std::string& value);
  #if LANG_CXX11
  void set_project(::std::string&& value);
  #endif
  void set_project(const char* value);
  void set_project(const char* value, size_t size);
  ::std::string* mutable_project();
  ::std::string* release_project();
  void set_allocated_project(::std::string* project);

  // string domain = 2;
  void clear_domain();
  static const int kDomainFieldNumber = 2;
  const ::std::string& domain() const;
  void set_domain(const ::std::string& value);
  #if LANG_CXX11
  void set_domain(::std::string&& value);
  #endif
  void set_domain(const char* value);
  void set_domain(const char* value, size_t size);
  ::std::string* mutable_domain();
  ::std::string* release_domain();
  void set_allocated_domain(::std::string* domain);

  // string name = 4;
  void clear_name();
  static const int kNameFieldNumber = 4;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:flyteidl.core.WorkflowExecutionIdentifier)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr project_;
  ::google::protobuf::internal::ArenaStringPtr domain_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2fidentifier_2eproto;
};
// -------------------------------------------------------------------

class NodeExecutionIdentifier final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.NodeExecutionIdentifier) */ {
 public:
  NodeExecutionIdentifier();
  virtual ~NodeExecutionIdentifier();

  NodeExecutionIdentifier(const NodeExecutionIdentifier& from);

  inline NodeExecutionIdentifier& operator=(const NodeExecutionIdentifier& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NodeExecutionIdentifier(NodeExecutionIdentifier&& from) noexcept
    : NodeExecutionIdentifier() {
    *this = ::std::move(from);
  }

  inline NodeExecutionIdentifier& operator=(NodeExecutionIdentifier&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const NodeExecutionIdentifier& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NodeExecutionIdentifier* internal_default_instance() {
    return reinterpret_cast<const NodeExecutionIdentifier*>(
               &_NodeExecutionIdentifier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(NodeExecutionIdentifier* other);
  friend void swap(NodeExecutionIdentifier& a, NodeExecutionIdentifier& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NodeExecutionIdentifier* New() const final {
    return CreateMaybeMessage<NodeExecutionIdentifier>(nullptr);
  }

  NodeExecutionIdentifier* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NodeExecutionIdentifier>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NodeExecutionIdentifier& from);
  void MergeFrom(const NodeExecutionIdentifier& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeExecutionIdentifier* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string node_id = 1;
  void clear_node_id();
  static const int kNodeIdFieldNumber = 1;
  const ::std::string& node_id() const;
  void set_node_id(const ::std::string& value);
  #if LANG_CXX11
  void set_node_id(::std::string&& value);
  #endif
  void set_node_id(const char* value);
  void set_node_id(const char* value, size_t size);
  ::std::string* mutable_node_id();
  ::std::string* release_node_id();
  void set_allocated_node_id(::std::string* node_id);

  // .flyteidl.core.WorkflowExecutionIdentifier execution_id = 2;
  bool has_execution_id() const;
  void clear_execution_id();
  static const int kExecutionIdFieldNumber = 2;
  const ::flyteidl::core::WorkflowExecutionIdentifier& execution_id() const;
  ::flyteidl::core::WorkflowExecutionIdentifier* release_execution_id();
  ::flyteidl::core::WorkflowExecutionIdentifier* mutable_execution_id();
  void set_allocated_execution_id(::flyteidl::core::WorkflowExecutionIdentifier* execution_id);

  // @@protoc_insertion_point(class_scope:flyteidl.core.NodeExecutionIdentifier)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr node_id_;
  ::flyteidl::core::WorkflowExecutionIdentifier* execution_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2fidentifier_2eproto;
};
// -------------------------------------------------------------------

class TaskExecutionIdentifier final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.TaskExecutionIdentifier) */ {
 public:
  TaskExecutionIdentifier();
  virtual ~TaskExecutionIdentifier();

  TaskExecutionIdentifier(const TaskExecutionIdentifier& from);

  inline TaskExecutionIdentifier& operator=(const TaskExecutionIdentifier& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TaskExecutionIdentifier(TaskExecutionIdentifier&& from) noexcept
    : TaskExecutionIdentifier() {
    *this = ::std::move(from);
  }

  inline TaskExecutionIdentifier& operator=(TaskExecutionIdentifier&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TaskExecutionIdentifier& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TaskExecutionIdentifier* internal_default_instance() {
    return reinterpret_cast<const TaskExecutionIdentifier*>(
               &_TaskExecutionIdentifier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(TaskExecutionIdentifier* other);
  friend void swap(TaskExecutionIdentifier& a, TaskExecutionIdentifier& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TaskExecutionIdentifier* New() const final {
    return CreateMaybeMessage<TaskExecutionIdentifier>(nullptr);
  }

  TaskExecutionIdentifier* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TaskExecutionIdentifier>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TaskExecutionIdentifier& from);
  void MergeFrom(const TaskExecutionIdentifier& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskExecutionIdentifier* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .flyteidl.core.Identifier task_id = 1;
  bool has_task_id() const;
  void clear_task_id();
  static const int kTaskIdFieldNumber = 1;
  const ::flyteidl::core::Identifier& task_id() const;
  ::flyteidl::core::Identifier* release_task_id();
  ::flyteidl::core::Identifier* mutable_task_id();
  void set_allocated_task_id(::flyteidl::core::Identifier* task_id);

  // .flyteidl.core.NodeExecutionIdentifier node_execution_id = 2;
  bool has_node_execution_id() const;
  void clear_node_execution_id();
  static const int kNodeExecutionIdFieldNumber = 2;
  const ::flyteidl::core::NodeExecutionIdentifier& node_execution_id() const;
  ::flyteidl::core::NodeExecutionIdentifier* release_node_execution_id();
  ::flyteidl::core::NodeExecutionIdentifier* mutable_node_execution_id();
  void set_allocated_node_execution_id(::flyteidl::core::NodeExecutionIdentifier* node_execution_id);

  // uint32 retry_attempt = 3;
  void clear_retry_attempt();
  static const int kRetryAttemptFieldNumber = 3;
  ::google::protobuf::uint32 retry_attempt() const;
  void set_retry_attempt(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:flyteidl.core.TaskExecutionIdentifier)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::flyteidl::core::Identifier* task_id_;
  ::flyteidl::core::NodeExecutionIdentifier* node_execution_id_;
  ::google::protobuf::uint32 retry_attempt_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2fidentifier_2eproto;
};
// -------------------------------------------------------------------

class SignalIdentifier final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.SignalIdentifier) */ {
 public:
  SignalIdentifier();
  virtual ~SignalIdentifier();

  SignalIdentifier(const SignalIdentifier& from);

  inline SignalIdentifier& operator=(const SignalIdentifier& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SignalIdentifier(SignalIdentifier&& from) noexcept
    : SignalIdentifier() {
    *this = ::std::move(from);
  }

  inline SignalIdentifier& operator=(SignalIdentifier&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SignalIdentifier& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SignalIdentifier* internal_default_instance() {
    return reinterpret_cast<const SignalIdentifier*>(
               &_SignalIdentifier_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(SignalIdentifier* other);
  friend void swap(SignalIdentifier& a, SignalIdentifier& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SignalIdentifier* New() const final {
    return CreateMaybeMessage<SignalIdentifier>(nullptr);
  }

  SignalIdentifier* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SignalIdentifier>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SignalIdentifier& from);
  void MergeFrom(const SignalIdentifier& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignalIdentifier* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string signal_id = 1;
  void clear_signal_id();
  static const int kSignalIdFieldNumber = 1;
  const ::std::string& signal_id() const;
  void set_signal_id(const ::std::string& value);
  #if LANG_CXX11
  void set_signal_id(::std::string&& value);
  #endif
  void set_signal_id(const char* value);
  void set_signal_id(const char* value, size_t size);
  ::std::string* mutable_signal_id();
  ::std::string* release_signal_id();
  void set_allocated_signal_id(::std::string* signal_id);

  // .flyteidl.core.WorkflowExecutionIdentifier execution_id = 2;
  bool has_execution_id() const;
  void clear_execution_id();
  static const int kExecutionIdFieldNumber = 2;
  const ::flyteidl::core::WorkflowExecutionIdentifier& execution_id() const;
  ::flyteidl::core::WorkflowExecutionIdentifier* release_execution_id();
  ::flyteidl::core::WorkflowExecutionIdentifier* mutable_execution_id();
  void set_allocated_execution_id(::flyteidl::core::WorkflowExecutionIdentifier* execution_id);

  // @@protoc_insertion_point(class_scope:flyteidl.core.SignalIdentifier)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr signal_id_;
  ::flyteidl::core::WorkflowExecutionIdentifier* execution_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2fidentifier_2eproto;
};
// -------------------------------------------------------------------

class ArtifactKey final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.ArtifactKey) */ {
 public:
  ArtifactKey();
  virtual ~ArtifactKey();

  ArtifactKey(const ArtifactKey& from);

  inline ArtifactKey& operator=(const ArtifactKey& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ArtifactKey(ArtifactKey&& from) noexcept
    : ArtifactKey() {
    *this = ::std::move(from);
  }

  inline ArtifactKey& operator=(ArtifactKey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ArtifactKey& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ArtifactKey* internal_default_instance() {
    return reinterpret_cast<const ArtifactKey*>(
               &_ArtifactKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(ArtifactKey* other);
  friend void swap(ArtifactKey& a, ArtifactKey& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ArtifactKey* New() const final {
    return CreateMaybeMessage<ArtifactKey>(nullptr);
  }

  ArtifactKey* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ArtifactKey>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ArtifactKey& from);
  void MergeFrom(const ArtifactKey& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArtifactKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string project = 1;
  void clear_project();
  static const int kProjectFieldNumber = 1;
  const ::std::string& project() const;
  void set_project(const ::std::string& value);
  #if LANG_CXX11
  void set_project(::std::string&& value);
  #endif
  void set_project(const char* value);
  void set_project(const char* value, size_t size);
  ::std::string* mutable_project();
  ::std::string* release_project();
  void set_allocated_project(::std::string* project);

  // string domain = 2;
  void clear_domain();
  static const int kDomainFieldNumber = 2;
  const ::std::string& domain() const;
  void set_domain(const ::std::string& value);
  #if LANG_CXX11
  void set_domain(::std::string&& value);
  #endif
  void set_domain(const char* value);
  void set_domain(const char* value, size_t size);
  ::std::string* mutable_domain();
  ::std::string* release_domain();
  void set_allocated_domain(::std::string* domain);

  // string name = 3;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:flyteidl.core.ArtifactKey)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr project_;
  ::google::protobuf::internal::ArenaStringPtr domain_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2fidentifier_2eproto;
};
// -------------------------------------------------------------------

class ArtifactBindingData final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.ArtifactBindingData) */ {
 public:
  ArtifactBindingData();
  virtual ~ArtifactBindingData();

  ArtifactBindingData(const ArtifactBindingData& from);

  inline ArtifactBindingData& operator=(const ArtifactBindingData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ArtifactBindingData(ArtifactBindingData&& from) noexcept
    : ArtifactBindingData() {
    *this = ::std::move(from);
  }

  inline ArtifactBindingData& operator=(ArtifactBindingData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ArtifactBindingData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ArtifactBindingData* internal_default_instance() {
    return reinterpret_cast<const ArtifactBindingData*>(
               &_ArtifactBindingData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(ArtifactBindingData* other);
  friend void swap(ArtifactBindingData& a, ArtifactBindingData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ArtifactBindingData* New() const final {
    return CreateMaybeMessage<ArtifactBindingData>(nullptr);
  }

  ArtifactBindingData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ArtifactBindingData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ArtifactBindingData& from);
  void MergeFrom(const ArtifactBindingData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArtifactBindingData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string partition_key = 2;
  void clear_partition_key();
  static const int kPartitionKeyFieldNumber = 2;
  const ::std::string& partition_key() const;
  void set_partition_key(const ::std::string& value);
  #if LANG_CXX11
  void set_partition_key(::std::string&& value);
  #endif
  void set_partition_key(const char* value);
  void set_partition_key(const char* value, size_t size);
  ::std::string* mutable_partition_key();
  ::std::string* release_partition_key();
  void set_allocated_partition_key(::std::string* partition_key);

  // string transform = 3;
  void clear_transform();
  static const int kTransformFieldNumber = 3;
  const ::std::string& transform() const;
  void set_transform(const ::std::string& value);
  #if LANG_CXX11
  void set_transform(::std::string&& value);
  #endif
  void set_transform(const char* value);
  void set_transform(const char* value, size_t size);
  ::std::string* mutable_transform();
  ::std::string* release_transform();
  void set_allocated_transform(::std::string* transform);

  // uint32 index = 1;
  void clear_index();
  static const int kIndexFieldNumber = 1;
  ::google::protobuf::uint32 index() const;
  void set_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:flyteidl.core.ArtifactBindingData)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr partition_key_;
  ::google::protobuf::internal::ArenaStringPtr transform_;
  ::google::protobuf::uint32 index_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2fidentifier_2eproto;
};
// -------------------------------------------------------------------

class PartitionValue final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.PartitionValue) */ {
 public:
  PartitionValue();
  virtual ~PartitionValue();

  PartitionValue(const PartitionValue& from);

  inline PartitionValue& operator=(const PartitionValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PartitionValue(PartitionValue&& from) noexcept
    : PartitionValue() {
    *this = ::std::move(from);
  }

  inline PartitionValue& operator=(PartitionValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const PartitionValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PartitionValue* internal_default_instance() {
    return reinterpret_cast<const PartitionValue*>(
               &_PartitionValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(PartitionValue* other);
  friend void swap(PartitionValue& a, PartitionValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PartitionValue* New() const final {
    return CreateMaybeMessage<PartitionValue>(nullptr);
  }

  PartitionValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PartitionValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PartitionValue& from);
  void MergeFrom(const PartitionValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PartitionValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string static_value = 1;
  void clear_static_value();
  static const int kStaticValueFieldNumber = 1;
  const ::std::string& static_value() const;
  void set_static_value(const ::std::string& value);
  #if LANG_CXX11
  void set_static_value(::std::string&& value);
  #endif
  void set_static_value(const char* value);
  void set_static_value(const char* value, size_t size);
  ::std::string* mutable_static_value();
  ::std::string* release_static_value();
  void set_allocated_static_value(::std::string* static_value);

  // .flyteidl.core.ArtifactBindingData binding = 2;
  bool has_binding() const;
  void clear_binding();
  static const int kBindingFieldNumber = 2;
  const ::flyteidl::core::ArtifactBindingData& binding() const;
  ::flyteidl::core::ArtifactBindingData* release_binding();
  ::flyteidl::core::ArtifactBindingData* mutable_binding();
  void set_allocated_binding(::flyteidl::core::ArtifactBindingData* binding);

  // @@protoc_insertion_point(class_scope:flyteidl.core.PartitionValue)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr static_value_;
  ::flyteidl::core::ArtifactBindingData* binding_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2fidentifier_2eproto;
};
// -------------------------------------------------------------------

class Partitions_ValueEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<Partitions_ValueEntry_DoNotUse, 
    ::std::string, ::flyteidl::core::PartitionValue,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
static bool _ParseMap(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  typedef ::google::protobuf::internal::MapEntry<Partitions_ValueEntry_DoNotUse, 
    ::std::string, ::flyteidl::core::PartitionValue,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  Partitions_ValueEntry_DoNotUse();
  Partitions_ValueEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const Partitions_ValueEntry_DoNotUse& other);
  static const Partitions_ValueEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Partitions_ValueEntry_DoNotUse*>(&_Partitions_ValueEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class Partitions final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.Partitions) */ {
 public:
  Partitions();
  virtual ~Partitions();

  Partitions(const Partitions& from);

  inline Partitions& operator=(const Partitions& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Partitions(Partitions&& from) noexcept
    : Partitions() {
    *this = ::std::move(from);
  }

  inline Partitions& operator=(Partitions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Partitions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Partitions* internal_default_instance() {
    return reinterpret_cast<const Partitions*>(
               &_Partitions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(Partitions* other);
  friend void swap(Partitions& a, Partitions& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Partitions* New() const final {
    return CreateMaybeMessage<Partitions>(nullptr);
  }

  Partitions* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Partitions>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Partitions& from);
  void MergeFrom(const Partitions& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Partitions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, .flyteidl.core.PartitionValue> value = 1;
  int value_size() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::google::protobuf::Map< ::std::string, ::flyteidl::core::PartitionValue >&
      value() const;
  ::google::protobuf::Map< ::std::string, ::flyteidl::core::PartitionValue >*
      mutable_value();

  // @@protoc_insertion_point(class_scope:flyteidl.core.Partitions)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      Partitions_ValueEntry_DoNotUse,
      ::std::string, ::flyteidl::core::PartitionValue,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2fidentifier_2eproto;
};
// -------------------------------------------------------------------

class ArtifactID final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.ArtifactID) */ {
 public:
  ArtifactID();
  virtual ~ArtifactID();

  ArtifactID(const ArtifactID& from);

  inline ArtifactID& operator=(const ArtifactID& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ArtifactID(ArtifactID&& from) noexcept
    : ArtifactID() {
    *this = ::std::move(from);
  }

  inline ArtifactID& operator=(ArtifactID&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ArtifactID& default_instance();

  enum DimensionsCase {
    kPartitions = 3,
    DIMENSIONS_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ArtifactID* internal_default_instance() {
    return reinterpret_cast<const ArtifactID*>(
               &_ArtifactID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(ArtifactID* other);
  friend void swap(ArtifactID& a, ArtifactID& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ArtifactID* New() const final {
    return CreateMaybeMessage<ArtifactID>(nullptr);
  }

  ArtifactID* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ArtifactID>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ArtifactID& from);
  void MergeFrom(const ArtifactID& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArtifactID* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string version = 2;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // .flyteidl.core.ArtifactKey artifact_key = 1;
  bool has_artifact_key() const;
  void clear_artifact_key();
  static const int kArtifactKeyFieldNumber = 1;
  const ::flyteidl::core::ArtifactKey& artifact_key() const;
  ::flyteidl::core::ArtifactKey* release_artifact_key();
  ::flyteidl::core::ArtifactKey* mutable_artifact_key();
  void set_allocated_artifact_key(::flyteidl::core::ArtifactKey* artifact_key);

  // .flyteidl.core.Partitions partitions = 3;
  bool has_partitions() const;
  void clear_partitions();
  static const int kPartitionsFieldNumber = 3;
  const ::flyteidl::core::Partitions& partitions() const;
  ::flyteidl::core::Partitions* release_partitions();
  ::flyteidl::core::Partitions* mutable_partitions();
  void set_allocated_partitions(::flyteidl::core::Partitions* partitions);

  void clear_dimensions();
  DimensionsCase dimensions_case() const;
  // @@protoc_insertion_point(class_scope:flyteidl.core.ArtifactID)
 private:
  class HasBitSetters;
  void set_has_partitions();

  inline bool has_dimensions() const;
  inline void clear_has_dimensions();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::flyteidl::core::ArtifactKey* artifact_key_;
  union DimensionsUnion {
    DimensionsUnion() {}
    ::flyteidl::core::Partitions* partitions_;
  } dimensions_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_flyteidl_2fcore_2fidentifier_2eproto;
};
// -------------------------------------------------------------------

class ArtifactTag final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.ArtifactTag) */ {
 public:
  ArtifactTag();
  virtual ~ArtifactTag();

  ArtifactTag(const ArtifactTag& from);

  inline ArtifactTag& operator=(const ArtifactTag& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ArtifactTag(ArtifactTag&& from) noexcept
    : ArtifactTag() {
    *this = ::std::move(from);
  }

  inline ArtifactTag& operator=(ArtifactTag&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ArtifactTag& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ArtifactTag* internal_default_instance() {
    return reinterpret_cast<const ArtifactTag*>(
               &_ArtifactTag_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(ArtifactTag* other);
  friend void swap(ArtifactTag& a, ArtifactTag& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ArtifactTag* New() const final {
    return CreateMaybeMessage<ArtifactTag>(nullptr);
  }

  ArtifactTag* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ArtifactTag>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ArtifactTag& from);
  void MergeFrom(const ArtifactTag& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArtifactTag* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // .flyteidl.core.ArtifactKey artifact_key = 1;
  bool has_artifact_key() const;
  void clear_artifact_key();
  static const int kArtifactKeyFieldNumber = 1;
  const ::flyteidl::core::ArtifactKey& artifact_key() const;
  ::flyteidl::core::ArtifactKey* release_artifact_key();
  ::flyteidl::core::ArtifactKey* mutable_artifact_key();
  void set_allocated_artifact_key(::flyteidl::core::ArtifactKey* artifact_key);

  // @@protoc_insertion_point(class_scope:flyteidl.core.ArtifactTag)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::flyteidl::core::ArtifactKey* artifact_key_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2fidentifier_2eproto;
};
// -------------------------------------------------------------------

class ArtifactQuery final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.ArtifactQuery) */ {
 public:
  ArtifactQuery();
  virtual ~ArtifactQuery();

  ArtifactQuery(const ArtifactQuery& from);

  inline ArtifactQuery& operator=(const ArtifactQuery& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ArtifactQuery(ArtifactQuery&& from) noexcept
    : ArtifactQuery() {
    *this = ::std::move(from);
  }

  inline ArtifactQuery& operator=(ArtifactQuery&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ArtifactQuery& default_instance();

  enum IdentifierCase {
    kArtifactId = 1,
    kArtifactTag = 2,
    kUri = 3,
    kBinding = 4,
    IDENTIFIER_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ArtifactQuery* internal_default_instance() {
    return reinterpret_cast<const ArtifactQuery*>(
               &_ArtifactQuery_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(ArtifactQuery* other);
  friend void swap(ArtifactQuery& a, ArtifactQuery& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ArtifactQuery* New() const final {
    return CreateMaybeMessage<ArtifactQuery>(nullptr);
  }

  ArtifactQuery* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ArtifactQuery>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ArtifactQuery& from);
  void MergeFrom(const ArtifactQuery& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArtifactQuery* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .flyteidl.core.ArtifactID artifact_id = 1;
  bool has_artifact_id() const;
  void clear_artifact_id();
  static const int kArtifactIdFieldNumber = 1;
  const ::flyteidl::core::ArtifactID& artifact_id() const;
  ::flyteidl::core::ArtifactID* release_artifact_id();
  ::flyteidl::core::ArtifactID* mutable_artifact_id();
  void set_allocated_artifact_id(::flyteidl::core::ArtifactID* artifact_id);

  // .flyteidl.core.ArtifactTag artifact_tag = 2;
  bool has_artifact_tag() const;
  void clear_artifact_tag();
  static const int kArtifactTagFieldNumber = 2;
  const ::flyteidl::core::ArtifactTag& artifact_tag() const;
  ::flyteidl::core::ArtifactTag* release_artifact_tag();
  ::flyteidl::core::ArtifactTag* mutable_artifact_tag();
  void set_allocated_artifact_tag(::flyteidl::core::ArtifactTag* artifact_tag);

  // string uri = 3;
  private:
  bool has_uri() const;
  public:
  void clear_uri();
  static const int kUriFieldNumber = 3;
  const ::std::string& uri() const;
  void set_uri(const ::std::string& value);
  #if LANG_CXX11
  void set_uri(::std::string&& value);
  #endif
  void set_uri(const char* value);
  void set_uri(const char* value, size_t size);
  ::std::string* mutable_uri();
  ::std::string* release_uri();
  void set_allocated_uri(::std::string* uri);

  // .flyteidl.core.ArtifactBindingData binding = 4;
  bool has_binding() const;
  void clear_binding();
  static const int kBindingFieldNumber = 4;
  const ::flyteidl::core::ArtifactBindingData& binding() const;
  ::flyteidl::core::ArtifactBindingData* release_binding();
  ::flyteidl::core::ArtifactBindingData* mutable_binding();
  void set_allocated_binding(::flyteidl::core::ArtifactBindingData* binding);

  void clear_identifier();
  IdentifierCase identifier_case() const;
  // @@protoc_insertion_point(class_scope:flyteidl.core.ArtifactQuery)
 private:
  class HasBitSetters;
  void set_has_artifact_id();
  void set_has_artifact_tag();
  void set_has_uri();
  void set_has_binding();

  inline bool has_identifier() const;
  inline void clear_has_identifier();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union IdentifierUnion {
    IdentifierUnion() {}
    ::flyteidl::core::ArtifactID* artifact_id_;
    ::flyteidl::core::ArtifactTag* artifact_tag_;
    ::google::protobuf::internal::ArenaStringPtr uri_;
    ::flyteidl::core::ArtifactBindingData* binding_;
  } identifier_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_flyteidl_2fcore_2fidentifier_2eproto;
};
// -------------------------------------------------------------------

class Trigger final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.Trigger) */ {
 public:
  Trigger();
  virtual ~Trigger();

  Trigger(const Trigger& from);

  inline Trigger& operator=(const Trigger& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Trigger(Trigger&& from) noexcept
    : Trigger() {
    *this = ::std::move(from);
  }

  inline Trigger& operator=(Trigger&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Trigger& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Trigger* internal_default_instance() {
    return reinterpret_cast<const Trigger*>(
               &_Trigger_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(Trigger* other);
  friend void swap(Trigger& a, Trigger& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Trigger* New() const final {
    return CreateMaybeMessage<Trigger>(nullptr);
  }

  Trigger* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Trigger>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Trigger& from);
  void MergeFrom(const Trigger& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Trigger* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .flyteidl.core.ArtifactID triggers = 2;
  int triggers_size() const;
  void clear_triggers();
  static const int kTriggersFieldNumber = 2;
  ::flyteidl::core::ArtifactID* mutable_triggers(int index);
  ::google::protobuf::RepeatedPtrField< ::flyteidl::core::ArtifactID >*
      mutable_triggers();
  const ::flyteidl::core::ArtifactID& triggers(int index) const;
  ::flyteidl::core::ArtifactID* add_triggers();
  const ::google::protobuf::RepeatedPtrField< ::flyteidl::core::ArtifactID >&
      triggers() const;

  // .flyteidl.core.Identifier trigger_id = 1;
  bool has_trigger_id() const;
  void clear_trigger_id();
  static const int kTriggerIdFieldNumber = 1;
  const ::flyteidl::core::Identifier& trigger_id() const;
  ::flyteidl::core::Identifier* release_trigger_id();
  ::flyteidl::core::Identifier* mutable_trigger_id();
  void set_allocated_trigger_id(::flyteidl::core::Identifier* trigger_id);

  // @@protoc_insertion_point(class_scope:flyteidl.core.Trigger)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::flyteidl::core::ArtifactID > triggers_;
  ::flyteidl::core::Identifier* trigger_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2fidentifier_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Identifier

// .flyteidl.core.ResourceType resource_type = 1;
inline void Identifier::clear_resource_type() {
  resource_type_ = 0;
}
inline ::flyteidl::core::ResourceType Identifier::resource_type() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Identifier.resource_type)
  return static_cast< ::flyteidl::core::ResourceType >(resource_type_);
}
inline void Identifier::set_resource_type(::flyteidl::core::ResourceType value) {
  
  resource_type_ = value;
  // @@protoc_insertion_point(field_set:flyteidl.core.Identifier.resource_type)
}

// string project = 2;
inline void Identifier::clear_project() {
  project_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Identifier::project() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Identifier.project)
  return project_.GetNoArena();
}
inline void Identifier::set_project(const ::std::string& value) {
  
  project_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.Identifier.project)
}
#if LANG_CXX11
inline void Identifier::set_project(::std::string&& value) {
  
  project_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.Identifier.project)
}
#endif
inline void Identifier::set_project(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  project_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.Identifier.project)
}
inline void Identifier::set_project(const char* value, size_t size) {
  
  project_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.Identifier.project)
}
inline ::std::string* Identifier::mutable_project() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Identifier.project)
  return project_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Identifier::release_project() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Identifier.project)
  
  return project_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Identifier::set_allocated_project(::std::string* project) {
  if (project != nullptr) {
    
  } else {
    
  }
  project_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), project);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Identifier.project)
}

// string domain = 3;
inline void Identifier::clear_domain() {
  domain_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Identifier::domain() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Identifier.domain)
  return domain_.GetNoArena();
}
inline void Identifier::set_domain(const ::std::string& value) {
  
  domain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.Identifier.domain)
}
#if LANG_CXX11
inline void Identifier::set_domain(::std::string&& value) {
  
  domain_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.Identifier.domain)
}
#endif
inline void Identifier::set_domain(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  domain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.Identifier.domain)
}
inline void Identifier::set_domain(const char* value, size_t size) {
  
  domain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.Identifier.domain)
}
inline ::std::string* Identifier::mutable_domain() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Identifier.domain)
  return domain_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Identifier::release_domain() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Identifier.domain)
  
  return domain_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Identifier::set_allocated_domain(::std::string* domain) {
  if (domain != nullptr) {
    
  } else {
    
  }
  domain_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), domain);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Identifier.domain)
}

// string name = 4;
inline void Identifier::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Identifier::name() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Identifier.name)
  return name_.GetNoArena();
}
inline void Identifier::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.Identifier.name)
}
#if LANG_CXX11
inline void Identifier::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.Identifier.name)
}
#endif
inline void Identifier::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.Identifier.name)
}
inline void Identifier::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.Identifier.name)
}
inline ::std::string* Identifier::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Identifier.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Identifier::release_name() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Identifier.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Identifier::set_allocated_name(::std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Identifier.name)
}

// string version = 5;
inline void Identifier::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Identifier::version() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Identifier.version)
  return version_.GetNoArena();
}
inline void Identifier::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.Identifier.version)
}
#if LANG_CXX11
inline void Identifier::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.Identifier.version)
}
#endif
inline void Identifier::set_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.Identifier.version)
}
inline void Identifier::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.Identifier.version)
}
inline ::std::string* Identifier::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Identifier.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Identifier::release_version() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Identifier.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Identifier::set_allocated_version(::std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Identifier.version)
}

// -------------------------------------------------------------------

// WorkflowExecutionIdentifier

// string project = 1;
inline void WorkflowExecutionIdentifier::clear_project() {
  project_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WorkflowExecutionIdentifier::project() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.WorkflowExecutionIdentifier.project)
  return project_.GetNoArena();
}
inline void WorkflowExecutionIdentifier::set_project(const ::std::string& value) {
  
  project_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.WorkflowExecutionIdentifier.project)
}
#if LANG_CXX11
inline void WorkflowExecutionIdentifier::set_project(::std::string&& value) {
  
  project_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.WorkflowExecutionIdentifier.project)
}
#endif
inline void WorkflowExecutionIdentifier::set_project(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  project_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.WorkflowExecutionIdentifier.project)
}
inline void WorkflowExecutionIdentifier::set_project(const char* value, size_t size) {
  
  project_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.WorkflowExecutionIdentifier.project)
}
inline ::std::string* WorkflowExecutionIdentifier::mutable_project() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.WorkflowExecutionIdentifier.project)
  return project_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WorkflowExecutionIdentifier::release_project() {
  // @@protoc_insertion_point(field_release:flyteidl.core.WorkflowExecutionIdentifier.project)
  
  return project_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WorkflowExecutionIdentifier::set_allocated_project(::std::string* project) {
  if (project != nullptr) {
    
  } else {
    
  }
  project_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), project);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.WorkflowExecutionIdentifier.project)
}

// string domain = 2;
inline void WorkflowExecutionIdentifier::clear_domain() {
  domain_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WorkflowExecutionIdentifier::domain() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.WorkflowExecutionIdentifier.domain)
  return domain_.GetNoArena();
}
inline void WorkflowExecutionIdentifier::set_domain(const ::std::string& value) {
  
  domain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.WorkflowExecutionIdentifier.domain)
}
#if LANG_CXX11
inline void WorkflowExecutionIdentifier::set_domain(::std::string&& value) {
  
  domain_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.WorkflowExecutionIdentifier.domain)
}
#endif
inline void WorkflowExecutionIdentifier::set_domain(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  domain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.WorkflowExecutionIdentifier.domain)
}
inline void WorkflowExecutionIdentifier::set_domain(const char* value, size_t size) {
  
  domain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.WorkflowExecutionIdentifier.domain)
}
inline ::std::string* WorkflowExecutionIdentifier::mutable_domain() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.WorkflowExecutionIdentifier.domain)
  return domain_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WorkflowExecutionIdentifier::release_domain() {
  // @@protoc_insertion_point(field_release:flyteidl.core.WorkflowExecutionIdentifier.domain)
  
  return domain_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WorkflowExecutionIdentifier::set_allocated_domain(::std::string* domain) {
  if (domain != nullptr) {
    
  } else {
    
  }
  domain_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), domain);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.WorkflowExecutionIdentifier.domain)
}

// string name = 4;
inline void WorkflowExecutionIdentifier::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WorkflowExecutionIdentifier::name() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.WorkflowExecutionIdentifier.name)
  return name_.GetNoArena();
}
inline void WorkflowExecutionIdentifier::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.WorkflowExecutionIdentifier.name)
}
#if LANG_CXX11
inline void WorkflowExecutionIdentifier::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.WorkflowExecutionIdentifier.name)
}
#endif
inline void WorkflowExecutionIdentifier::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.WorkflowExecutionIdentifier.name)
}
inline void WorkflowExecutionIdentifier::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.WorkflowExecutionIdentifier.name)
}
inline ::std::string* WorkflowExecutionIdentifier::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.WorkflowExecutionIdentifier.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WorkflowExecutionIdentifier::release_name() {
  // @@protoc_insertion_point(field_release:flyteidl.core.WorkflowExecutionIdentifier.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WorkflowExecutionIdentifier::set_allocated_name(::std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.WorkflowExecutionIdentifier.name)
}

// -------------------------------------------------------------------

// NodeExecutionIdentifier

// string node_id = 1;
inline void NodeExecutionIdentifier::clear_node_id() {
  node_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NodeExecutionIdentifier::node_id() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.NodeExecutionIdentifier.node_id)
  return node_id_.GetNoArena();
}
inline void NodeExecutionIdentifier::set_node_id(const ::std::string& value) {
  
  node_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.NodeExecutionIdentifier.node_id)
}
#if LANG_CXX11
inline void NodeExecutionIdentifier::set_node_id(::std::string&& value) {
  
  node_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.NodeExecutionIdentifier.node_id)
}
#endif
inline void NodeExecutionIdentifier::set_node_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  node_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.NodeExecutionIdentifier.node_id)
}
inline void NodeExecutionIdentifier::set_node_id(const char* value, size_t size) {
  
  node_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.NodeExecutionIdentifier.node_id)
}
inline ::std::string* NodeExecutionIdentifier::mutable_node_id() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.NodeExecutionIdentifier.node_id)
  return node_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NodeExecutionIdentifier::release_node_id() {
  // @@protoc_insertion_point(field_release:flyteidl.core.NodeExecutionIdentifier.node_id)
  
  return node_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NodeExecutionIdentifier::set_allocated_node_id(::std::string* node_id) {
  if (node_id != nullptr) {
    
  } else {
    
  }
  node_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), node_id);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.NodeExecutionIdentifier.node_id)
}

// .flyteidl.core.WorkflowExecutionIdentifier execution_id = 2;
inline bool NodeExecutionIdentifier::has_execution_id() const {
  return this != internal_default_instance() && execution_id_ != nullptr;
}
inline void NodeExecutionIdentifier::clear_execution_id() {
  if (GetArenaNoVirtual() == nullptr && execution_id_ != nullptr) {
    delete execution_id_;
  }
  execution_id_ = nullptr;
}
inline const ::flyteidl::core::WorkflowExecutionIdentifier& NodeExecutionIdentifier::execution_id() const {
  const ::flyteidl::core::WorkflowExecutionIdentifier* p = execution_id_;
  // @@protoc_insertion_point(field_get:flyteidl.core.NodeExecutionIdentifier.execution_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::WorkflowExecutionIdentifier*>(
      &::flyteidl::core::_WorkflowExecutionIdentifier_default_instance_);
}
inline ::flyteidl::core::WorkflowExecutionIdentifier* NodeExecutionIdentifier::release_execution_id() {
  // @@protoc_insertion_point(field_release:flyteidl.core.NodeExecutionIdentifier.execution_id)
  
  ::flyteidl::core::WorkflowExecutionIdentifier* temp = execution_id_;
  execution_id_ = nullptr;
  return temp;
}
inline ::flyteidl::core::WorkflowExecutionIdentifier* NodeExecutionIdentifier::mutable_execution_id() {
  
  if (execution_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::WorkflowExecutionIdentifier>(GetArenaNoVirtual());
    execution_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.NodeExecutionIdentifier.execution_id)
  return execution_id_;
}
inline void NodeExecutionIdentifier::set_allocated_execution_id(::flyteidl::core::WorkflowExecutionIdentifier* execution_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete execution_id_;
  }
  if (execution_id) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      execution_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, execution_id, submessage_arena);
    }
    
  } else {
    
  }
  execution_id_ = execution_id;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.NodeExecutionIdentifier.execution_id)
}

// -------------------------------------------------------------------

// TaskExecutionIdentifier

// .flyteidl.core.Identifier task_id = 1;
inline bool TaskExecutionIdentifier::has_task_id() const {
  return this != internal_default_instance() && task_id_ != nullptr;
}
inline void TaskExecutionIdentifier::clear_task_id() {
  if (GetArenaNoVirtual() == nullptr && task_id_ != nullptr) {
    delete task_id_;
  }
  task_id_ = nullptr;
}
inline const ::flyteidl::core::Identifier& TaskExecutionIdentifier::task_id() const {
  const ::flyteidl::core::Identifier* p = task_id_;
  // @@protoc_insertion_point(field_get:flyteidl.core.TaskExecutionIdentifier.task_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::Identifier*>(
      &::flyteidl::core::_Identifier_default_instance_);
}
inline ::flyteidl::core::Identifier* TaskExecutionIdentifier::release_task_id() {
  // @@protoc_insertion_point(field_release:flyteidl.core.TaskExecutionIdentifier.task_id)
  
  ::flyteidl::core::Identifier* temp = task_id_;
  task_id_ = nullptr;
  return temp;
}
inline ::flyteidl::core::Identifier* TaskExecutionIdentifier::mutable_task_id() {
  
  if (task_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::Identifier>(GetArenaNoVirtual());
    task_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.TaskExecutionIdentifier.task_id)
  return task_id_;
}
inline void TaskExecutionIdentifier::set_allocated_task_id(::flyteidl::core::Identifier* task_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete task_id_;
  }
  if (task_id) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      task_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, task_id, submessage_arena);
    }
    
  } else {
    
  }
  task_id_ = task_id;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.TaskExecutionIdentifier.task_id)
}

// .flyteidl.core.NodeExecutionIdentifier node_execution_id = 2;
inline bool TaskExecutionIdentifier::has_node_execution_id() const {
  return this != internal_default_instance() && node_execution_id_ != nullptr;
}
inline void TaskExecutionIdentifier::clear_node_execution_id() {
  if (GetArenaNoVirtual() == nullptr && node_execution_id_ != nullptr) {
    delete node_execution_id_;
  }
  node_execution_id_ = nullptr;
}
inline const ::flyteidl::core::NodeExecutionIdentifier& TaskExecutionIdentifier::node_execution_id() const {
  const ::flyteidl::core::NodeExecutionIdentifier* p = node_execution_id_;
  // @@protoc_insertion_point(field_get:flyteidl.core.TaskExecutionIdentifier.node_execution_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::NodeExecutionIdentifier*>(
      &::flyteidl::core::_NodeExecutionIdentifier_default_instance_);
}
inline ::flyteidl::core::NodeExecutionIdentifier* TaskExecutionIdentifier::release_node_execution_id() {
  // @@protoc_insertion_point(field_release:flyteidl.core.TaskExecutionIdentifier.node_execution_id)
  
  ::flyteidl::core::NodeExecutionIdentifier* temp = node_execution_id_;
  node_execution_id_ = nullptr;
  return temp;
}
inline ::flyteidl::core::NodeExecutionIdentifier* TaskExecutionIdentifier::mutable_node_execution_id() {
  
  if (node_execution_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::NodeExecutionIdentifier>(GetArenaNoVirtual());
    node_execution_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.TaskExecutionIdentifier.node_execution_id)
  return node_execution_id_;
}
inline void TaskExecutionIdentifier::set_allocated_node_execution_id(::flyteidl::core::NodeExecutionIdentifier* node_execution_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete node_execution_id_;
  }
  if (node_execution_id) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      node_execution_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, node_execution_id, submessage_arena);
    }
    
  } else {
    
  }
  node_execution_id_ = node_execution_id;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.TaskExecutionIdentifier.node_execution_id)
}

// uint32 retry_attempt = 3;
inline void TaskExecutionIdentifier::clear_retry_attempt() {
  retry_attempt_ = 0u;
}
inline ::google::protobuf::uint32 TaskExecutionIdentifier::retry_attempt() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.TaskExecutionIdentifier.retry_attempt)
  return retry_attempt_;
}
inline void TaskExecutionIdentifier::set_retry_attempt(::google::protobuf::uint32 value) {
  
  retry_attempt_ = value;
  // @@protoc_insertion_point(field_set:flyteidl.core.TaskExecutionIdentifier.retry_attempt)
}

// -------------------------------------------------------------------

// SignalIdentifier

// string signal_id = 1;
inline void SignalIdentifier::clear_signal_id() {
  signal_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SignalIdentifier::signal_id() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.SignalIdentifier.signal_id)
  return signal_id_.GetNoArena();
}
inline void SignalIdentifier::set_signal_id(const ::std::string& value) {
  
  signal_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.SignalIdentifier.signal_id)
}
#if LANG_CXX11
inline void SignalIdentifier::set_signal_id(::std::string&& value) {
  
  signal_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.SignalIdentifier.signal_id)
}
#endif
inline void SignalIdentifier::set_signal_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  signal_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.SignalIdentifier.signal_id)
}
inline void SignalIdentifier::set_signal_id(const char* value, size_t size) {
  
  signal_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.SignalIdentifier.signal_id)
}
inline ::std::string* SignalIdentifier::mutable_signal_id() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.SignalIdentifier.signal_id)
  return signal_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SignalIdentifier::release_signal_id() {
  // @@protoc_insertion_point(field_release:flyteidl.core.SignalIdentifier.signal_id)
  
  return signal_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SignalIdentifier::set_allocated_signal_id(::std::string* signal_id) {
  if (signal_id != nullptr) {
    
  } else {
    
  }
  signal_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signal_id);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.SignalIdentifier.signal_id)
}

// .flyteidl.core.WorkflowExecutionIdentifier execution_id = 2;
inline bool SignalIdentifier::has_execution_id() const {
  return this != internal_default_instance() && execution_id_ != nullptr;
}
inline void SignalIdentifier::clear_execution_id() {
  if (GetArenaNoVirtual() == nullptr && execution_id_ != nullptr) {
    delete execution_id_;
  }
  execution_id_ = nullptr;
}
inline const ::flyteidl::core::WorkflowExecutionIdentifier& SignalIdentifier::execution_id() const {
  const ::flyteidl::core::WorkflowExecutionIdentifier* p = execution_id_;
  // @@protoc_insertion_point(field_get:flyteidl.core.SignalIdentifier.execution_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::WorkflowExecutionIdentifier*>(
      &::flyteidl::core::_WorkflowExecutionIdentifier_default_instance_);
}
inline ::flyteidl::core::WorkflowExecutionIdentifier* SignalIdentifier::release_execution_id() {
  // @@protoc_insertion_point(field_release:flyteidl.core.SignalIdentifier.execution_id)
  
  ::flyteidl::core::WorkflowExecutionIdentifier* temp = execution_id_;
  execution_id_ = nullptr;
  return temp;
}
inline ::flyteidl::core::WorkflowExecutionIdentifier* SignalIdentifier::mutable_execution_id() {
  
  if (execution_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::WorkflowExecutionIdentifier>(GetArenaNoVirtual());
    execution_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.SignalIdentifier.execution_id)
  return execution_id_;
}
inline void SignalIdentifier::set_allocated_execution_id(::flyteidl::core::WorkflowExecutionIdentifier* execution_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete execution_id_;
  }
  if (execution_id) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      execution_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, execution_id, submessage_arena);
    }
    
  } else {
    
  }
  execution_id_ = execution_id;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.SignalIdentifier.execution_id)
}

// -------------------------------------------------------------------

// ArtifactKey

// string project = 1;
inline void ArtifactKey::clear_project() {
  project_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ArtifactKey::project() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.ArtifactKey.project)
  return project_.GetNoArena();
}
inline void ArtifactKey::set_project(const ::std::string& value) {
  
  project_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.ArtifactKey.project)
}
#if LANG_CXX11
inline void ArtifactKey::set_project(::std::string&& value) {
  
  project_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.ArtifactKey.project)
}
#endif
inline void ArtifactKey::set_project(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  project_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.ArtifactKey.project)
}
inline void ArtifactKey::set_project(const char* value, size_t size) {
  
  project_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.ArtifactKey.project)
}
inline ::std::string* ArtifactKey::mutable_project() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.ArtifactKey.project)
  return project_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ArtifactKey::release_project() {
  // @@protoc_insertion_point(field_release:flyteidl.core.ArtifactKey.project)
  
  return project_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ArtifactKey::set_allocated_project(::std::string* project) {
  if (project != nullptr) {
    
  } else {
    
  }
  project_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), project);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.ArtifactKey.project)
}

// string domain = 2;
inline void ArtifactKey::clear_domain() {
  domain_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ArtifactKey::domain() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.ArtifactKey.domain)
  return domain_.GetNoArena();
}
inline void ArtifactKey::set_domain(const ::std::string& value) {
  
  domain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.ArtifactKey.domain)
}
#if LANG_CXX11
inline void ArtifactKey::set_domain(::std::string&& value) {
  
  domain_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.ArtifactKey.domain)
}
#endif
inline void ArtifactKey::set_domain(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  domain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.ArtifactKey.domain)
}
inline void ArtifactKey::set_domain(const char* value, size_t size) {
  
  domain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.ArtifactKey.domain)
}
inline ::std::string* ArtifactKey::mutable_domain() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.ArtifactKey.domain)
  return domain_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ArtifactKey::release_domain() {
  // @@protoc_insertion_point(field_release:flyteidl.core.ArtifactKey.domain)
  
  return domain_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ArtifactKey::set_allocated_domain(::std::string* domain) {
  if (domain != nullptr) {
    
  } else {
    
  }
  domain_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), domain);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.ArtifactKey.domain)
}

// string name = 3;
inline void ArtifactKey::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ArtifactKey::name() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.ArtifactKey.name)
  return name_.GetNoArena();
}
inline void ArtifactKey::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.ArtifactKey.name)
}
#if LANG_CXX11
inline void ArtifactKey::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.ArtifactKey.name)
}
#endif
inline void ArtifactKey::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.ArtifactKey.name)
}
inline void ArtifactKey::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.ArtifactKey.name)
}
inline ::std::string* ArtifactKey::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.ArtifactKey.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ArtifactKey::release_name() {
  // @@protoc_insertion_point(field_release:flyteidl.core.ArtifactKey.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ArtifactKey::set_allocated_name(::std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.ArtifactKey.name)
}

// -------------------------------------------------------------------

// ArtifactBindingData

// uint32 index = 1;
inline void ArtifactBindingData::clear_index() {
  index_ = 0u;
}
inline ::google::protobuf::uint32 ArtifactBindingData::index() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.ArtifactBindingData.index)
  return index_;
}
inline void ArtifactBindingData::set_index(::google::protobuf::uint32 value) {
  
  index_ = value;
  // @@protoc_insertion_point(field_set:flyteidl.core.ArtifactBindingData.index)
}

// string partition_key = 2;
inline void ArtifactBindingData::clear_partition_key() {
  partition_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ArtifactBindingData::partition_key() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.ArtifactBindingData.partition_key)
  return partition_key_.GetNoArena();
}
inline void ArtifactBindingData::set_partition_key(const ::std::string& value) {
  
  partition_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.ArtifactBindingData.partition_key)
}
#if LANG_CXX11
inline void ArtifactBindingData::set_partition_key(::std::string&& value) {
  
  partition_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.ArtifactBindingData.partition_key)
}
#endif
inline void ArtifactBindingData::set_partition_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  partition_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.ArtifactBindingData.partition_key)
}
inline void ArtifactBindingData::set_partition_key(const char* value, size_t size) {
  
  partition_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.ArtifactBindingData.partition_key)
}
inline ::std::string* ArtifactBindingData::mutable_partition_key() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.ArtifactBindingData.partition_key)
  return partition_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ArtifactBindingData::release_partition_key() {
  // @@protoc_insertion_point(field_release:flyteidl.core.ArtifactBindingData.partition_key)
  
  return partition_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ArtifactBindingData::set_allocated_partition_key(::std::string* partition_key) {
  if (partition_key != nullptr) {
    
  } else {
    
  }
  partition_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), partition_key);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.ArtifactBindingData.partition_key)
}

// string transform = 3;
inline void ArtifactBindingData::clear_transform() {
  transform_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ArtifactBindingData::transform() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.ArtifactBindingData.transform)
  return transform_.GetNoArena();
}
inline void ArtifactBindingData::set_transform(const ::std::string& value) {
  
  transform_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.ArtifactBindingData.transform)
}
#if LANG_CXX11
inline void ArtifactBindingData::set_transform(::std::string&& value) {
  
  transform_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.ArtifactBindingData.transform)
}
#endif
inline void ArtifactBindingData::set_transform(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  transform_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.ArtifactBindingData.transform)
}
inline void ArtifactBindingData::set_transform(const char* value, size_t size) {
  
  transform_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.ArtifactBindingData.transform)
}
inline ::std::string* ArtifactBindingData::mutable_transform() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.ArtifactBindingData.transform)
  return transform_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ArtifactBindingData::release_transform() {
  // @@protoc_insertion_point(field_release:flyteidl.core.ArtifactBindingData.transform)
  
  return transform_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ArtifactBindingData::set_allocated_transform(::std::string* transform) {
  if (transform != nullptr) {
    
  } else {
    
  }
  transform_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), transform);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.ArtifactBindingData.transform)
}

// -------------------------------------------------------------------

// PartitionValue

// string static_value = 1;
inline void PartitionValue::clear_static_value() {
  static_value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PartitionValue::static_value() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.PartitionValue.static_value)
  return static_value_.GetNoArena();
}
inline void PartitionValue::set_static_value(const ::std::string& value) {
  
  static_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.PartitionValue.static_value)
}
#if LANG_CXX11
inline void PartitionValue::set_static_value(::std::string&& value) {
  
  static_value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.PartitionValue.static_value)
}
#endif
inline void PartitionValue::set_static_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  static_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.PartitionValue.static_value)
}
inline void PartitionValue::set_static_value(const char* value, size_t size) {
  
  static_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.PartitionValue.static_value)
}
inline ::std::string* PartitionValue::mutable_static_value() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.PartitionValue.static_value)
  return static_value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PartitionValue::release_static_value() {
  // @@protoc_insertion_point(field_release:flyteidl.core.PartitionValue.static_value)
  
  return static_value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PartitionValue::set_allocated_static_value(::std::string* static_value) {
  if (static_value != nullptr) {
    
  } else {
    
  }
  static_value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), static_value);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.PartitionValue.static_value)
}

// .flyteidl.core.ArtifactBindingData binding = 2;
inline bool PartitionValue::has_binding() const {
  return this != internal_default_instance() && binding_ != nullptr;
}
inline void PartitionValue::clear_binding() {
  if (GetArenaNoVirtual() == nullptr && binding_ != nullptr) {
    delete binding_;
  }
  binding_ = nullptr;
}
inline const ::flyteidl::core::ArtifactBindingData& PartitionValue::binding() const {
  const ::flyteidl::core::ArtifactBindingData* p = binding_;
  // @@protoc_insertion_point(field_get:flyteidl.core.PartitionValue.binding)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::ArtifactBindingData*>(
      &::flyteidl::core::_ArtifactBindingData_default_instance_);
}
inline ::flyteidl::core::ArtifactBindingData* PartitionValue::release_binding() {
  // @@protoc_insertion_point(field_release:flyteidl.core.PartitionValue.binding)
  
  ::flyteidl::core::ArtifactBindingData* temp = binding_;
  binding_ = nullptr;
  return temp;
}
inline ::flyteidl::core::ArtifactBindingData* PartitionValue::mutable_binding() {
  
  if (binding_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::ArtifactBindingData>(GetArenaNoVirtual());
    binding_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.PartitionValue.binding)
  return binding_;
}
inline void PartitionValue::set_allocated_binding(::flyteidl::core::ArtifactBindingData* binding) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete binding_;
  }
  if (binding) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      binding = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, binding, submessage_arena);
    }
    
  } else {
    
  }
  binding_ = binding;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.PartitionValue.binding)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Partitions

// map<string, .flyteidl.core.PartitionValue> value = 1;
inline int Partitions::value_size() const {
  return value_.size();
}
inline void Partitions::clear_value() {
  value_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::flyteidl::core::PartitionValue >&
Partitions::value() const {
  // @@protoc_insertion_point(field_map:flyteidl.core.Partitions.value)
  return value_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::flyteidl::core::PartitionValue >*
Partitions::mutable_value() {
  // @@protoc_insertion_point(field_mutable_map:flyteidl.core.Partitions.value)
  return value_.MutableMap();
}

// -------------------------------------------------------------------

// ArtifactID

// .flyteidl.core.ArtifactKey artifact_key = 1;
inline bool ArtifactID::has_artifact_key() const {
  return this != internal_default_instance() && artifact_key_ != nullptr;
}
inline void ArtifactID::clear_artifact_key() {
  if (GetArenaNoVirtual() == nullptr && artifact_key_ != nullptr) {
    delete artifact_key_;
  }
  artifact_key_ = nullptr;
}
inline const ::flyteidl::core::ArtifactKey& ArtifactID::artifact_key() const {
  const ::flyteidl::core::ArtifactKey* p = artifact_key_;
  // @@protoc_insertion_point(field_get:flyteidl.core.ArtifactID.artifact_key)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::ArtifactKey*>(
      &::flyteidl::core::_ArtifactKey_default_instance_);
}
inline ::flyteidl::core::ArtifactKey* ArtifactID::release_artifact_key() {
  // @@protoc_insertion_point(field_release:flyteidl.core.ArtifactID.artifact_key)
  
  ::flyteidl::core::ArtifactKey* temp = artifact_key_;
  artifact_key_ = nullptr;
  return temp;
}
inline ::flyteidl::core::ArtifactKey* ArtifactID::mutable_artifact_key() {
  
  if (artifact_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::ArtifactKey>(GetArenaNoVirtual());
    artifact_key_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.ArtifactID.artifact_key)
  return artifact_key_;
}
inline void ArtifactID::set_allocated_artifact_key(::flyteidl::core::ArtifactKey* artifact_key) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete artifact_key_;
  }
  if (artifact_key) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      artifact_key = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, artifact_key, submessage_arena);
    }
    
  } else {
    
  }
  artifact_key_ = artifact_key;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.ArtifactID.artifact_key)
}

// string version = 2;
inline void ArtifactID::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ArtifactID::version() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.ArtifactID.version)
  return version_.GetNoArena();
}
inline void ArtifactID::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.ArtifactID.version)
}
#if LANG_CXX11
inline void ArtifactID::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.ArtifactID.version)
}
#endif
inline void ArtifactID::set_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.ArtifactID.version)
}
inline void ArtifactID::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.ArtifactID.version)
}
inline ::std::string* ArtifactID::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.ArtifactID.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ArtifactID::release_version() {
  // @@protoc_insertion_point(field_release:flyteidl.core.ArtifactID.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ArtifactID::set_allocated_version(::std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.ArtifactID.version)
}

// .flyteidl.core.Partitions partitions = 3;
inline bool ArtifactID::has_partitions() const {
  return dimensions_case() == kPartitions;
}
inline void ArtifactID::set_has_partitions() {
  _oneof_case_[0] = kPartitions;
}
inline void ArtifactID::clear_partitions() {
  if (has_partitions()) {
    delete dimensions_.partitions_;
    clear_has_dimensions();
  }
}
inline ::flyteidl::core::Partitions* ArtifactID::release_partitions() {
  // @@protoc_insertion_point(field_release:flyteidl.core.ArtifactID.partitions)
  if (has_partitions()) {
    clear_has_dimensions();
      ::flyteidl::core::Partitions* temp = dimensions_.partitions_;
    dimensions_.partitions_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::Partitions& ArtifactID::partitions() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.ArtifactID.partitions)
  return has_partitions()
      ? *dimensions_.partitions_
      : *reinterpret_cast< ::flyteidl::core::Partitions*>(&::flyteidl::core::_Partitions_default_instance_);
}
inline ::flyteidl::core::Partitions* ArtifactID::mutable_partitions() {
  if (!has_partitions()) {
    clear_dimensions();
    set_has_partitions();
    dimensions_.partitions_ = CreateMaybeMessage< ::flyteidl::core::Partitions >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.ArtifactID.partitions)
  return dimensions_.partitions_;
}

inline bool ArtifactID::has_dimensions() const {
  return dimensions_case() != DIMENSIONS_NOT_SET;
}
inline void ArtifactID::clear_has_dimensions() {
  _oneof_case_[0] = DIMENSIONS_NOT_SET;
}
inline ArtifactID::DimensionsCase ArtifactID::dimensions_case() const {
  return ArtifactID::DimensionsCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ArtifactTag

// .flyteidl.core.ArtifactKey artifact_key = 1;
inline bool ArtifactTag::has_artifact_key() const {
  return this != internal_default_instance() && artifact_key_ != nullptr;
}
inline void ArtifactTag::clear_artifact_key() {
  if (GetArenaNoVirtual() == nullptr && artifact_key_ != nullptr) {
    delete artifact_key_;
  }
  artifact_key_ = nullptr;
}
inline const ::flyteidl::core::ArtifactKey& ArtifactTag::artifact_key() const {
  const ::flyteidl::core::ArtifactKey* p = artifact_key_;
  // @@protoc_insertion_point(field_get:flyteidl.core.ArtifactTag.artifact_key)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::ArtifactKey*>(
      &::flyteidl::core::_ArtifactKey_default_instance_);
}
inline ::flyteidl::core::ArtifactKey* ArtifactTag::release_artifact_key() {
  // @@protoc_insertion_point(field_release:flyteidl.core.ArtifactTag.artifact_key)
  
  ::flyteidl::core::ArtifactKey* temp = artifact_key_;
  artifact_key_ = nullptr;
  return temp;
}
inline ::flyteidl::core::ArtifactKey* ArtifactTag::mutable_artifact_key() {
  
  if (artifact_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::ArtifactKey>(GetArenaNoVirtual());
    artifact_key_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.ArtifactTag.artifact_key)
  return artifact_key_;
}
inline void ArtifactTag::set_allocated_artifact_key(::flyteidl::core::ArtifactKey* artifact_key) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete artifact_key_;
  }
  if (artifact_key) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      artifact_key = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, artifact_key, submessage_arena);
    }
    
  } else {
    
  }
  artifact_key_ = artifact_key;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.ArtifactTag.artifact_key)
}

// string value = 2;
inline void ArtifactTag::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ArtifactTag::value() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.ArtifactTag.value)
  return value_.GetNoArena();
}
inline void ArtifactTag::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.ArtifactTag.value)
}
#if LANG_CXX11
inline void ArtifactTag::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.ArtifactTag.value)
}
#endif
inline void ArtifactTag::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.ArtifactTag.value)
}
inline void ArtifactTag::set_value(const char* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.ArtifactTag.value)
}
inline ::std::string* ArtifactTag::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.ArtifactTag.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ArtifactTag::release_value() {
  // @@protoc_insertion_point(field_release:flyteidl.core.ArtifactTag.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ArtifactTag::set_allocated_value(::std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.ArtifactTag.value)
}

// -------------------------------------------------------------------

// ArtifactQuery

// .flyteidl.core.ArtifactID artifact_id = 1;
inline bool ArtifactQuery::has_artifact_id() const {
  return identifier_case() == kArtifactId;
}
inline void ArtifactQuery::set_has_artifact_id() {
  _oneof_case_[0] = kArtifactId;
}
inline void ArtifactQuery::clear_artifact_id() {
  if (has_artifact_id()) {
    delete identifier_.artifact_id_;
    clear_has_identifier();
  }
}
inline ::flyteidl::core::ArtifactID* ArtifactQuery::release_artifact_id() {
  // @@protoc_insertion_point(field_release:flyteidl.core.ArtifactQuery.artifact_id)
  if (has_artifact_id()) {
    clear_has_identifier();
      ::flyteidl::core::ArtifactID* temp = identifier_.artifact_id_;
    identifier_.artifact_id_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::ArtifactID& ArtifactQuery::artifact_id() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.ArtifactQuery.artifact_id)
  return has_artifact_id()
      ? *identifier_.artifact_id_
      : *reinterpret_cast< ::flyteidl::core::ArtifactID*>(&::flyteidl::core::_ArtifactID_default_instance_);
}
inline ::flyteidl::core::ArtifactID* ArtifactQuery::mutable_artifact_id() {
  if (!has_artifact_id()) {
    clear_identifier();
    set_has_artifact_id();
    identifier_.artifact_id_ = CreateMaybeMessage< ::flyteidl::core::ArtifactID >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.ArtifactQuery.artifact_id)
  return identifier_.artifact_id_;
}

// .flyteidl.core.ArtifactTag artifact_tag = 2;
inline bool ArtifactQuery::has_artifact_tag() const {
  return identifier_case() == kArtifactTag;
}
inline void ArtifactQuery::set_has_artifact_tag() {
  _oneof_case_[0] = kArtifactTag;
}
inline void ArtifactQuery::clear_artifact_tag() {
  if (has_artifact_tag()) {
    delete identifier_.artifact_tag_;
    clear_has_identifier();
  }
}
inline ::flyteidl::core::ArtifactTag* ArtifactQuery::release_artifact_tag() {
  // @@protoc_insertion_point(field_release:flyteidl.core.ArtifactQuery.artifact_tag)
  if (has_artifact_tag()) {
    clear_has_identifier();
      ::flyteidl::core::ArtifactTag* temp = identifier_.artifact_tag_;
    identifier_.artifact_tag_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::ArtifactTag& ArtifactQuery::artifact_tag() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.ArtifactQuery.artifact_tag)
  return has_artifact_tag()
      ? *identifier_.artifact_tag_
      : *reinterpret_cast< ::flyteidl::core::ArtifactTag*>(&::flyteidl::core::_ArtifactTag_default_instance_);
}
inline ::flyteidl::core::ArtifactTag* ArtifactQuery::mutable_artifact_tag() {
  if (!has_artifact_tag()) {
    clear_identifier();
    set_has_artifact_tag();
    identifier_.artifact_tag_ = CreateMaybeMessage< ::flyteidl::core::ArtifactTag >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.ArtifactQuery.artifact_tag)
  return identifier_.artifact_tag_;
}

// string uri = 3;
inline bool ArtifactQuery::has_uri() const {
  return identifier_case() == kUri;
}
inline void ArtifactQuery::set_has_uri() {
  _oneof_case_[0] = kUri;
}
inline void ArtifactQuery::clear_uri() {
  if (has_uri()) {
    identifier_.uri_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_identifier();
  }
}
inline const ::std::string& ArtifactQuery::uri() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.ArtifactQuery.uri)
  if (has_uri()) {
    return identifier_.uri_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void ArtifactQuery::set_uri(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:flyteidl.core.ArtifactQuery.uri)
  if (!has_uri()) {
    clear_identifier();
    set_has_uri();
    identifier_.uri_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  identifier_.uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.ArtifactQuery.uri)
}
#if LANG_CXX11
inline void ArtifactQuery::set_uri(::std::string&& value) {
  // @@protoc_insertion_point(field_set:flyteidl.core.ArtifactQuery.uri)
  if (!has_uri()) {
    clear_identifier();
    set_has_uri();
    identifier_.uri_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  identifier_.uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.ArtifactQuery.uri)
}
#endif
inline void ArtifactQuery::set_uri(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!has_uri()) {
    clear_identifier();
    set_has_uri();
    identifier_.uri_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  identifier_.uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.ArtifactQuery.uri)
}
inline void ArtifactQuery::set_uri(const char* value, size_t size) {
  if (!has_uri()) {
    clear_identifier();
    set_has_uri();
    identifier_.uri_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  identifier_.uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.ArtifactQuery.uri)
}
inline ::std::string* ArtifactQuery::mutable_uri() {
  if (!has_uri()) {
    clear_identifier();
    set_has_uri();
    identifier_.uri_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.ArtifactQuery.uri)
  return identifier_.uri_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ArtifactQuery::release_uri() {
  // @@protoc_insertion_point(field_release:flyteidl.core.ArtifactQuery.uri)
  if (has_uri()) {
    clear_has_identifier();
    return identifier_.uri_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return nullptr;
  }
}
inline void ArtifactQuery::set_allocated_uri(::std::string* uri) {
  if (has_identifier()) {
    clear_identifier();
  }
  if (uri != nullptr) {
    set_has_uri();
    identifier_.uri_.UnsafeSetDefault(uri);
  }
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.ArtifactQuery.uri)
}

// .flyteidl.core.ArtifactBindingData binding = 4;
inline bool ArtifactQuery::has_binding() const {
  return identifier_case() == kBinding;
}
inline void ArtifactQuery::set_has_binding() {
  _oneof_case_[0] = kBinding;
}
inline void ArtifactQuery::clear_binding() {
  if (has_binding()) {
    delete identifier_.binding_;
    clear_has_identifier();
  }
}
inline ::flyteidl::core::ArtifactBindingData* ArtifactQuery::release_binding() {
  // @@protoc_insertion_point(field_release:flyteidl.core.ArtifactQuery.binding)
  if (has_binding()) {
    clear_has_identifier();
      ::flyteidl::core::ArtifactBindingData* temp = identifier_.binding_;
    identifier_.binding_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::ArtifactBindingData& ArtifactQuery::binding() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.ArtifactQuery.binding)
  return has_binding()
      ? *identifier_.binding_
      : *reinterpret_cast< ::flyteidl::core::ArtifactBindingData*>(&::flyteidl::core::_ArtifactBindingData_default_instance_);
}
inline ::flyteidl::core::ArtifactBindingData* ArtifactQuery::mutable_binding() {
  if (!has_binding()) {
    clear_identifier();
    set_has_binding();
    identifier_.binding_ = CreateMaybeMessage< ::flyteidl::core::ArtifactBindingData >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.ArtifactQuery.binding)
  return identifier_.binding_;
}

inline bool ArtifactQuery::has_identifier() const {
  return identifier_case() != IDENTIFIER_NOT_SET;
}
inline void ArtifactQuery::clear_has_identifier() {
  _oneof_case_[0] = IDENTIFIER_NOT_SET;
}
inline ArtifactQuery::IdentifierCase ArtifactQuery::identifier_case() const {
  return ArtifactQuery::IdentifierCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Trigger

// .flyteidl.core.Identifier trigger_id = 1;
inline bool Trigger::has_trigger_id() const {
  return this != internal_default_instance() && trigger_id_ != nullptr;
}
inline void Trigger::clear_trigger_id() {
  if (GetArenaNoVirtual() == nullptr && trigger_id_ != nullptr) {
    delete trigger_id_;
  }
  trigger_id_ = nullptr;
}
inline const ::flyteidl::core::Identifier& Trigger::trigger_id() const {
  const ::flyteidl::core::Identifier* p = trigger_id_;
  // @@protoc_insertion_point(field_get:flyteidl.core.Trigger.trigger_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::Identifier*>(
      &::flyteidl::core::_Identifier_default_instance_);
}
inline ::flyteidl::core::Identifier* Trigger::release_trigger_id() {
  // @@protoc_insertion_point(field_release:flyteidl.core.Trigger.trigger_id)
  
  ::flyteidl::core::Identifier* temp = trigger_id_;
  trigger_id_ = nullptr;
  return temp;
}
inline ::flyteidl::core::Identifier* Trigger::mutable_trigger_id() {
  
  if (trigger_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::Identifier>(GetArenaNoVirtual());
    trigger_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Trigger.trigger_id)
  return trigger_id_;
}
inline void Trigger::set_allocated_trigger_id(::flyteidl::core::Identifier* trigger_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete trigger_id_;
  }
  if (trigger_id) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      trigger_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, trigger_id, submessage_arena);
    }
    
  } else {
    
  }
  trigger_id_ = trigger_id;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.Trigger.trigger_id)
}

// repeated .flyteidl.core.ArtifactID triggers = 2;
inline int Trigger::triggers_size() const {
  return triggers_.size();
}
inline void Trigger::clear_triggers() {
  triggers_.Clear();
}
inline ::flyteidl::core::ArtifactID* Trigger::mutable_triggers(int index) {
  // @@protoc_insertion_point(field_mutable:flyteidl.core.Trigger.triggers)
  return triggers_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::flyteidl::core::ArtifactID >*
Trigger::mutable_triggers() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.core.Trigger.triggers)
  return &triggers_;
}
inline const ::flyteidl::core::ArtifactID& Trigger::triggers(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.core.Trigger.triggers)
  return triggers_.Get(index);
}
inline ::flyteidl::core::ArtifactID* Trigger::add_triggers() {
  // @@protoc_insertion_point(field_add:flyteidl.core.Trigger.triggers)
  return triggers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::flyteidl::core::ArtifactID >&
Trigger::triggers() const {
  // @@protoc_insertion_point(field_list:flyteidl.core.Trigger.triggers)
  return triggers_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace core
}  // namespace flyteidl

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::flyteidl::core::ResourceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::flyteidl::core::ResourceType>() {
  return ::flyteidl::core::ResourceType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_flyteidl_2fcore_2fidentifier_2eproto
