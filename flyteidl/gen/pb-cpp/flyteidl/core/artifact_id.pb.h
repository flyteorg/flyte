// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: flyteidl/core/artifact_id.proto

#ifndef PROTOBUF_INCLUDED_flyteidl_2fcore_2fartifact_5fid_2eproto
#define PROTOBUF_INCLUDED_flyteidl_2fcore_2fartifact_5fid_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
#include "flyteidl/core/identifier.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_flyteidl_2fcore_2fartifact_5fid_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_flyteidl_2fcore_2fartifact_5fid_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[10]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_flyteidl_2fcore_2fartifact_5fid_2eproto();
namespace flyteidl {
namespace core {
class ArtifactBindingData;
class ArtifactBindingDataDefaultTypeInternal;
extern ArtifactBindingDataDefaultTypeInternal _ArtifactBindingData_default_instance_;
class ArtifactID;
class ArtifactIDDefaultTypeInternal;
extern ArtifactIDDefaultTypeInternal _ArtifactID_default_instance_;
class ArtifactKey;
class ArtifactKeyDefaultTypeInternal;
extern ArtifactKeyDefaultTypeInternal _ArtifactKey_default_instance_;
class ArtifactQuery;
class ArtifactQueryDefaultTypeInternal;
extern ArtifactQueryDefaultTypeInternal _ArtifactQuery_default_instance_;
class ArtifactTag;
class ArtifactTagDefaultTypeInternal;
extern ArtifactTagDefaultTypeInternal _ArtifactTag_default_instance_;
class InputBindingData;
class InputBindingDataDefaultTypeInternal;
extern InputBindingDataDefaultTypeInternal _InputBindingData_default_instance_;
class LabelValue;
class LabelValueDefaultTypeInternal;
extern LabelValueDefaultTypeInternal _LabelValue_default_instance_;
class Partitions;
class PartitionsDefaultTypeInternal;
extern PartitionsDefaultTypeInternal _Partitions_default_instance_;
class Partitions_ValueEntry_DoNotUse;
class Partitions_ValueEntry_DoNotUseDefaultTypeInternal;
extern Partitions_ValueEntry_DoNotUseDefaultTypeInternal _Partitions_ValueEntry_DoNotUse_default_instance_;
class TimePartition;
class TimePartitionDefaultTypeInternal;
extern TimePartitionDefaultTypeInternal _TimePartition_default_instance_;
}  // namespace core
}  // namespace flyteidl
namespace google {
namespace protobuf {
template<> ::flyteidl::core::ArtifactBindingData* Arena::CreateMaybeMessage<::flyteidl::core::ArtifactBindingData>(Arena*);
template<> ::flyteidl::core::ArtifactID* Arena::CreateMaybeMessage<::flyteidl::core::ArtifactID>(Arena*);
template<> ::flyteidl::core::ArtifactKey* Arena::CreateMaybeMessage<::flyteidl::core::ArtifactKey>(Arena*);
template<> ::flyteidl::core::ArtifactQuery* Arena::CreateMaybeMessage<::flyteidl::core::ArtifactQuery>(Arena*);
template<> ::flyteidl::core::ArtifactTag* Arena::CreateMaybeMessage<::flyteidl::core::ArtifactTag>(Arena*);
template<> ::flyteidl::core::InputBindingData* Arena::CreateMaybeMessage<::flyteidl::core::InputBindingData>(Arena*);
template<> ::flyteidl::core::LabelValue* Arena::CreateMaybeMessage<::flyteidl::core::LabelValue>(Arena*);
template<> ::flyteidl::core::Partitions* Arena::CreateMaybeMessage<::flyteidl::core::Partitions>(Arena*);
template<> ::flyteidl::core::Partitions_ValueEntry_DoNotUse* Arena::CreateMaybeMessage<::flyteidl::core::Partitions_ValueEntry_DoNotUse>(Arena*);
template<> ::flyteidl::core::TimePartition* Arena::CreateMaybeMessage<::flyteidl::core::TimePartition>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace flyteidl {
namespace core {

// ===================================================================

class ArtifactKey final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.ArtifactKey) */ {
 public:
  ArtifactKey();
  virtual ~ArtifactKey();

  ArtifactKey(const ArtifactKey& from);

  inline ArtifactKey& operator=(const ArtifactKey& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ArtifactKey(ArtifactKey&& from) noexcept
    : ArtifactKey() {
    *this = ::std::move(from);
  }

  inline ArtifactKey& operator=(ArtifactKey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ArtifactKey& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ArtifactKey* internal_default_instance() {
    return reinterpret_cast<const ArtifactKey*>(
               &_ArtifactKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(ArtifactKey* other);
  friend void swap(ArtifactKey& a, ArtifactKey& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ArtifactKey* New() const final {
    return CreateMaybeMessage<ArtifactKey>(nullptr);
  }

  ArtifactKey* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ArtifactKey>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ArtifactKey& from);
  void MergeFrom(const ArtifactKey& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArtifactKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string project = 1;
  void clear_project();
  static const int kProjectFieldNumber = 1;
  const ::std::string& project() const;
  void set_project(const ::std::string& value);
  #if LANG_CXX11
  void set_project(::std::string&& value);
  #endif
  void set_project(const char* value);
  void set_project(const char* value, size_t size);
  ::std::string* mutable_project();
  ::std::string* release_project();
  void set_allocated_project(::std::string* project);

  // string domain = 2;
  void clear_domain();
  static const int kDomainFieldNumber = 2;
  const ::std::string& domain() const;
  void set_domain(const ::std::string& value);
  #if LANG_CXX11
  void set_domain(::std::string&& value);
  #endif
  void set_domain(const char* value);
  void set_domain(const char* value, size_t size);
  ::std::string* mutable_domain();
  ::std::string* release_domain();
  void set_allocated_domain(::std::string* domain);

  // string name = 3;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:flyteidl.core.ArtifactKey)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr project_;
  ::google::protobuf::internal::ArenaStringPtr domain_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2fartifact_5fid_2eproto;
};
// -------------------------------------------------------------------

class ArtifactBindingData final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.ArtifactBindingData) */ {
 public:
  ArtifactBindingData();
  virtual ~ArtifactBindingData();

  ArtifactBindingData(const ArtifactBindingData& from);

  inline ArtifactBindingData& operator=(const ArtifactBindingData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ArtifactBindingData(ArtifactBindingData&& from) noexcept
    : ArtifactBindingData() {
    *this = ::std::move(from);
  }

  inline ArtifactBindingData& operator=(ArtifactBindingData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ArtifactBindingData& default_instance();

  enum PartitionDataCase {
    kPartitionKey = 2,
    kBindToTimePartition = 3,
    PARTITION_DATA_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ArtifactBindingData* internal_default_instance() {
    return reinterpret_cast<const ArtifactBindingData*>(
               &_ArtifactBindingData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(ArtifactBindingData* other);
  friend void swap(ArtifactBindingData& a, ArtifactBindingData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ArtifactBindingData* New() const final {
    return CreateMaybeMessage<ArtifactBindingData>(nullptr);
  }

  ArtifactBindingData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ArtifactBindingData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ArtifactBindingData& from);
  void MergeFrom(const ArtifactBindingData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArtifactBindingData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string transform = 4;
  void clear_transform();
  static const int kTransformFieldNumber = 4;
  const ::std::string& transform() const;
  void set_transform(const ::std::string& value);
  #if LANG_CXX11
  void set_transform(::std::string&& value);
  #endif
  void set_transform(const char* value);
  void set_transform(const char* value, size_t size);
  ::std::string* mutable_transform();
  ::std::string* release_transform();
  void set_allocated_transform(::std::string* transform);

  // uint32 index = 1;
  void clear_index();
  static const int kIndexFieldNumber = 1;
  ::google::protobuf::uint32 index() const;
  void set_index(::google::protobuf::uint32 value);

  // string partition_key = 2;
  private:
  bool has_partition_key() const;
  public:
  void clear_partition_key();
  static const int kPartitionKeyFieldNumber = 2;
  const ::std::string& partition_key() const;
  void set_partition_key(const ::std::string& value);
  #if LANG_CXX11
  void set_partition_key(::std::string&& value);
  #endif
  void set_partition_key(const char* value);
  void set_partition_key(const char* value, size_t size);
  ::std::string* mutable_partition_key();
  ::std::string* release_partition_key();
  void set_allocated_partition_key(::std::string* partition_key);

  // bool bind_to_time_partition = 3;
  private:
  bool has_bind_to_time_partition() const;
  public:
  void clear_bind_to_time_partition();
  static const int kBindToTimePartitionFieldNumber = 3;
  bool bind_to_time_partition() const;
  void set_bind_to_time_partition(bool value);

  void clear_partition_data();
  PartitionDataCase partition_data_case() const;
  // @@protoc_insertion_point(class_scope:flyteidl.core.ArtifactBindingData)
 private:
  class HasBitSetters;
  void set_has_partition_key();
  void set_has_bind_to_time_partition();

  inline bool has_partition_data() const;
  inline void clear_has_partition_data();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr transform_;
  ::google::protobuf::uint32 index_;
  union PartitionDataUnion {
    PartitionDataUnion() {}
    ::google::protobuf::internal::ArenaStringPtr partition_key_;
    bool bind_to_time_partition_;
  } partition_data_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_flyteidl_2fcore_2fartifact_5fid_2eproto;
};
// -------------------------------------------------------------------

class InputBindingData final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.InputBindingData) */ {
 public:
  InputBindingData();
  virtual ~InputBindingData();

  InputBindingData(const InputBindingData& from);

  inline InputBindingData& operator=(const InputBindingData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InputBindingData(InputBindingData&& from) noexcept
    : InputBindingData() {
    *this = ::std::move(from);
  }

  inline InputBindingData& operator=(InputBindingData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const InputBindingData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InputBindingData* internal_default_instance() {
    return reinterpret_cast<const InputBindingData*>(
               &_InputBindingData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(InputBindingData* other);
  friend void swap(InputBindingData& a, InputBindingData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InputBindingData* New() const final {
    return CreateMaybeMessage<InputBindingData>(nullptr);
  }

  InputBindingData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<InputBindingData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const InputBindingData& from);
  void MergeFrom(const InputBindingData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InputBindingData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string var = 1;
  void clear_var();
  static const int kVarFieldNumber = 1;
  const ::std::string& var() const;
  void set_var(const ::std::string& value);
  #if LANG_CXX11
  void set_var(::std::string&& value);
  #endif
  void set_var(const char* value);
  void set_var(const char* value, size_t size);
  ::std::string* mutable_var();
  ::std::string* release_var();
  void set_allocated_var(::std::string* var);

  // @@protoc_insertion_point(class_scope:flyteidl.core.InputBindingData)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr var_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2fartifact_5fid_2eproto;
};
// -------------------------------------------------------------------

class LabelValue final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.LabelValue) */ {
 public:
  LabelValue();
  virtual ~LabelValue();

  LabelValue(const LabelValue& from);

  inline LabelValue& operator=(const LabelValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LabelValue(LabelValue&& from) noexcept
    : LabelValue() {
    *this = ::std::move(from);
  }

  inline LabelValue& operator=(LabelValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const LabelValue& default_instance();

  enum ValueCase {
    kStaticValue = 1,
    kTimeValue = 2,
    kTriggeredBinding = 3,
    kInputBinding = 4,
    VALUE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LabelValue* internal_default_instance() {
    return reinterpret_cast<const LabelValue*>(
               &_LabelValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(LabelValue* other);
  friend void swap(LabelValue& a, LabelValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LabelValue* New() const final {
    return CreateMaybeMessage<LabelValue>(nullptr);
  }

  LabelValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LabelValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LabelValue& from);
  void MergeFrom(const LabelValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LabelValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string static_value = 1;
  private:
  bool has_static_value() const;
  public:
  void clear_static_value();
  static const int kStaticValueFieldNumber = 1;
  const ::std::string& static_value() const;
  void set_static_value(const ::std::string& value);
  #if LANG_CXX11
  void set_static_value(::std::string&& value);
  #endif
  void set_static_value(const char* value);
  void set_static_value(const char* value, size_t size);
  ::std::string* mutable_static_value();
  ::std::string* release_static_value();
  void set_allocated_static_value(::std::string* static_value);

  // .google.protobuf.Timestamp time_value = 2;
  bool has_time_value() const;
  void clear_time_value();
  static const int kTimeValueFieldNumber = 2;
  const ::google::protobuf::Timestamp& time_value() const;
  ::google::protobuf::Timestamp* release_time_value();
  ::google::protobuf::Timestamp* mutable_time_value();
  void set_allocated_time_value(::google::protobuf::Timestamp* time_value);

  // .flyteidl.core.ArtifactBindingData triggered_binding = 3;
  bool has_triggered_binding() const;
  void clear_triggered_binding();
  static const int kTriggeredBindingFieldNumber = 3;
  const ::flyteidl::core::ArtifactBindingData& triggered_binding() const;
  ::flyteidl::core::ArtifactBindingData* release_triggered_binding();
  ::flyteidl::core::ArtifactBindingData* mutable_triggered_binding();
  void set_allocated_triggered_binding(::flyteidl::core::ArtifactBindingData* triggered_binding);

  // .flyteidl.core.InputBindingData input_binding = 4;
  bool has_input_binding() const;
  void clear_input_binding();
  static const int kInputBindingFieldNumber = 4;
  const ::flyteidl::core::InputBindingData& input_binding() const;
  ::flyteidl::core::InputBindingData* release_input_binding();
  ::flyteidl::core::InputBindingData* mutable_input_binding();
  void set_allocated_input_binding(::flyteidl::core::InputBindingData* input_binding);

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:flyteidl.core.LabelValue)
 private:
  class HasBitSetters;
  void set_has_static_value();
  void set_has_time_value();
  void set_has_triggered_binding();
  void set_has_input_binding();

  inline bool has_value() const;
  inline void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union ValueUnion {
    ValueUnion() {}
    ::google::protobuf::internal::ArenaStringPtr static_value_;
    ::google::protobuf::Timestamp* time_value_;
    ::flyteidl::core::ArtifactBindingData* triggered_binding_;
    ::flyteidl::core::InputBindingData* input_binding_;
  } value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_flyteidl_2fcore_2fartifact_5fid_2eproto;
};
// -------------------------------------------------------------------

class Partitions_ValueEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<Partitions_ValueEntry_DoNotUse, 
    ::std::string, ::flyteidl::core::LabelValue,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
static bool _ParseMap(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  typedef ::google::protobuf::internal::MapEntry<Partitions_ValueEntry_DoNotUse, 
    ::std::string, ::flyteidl::core::LabelValue,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  Partitions_ValueEntry_DoNotUse();
  Partitions_ValueEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const Partitions_ValueEntry_DoNotUse& other);
  static const Partitions_ValueEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Partitions_ValueEntry_DoNotUse*>(&_Partitions_ValueEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class Partitions final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.Partitions) */ {
 public:
  Partitions();
  virtual ~Partitions();

  Partitions(const Partitions& from);

  inline Partitions& operator=(const Partitions& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Partitions(Partitions&& from) noexcept
    : Partitions() {
    *this = ::std::move(from);
  }

  inline Partitions& operator=(Partitions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Partitions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Partitions* internal_default_instance() {
    return reinterpret_cast<const Partitions*>(
               &_Partitions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Partitions* other);
  friend void swap(Partitions& a, Partitions& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Partitions* New() const final {
    return CreateMaybeMessage<Partitions>(nullptr);
  }

  Partitions* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Partitions>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Partitions& from);
  void MergeFrom(const Partitions& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Partitions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, .flyteidl.core.LabelValue> value = 1;
  int value_size() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::google::protobuf::Map< ::std::string, ::flyteidl::core::LabelValue >&
      value() const;
  ::google::protobuf::Map< ::std::string, ::flyteidl::core::LabelValue >*
      mutable_value();

  // @@protoc_insertion_point(class_scope:flyteidl.core.Partitions)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      Partitions_ValueEntry_DoNotUse,
      ::std::string, ::flyteidl::core::LabelValue,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2fartifact_5fid_2eproto;
};
// -------------------------------------------------------------------

class TimePartition final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.TimePartition) */ {
 public:
  TimePartition();
  virtual ~TimePartition();

  TimePartition(const TimePartition& from);

  inline TimePartition& operator=(const TimePartition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TimePartition(TimePartition&& from) noexcept
    : TimePartition() {
    *this = ::std::move(from);
  }

  inline TimePartition& operator=(TimePartition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TimePartition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TimePartition* internal_default_instance() {
    return reinterpret_cast<const TimePartition*>(
               &_TimePartition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(TimePartition* other);
  friend void swap(TimePartition& a, TimePartition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TimePartition* New() const final {
    return CreateMaybeMessage<TimePartition>(nullptr);
  }

  TimePartition* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TimePartition>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TimePartition& from);
  void MergeFrom(const TimePartition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TimePartition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .flyteidl.core.LabelValue value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::flyteidl::core::LabelValue& value() const;
  ::flyteidl::core::LabelValue* release_value();
  ::flyteidl::core::LabelValue* mutable_value();
  void set_allocated_value(::flyteidl::core::LabelValue* value);

  // @@protoc_insertion_point(class_scope:flyteidl.core.TimePartition)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::flyteidl::core::LabelValue* value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2fartifact_5fid_2eproto;
};
// -------------------------------------------------------------------

class ArtifactID final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.ArtifactID) */ {
 public:
  ArtifactID();
  virtual ~ArtifactID();

  ArtifactID(const ArtifactID& from);

  inline ArtifactID& operator=(const ArtifactID& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ArtifactID(ArtifactID&& from) noexcept
    : ArtifactID() {
    *this = ::std::move(from);
  }

  inline ArtifactID& operator=(ArtifactID&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ArtifactID& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ArtifactID* internal_default_instance() {
    return reinterpret_cast<const ArtifactID*>(
               &_ArtifactID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(ArtifactID* other);
  friend void swap(ArtifactID& a, ArtifactID& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ArtifactID* New() const final {
    return CreateMaybeMessage<ArtifactID>(nullptr);
  }

  ArtifactID* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ArtifactID>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ArtifactID& from);
  void MergeFrom(const ArtifactID& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArtifactID* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string version = 2;
  void clear_version();
  static const int kVersionFieldNumber = 2;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // .flyteidl.core.ArtifactKey artifact_key = 1;
  bool has_artifact_key() const;
  void clear_artifact_key();
  static const int kArtifactKeyFieldNumber = 1;
  const ::flyteidl::core::ArtifactKey& artifact_key() const;
  ::flyteidl::core::ArtifactKey* release_artifact_key();
  ::flyteidl::core::ArtifactKey* mutable_artifact_key();
  void set_allocated_artifact_key(::flyteidl::core::ArtifactKey* artifact_key);

  // .flyteidl.core.Partitions partitions = 3;
  bool has_partitions() const;
  void clear_partitions();
  static const int kPartitionsFieldNumber = 3;
  const ::flyteidl::core::Partitions& partitions() const;
  ::flyteidl::core::Partitions* release_partitions();
  ::flyteidl::core::Partitions* mutable_partitions();
  void set_allocated_partitions(::flyteidl::core::Partitions* partitions);

  // .flyteidl.core.TimePartition time_partition = 4;
  bool has_time_partition() const;
  void clear_time_partition();
  static const int kTimePartitionFieldNumber = 4;
  const ::flyteidl::core::TimePartition& time_partition() const;
  ::flyteidl::core::TimePartition* release_time_partition();
  ::flyteidl::core::TimePartition* mutable_time_partition();
  void set_allocated_time_partition(::flyteidl::core::TimePartition* time_partition);

  // @@protoc_insertion_point(class_scope:flyteidl.core.ArtifactID)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::flyteidl::core::ArtifactKey* artifact_key_;
  ::flyteidl::core::Partitions* partitions_;
  ::flyteidl::core::TimePartition* time_partition_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2fartifact_5fid_2eproto;
};
// -------------------------------------------------------------------

class ArtifactTag final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.ArtifactTag) */ {
 public:
  ArtifactTag();
  virtual ~ArtifactTag();

  ArtifactTag(const ArtifactTag& from);

  inline ArtifactTag& operator=(const ArtifactTag& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ArtifactTag(ArtifactTag&& from) noexcept
    : ArtifactTag() {
    *this = ::std::move(from);
  }

  inline ArtifactTag& operator=(ArtifactTag&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ArtifactTag& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ArtifactTag* internal_default_instance() {
    return reinterpret_cast<const ArtifactTag*>(
               &_ArtifactTag_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(ArtifactTag* other);
  friend void swap(ArtifactTag& a, ArtifactTag& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ArtifactTag* New() const final {
    return CreateMaybeMessage<ArtifactTag>(nullptr);
  }

  ArtifactTag* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ArtifactTag>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ArtifactTag& from);
  void MergeFrom(const ArtifactTag& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArtifactTag* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .flyteidl.core.ArtifactKey artifact_key = 1;
  bool has_artifact_key() const;
  void clear_artifact_key();
  static const int kArtifactKeyFieldNumber = 1;
  const ::flyteidl::core::ArtifactKey& artifact_key() const;
  ::flyteidl::core::ArtifactKey* release_artifact_key();
  ::flyteidl::core::ArtifactKey* mutable_artifact_key();
  void set_allocated_artifact_key(::flyteidl::core::ArtifactKey* artifact_key);

  // .flyteidl.core.LabelValue value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::flyteidl::core::LabelValue& value() const;
  ::flyteidl::core::LabelValue* release_value();
  ::flyteidl::core::LabelValue* mutable_value();
  void set_allocated_value(::flyteidl::core::LabelValue* value);

  // @@protoc_insertion_point(class_scope:flyteidl.core.ArtifactTag)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::flyteidl::core::ArtifactKey* artifact_key_;
  ::flyteidl::core::LabelValue* value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fcore_2fartifact_5fid_2eproto;
};
// -------------------------------------------------------------------

class ArtifactQuery final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.core.ArtifactQuery) */ {
 public:
  ArtifactQuery();
  virtual ~ArtifactQuery();

  ArtifactQuery(const ArtifactQuery& from);

  inline ArtifactQuery& operator=(const ArtifactQuery& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ArtifactQuery(ArtifactQuery&& from) noexcept
    : ArtifactQuery() {
    *this = ::std::move(from);
  }

  inline ArtifactQuery& operator=(ArtifactQuery&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ArtifactQuery& default_instance();

  enum IdentifierCase {
    kArtifactId = 1,
    kArtifactTag = 2,
    kUri = 3,
    kBinding = 4,
    IDENTIFIER_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ArtifactQuery* internal_default_instance() {
    return reinterpret_cast<const ArtifactQuery*>(
               &_ArtifactQuery_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(ArtifactQuery* other);
  friend void swap(ArtifactQuery& a, ArtifactQuery& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ArtifactQuery* New() const final {
    return CreateMaybeMessage<ArtifactQuery>(nullptr);
  }

  ArtifactQuery* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ArtifactQuery>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ArtifactQuery& from);
  void MergeFrom(const ArtifactQuery& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArtifactQuery* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .flyteidl.core.ArtifactID artifact_id = 1;
  bool has_artifact_id() const;
  void clear_artifact_id();
  static const int kArtifactIdFieldNumber = 1;
  const ::flyteidl::core::ArtifactID& artifact_id() const;
  ::flyteidl::core::ArtifactID* release_artifact_id();
  ::flyteidl::core::ArtifactID* mutable_artifact_id();
  void set_allocated_artifact_id(::flyteidl::core::ArtifactID* artifact_id);

  // .flyteidl.core.ArtifactTag artifact_tag = 2;
  bool has_artifact_tag() const;
  void clear_artifact_tag();
  static const int kArtifactTagFieldNumber = 2;
  const ::flyteidl::core::ArtifactTag& artifact_tag() const;
  ::flyteidl::core::ArtifactTag* release_artifact_tag();
  ::flyteidl::core::ArtifactTag* mutable_artifact_tag();
  void set_allocated_artifact_tag(::flyteidl::core::ArtifactTag* artifact_tag);

  // string uri = 3;
  private:
  bool has_uri() const;
  public:
  void clear_uri();
  static const int kUriFieldNumber = 3;
  const ::std::string& uri() const;
  void set_uri(const ::std::string& value);
  #if LANG_CXX11
  void set_uri(::std::string&& value);
  #endif
  void set_uri(const char* value);
  void set_uri(const char* value, size_t size);
  ::std::string* mutable_uri();
  ::std::string* release_uri();
  void set_allocated_uri(::std::string* uri);

  // .flyteidl.core.ArtifactBindingData binding = 4;
  bool has_binding() const;
  void clear_binding();
  static const int kBindingFieldNumber = 4;
  const ::flyteidl::core::ArtifactBindingData& binding() const;
  ::flyteidl::core::ArtifactBindingData* release_binding();
  ::flyteidl::core::ArtifactBindingData* mutable_binding();
  void set_allocated_binding(::flyteidl::core::ArtifactBindingData* binding);

  void clear_identifier();
  IdentifierCase identifier_case() const;
  // @@protoc_insertion_point(class_scope:flyteidl.core.ArtifactQuery)
 private:
  class HasBitSetters;
  void set_has_artifact_id();
  void set_has_artifact_tag();
  void set_has_uri();
  void set_has_binding();

  inline bool has_identifier() const;
  inline void clear_has_identifier();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union IdentifierUnion {
    IdentifierUnion() {}
    ::flyteidl::core::ArtifactID* artifact_id_;
    ::flyteidl::core::ArtifactTag* artifact_tag_;
    ::google::protobuf::internal::ArenaStringPtr uri_;
    ::flyteidl::core::ArtifactBindingData* binding_;
  } identifier_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_flyteidl_2fcore_2fartifact_5fid_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ArtifactKey

// string project = 1;
inline void ArtifactKey::clear_project() {
  project_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ArtifactKey::project() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.ArtifactKey.project)
  return project_.GetNoArena();
}
inline void ArtifactKey::set_project(const ::std::string& value) {
  
  project_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.ArtifactKey.project)
}
#if LANG_CXX11
inline void ArtifactKey::set_project(::std::string&& value) {
  
  project_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.ArtifactKey.project)
}
#endif
inline void ArtifactKey::set_project(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  project_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.ArtifactKey.project)
}
inline void ArtifactKey::set_project(const char* value, size_t size) {
  
  project_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.ArtifactKey.project)
}
inline ::std::string* ArtifactKey::mutable_project() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.ArtifactKey.project)
  return project_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ArtifactKey::release_project() {
  // @@protoc_insertion_point(field_release:flyteidl.core.ArtifactKey.project)
  
  return project_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ArtifactKey::set_allocated_project(::std::string* project) {
  if (project != nullptr) {
    
  } else {
    
  }
  project_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), project);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.ArtifactKey.project)
}

// string domain = 2;
inline void ArtifactKey::clear_domain() {
  domain_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ArtifactKey::domain() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.ArtifactKey.domain)
  return domain_.GetNoArena();
}
inline void ArtifactKey::set_domain(const ::std::string& value) {
  
  domain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.ArtifactKey.domain)
}
#if LANG_CXX11
inline void ArtifactKey::set_domain(::std::string&& value) {
  
  domain_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.ArtifactKey.domain)
}
#endif
inline void ArtifactKey::set_domain(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  domain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.ArtifactKey.domain)
}
inline void ArtifactKey::set_domain(const char* value, size_t size) {
  
  domain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.ArtifactKey.domain)
}
inline ::std::string* ArtifactKey::mutable_domain() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.ArtifactKey.domain)
  return domain_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ArtifactKey::release_domain() {
  // @@protoc_insertion_point(field_release:flyteidl.core.ArtifactKey.domain)
  
  return domain_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ArtifactKey::set_allocated_domain(::std::string* domain) {
  if (domain != nullptr) {
    
  } else {
    
  }
  domain_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), domain);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.ArtifactKey.domain)
}

// string name = 3;
inline void ArtifactKey::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ArtifactKey::name() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.ArtifactKey.name)
  return name_.GetNoArena();
}
inline void ArtifactKey::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.ArtifactKey.name)
}
#if LANG_CXX11
inline void ArtifactKey::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.ArtifactKey.name)
}
#endif
inline void ArtifactKey::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.ArtifactKey.name)
}
inline void ArtifactKey::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.ArtifactKey.name)
}
inline ::std::string* ArtifactKey::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.ArtifactKey.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ArtifactKey::release_name() {
  // @@protoc_insertion_point(field_release:flyteidl.core.ArtifactKey.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ArtifactKey::set_allocated_name(::std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.ArtifactKey.name)
}

// -------------------------------------------------------------------

// ArtifactBindingData

// uint32 index = 1;
inline void ArtifactBindingData::clear_index() {
  index_ = 0u;
}
inline ::google::protobuf::uint32 ArtifactBindingData::index() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.ArtifactBindingData.index)
  return index_;
}
inline void ArtifactBindingData::set_index(::google::protobuf::uint32 value) {
  
  index_ = value;
  // @@protoc_insertion_point(field_set:flyteidl.core.ArtifactBindingData.index)
}

// string partition_key = 2;
inline bool ArtifactBindingData::has_partition_key() const {
  return partition_data_case() == kPartitionKey;
}
inline void ArtifactBindingData::set_has_partition_key() {
  _oneof_case_[0] = kPartitionKey;
}
inline void ArtifactBindingData::clear_partition_key() {
  if (has_partition_key()) {
    partition_data_.partition_key_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_partition_data();
  }
}
inline const ::std::string& ArtifactBindingData::partition_key() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.ArtifactBindingData.partition_key)
  if (has_partition_key()) {
    return partition_data_.partition_key_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void ArtifactBindingData::set_partition_key(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:flyteidl.core.ArtifactBindingData.partition_key)
  if (!has_partition_key()) {
    clear_partition_data();
    set_has_partition_key();
    partition_data_.partition_key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  partition_data_.partition_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.ArtifactBindingData.partition_key)
}
#if LANG_CXX11
inline void ArtifactBindingData::set_partition_key(::std::string&& value) {
  // @@protoc_insertion_point(field_set:flyteidl.core.ArtifactBindingData.partition_key)
  if (!has_partition_key()) {
    clear_partition_data();
    set_has_partition_key();
    partition_data_.partition_key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  partition_data_.partition_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.ArtifactBindingData.partition_key)
}
#endif
inline void ArtifactBindingData::set_partition_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!has_partition_key()) {
    clear_partition_data();
    set_has_partition_key();
    partition_data_.partition_key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  partition_data_.partition_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.ArtifactBindingData.partition_key)
}
inline void ArtifactBindingData::set_partition_key(const char* value, size_t size) {
  if (!has_partition_key()) {
    clear_partition_data();
    set_has_partition_key();
    partition_data_.partition_key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  partition_data_.partition_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.ArtifactBindingData.partition_key)
}
inline ::std::string* ArtifactBindingData::mutable_partition_key() {
  if (!has_partition_key()) {
    clear_partition_data();
    set_has_partition_key();
    partition_data_.partition_key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.ArtifactBindingData.partition_key)
  return partition_data_.partition_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ArtifactBindingData::release_partition_key() {
  // @@protoc_insertion_point(field_release:flyteidl.core.ArtifactBindingData.partition_key)
  if (has_partition_key()) {
    clear_has_partition_data();
    return partition_data_.partition_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return nullptr;
  }
}
inline void ArtifactBindingData::set_allocated_partition_key(::std::string* partition_key) {
  if (has_partition_data()) {
    clear_partition_data();
  }
  if (partition_key != nullptr) {
    set_has_partition_key();
    partition_data_.partition_key_.UnsafeSetDefault(partition_key);
  }
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.ArtifactBindingData.partition_key)
}

// bool bind_to_time_partition = 3;
inline bool ArtifactBindingData::has_bind_to_time_partition() const {
  return partition_data_case() == kBindToTimePartition;
}
inline void ArtifactBindingData::set_has_bind_to_time_partition() {
  _oneof_case_[0] = kBindToTimePartition;
}
inline void ArtifactBindingData::clear_bind_to_time_partition() {
  if (has_bind_to_time_partition()) {
    partition_data_.bind_to_time_partition_ = false;
    clear_has_partition_data();
  }
}
inline bool ArtifactBindingData::bind_to_time_partition() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.ArtifactBindingData.bind_to_time_partition)
  if (has_bind_to_time_partition()) {
    return partition_data_.bind_to_time_partition_;
  }
  return false;
}
inline void ArtifactBindingData::set_bind_to_time_partition(bool value) {
  if (!has_bind_to_time_partition()) {
    clear_partition_data();
    set_has_bind_to_time_partition();
  }
  partition_data_.bind_to_time_partition_ = value;
  // @@protoc_insertion_point(field_set:flyteidl.core.ArtifactBindingData.bind_to_time_partition)
}

// string transform = 4;
inline void ArtifactBindingData::clear_transform() {
  transform_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ArtifactBindingData::transform() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.ArtifactBindingData.transform)
  return transform_.GetNoArena();
}
inline void ArtifactBindingData::set_transform(const ::std::string& value) {
  
  transform_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.ArtifactBindingData.transform)
}
#if LANG_CXX11
inline void ArtifactBindingData::set_transform(::std::string&& value) {
  
  transform_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.ArtifactBindingData.transform)
}
#endif
inline void ArtifactBindingData::set_transform(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  transform_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.ArtifactBindingData.transform)
}
inline void ArtifactBindingData::set_transform(const char* value, size_t size) {
  
  transform_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.ArtifactBindingData.transform)
}
inline ::std::string* ArtifactBindingData::mutable_transform() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.ArtifactBindingData.transform)
  return transform_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ArtifactBindingData::release_transform() {
  // @@protoc_insertion_point(field_release:flyteidl.core.ArtifactBindingData.transform)
  
  return transform_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ArtifactBindingData::set_allocated_transform(::std::string* transform) {
  if (transform != nullptr) {
    
  } else {
    
  }
  transform_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), transform);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.ArtifactBindingData.transform)
}

inline bool ArtifactBindingData::has_partition_data() const {
  return partition_data_case() != PARTITION_DATA_NOT_SET;
}
inline void ArtifactBindingData::clear_has_partition_data() {
  _oneof_case_[0] = PARTITION_DATA_NOT_SET;
}
inline ArtifactBindingData::PartitionDataCase ArtifactBindingData::partition_data_case() const {
  return ArtifactBindingData::PartitionDataCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// InputBindingData

// string var = 1;
inline void InputBindingData::clear_var() {
  var_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& InputBindingData::var() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.InputBindingData.var)
  return var_.GetNoArena();
}
inline void InputBindingData::set_var(const ::std::string& value) {
  
  var_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.InputBindingData.var)
}
#if LANG_CXX11
inline void InputBindingData::set_var(::std::string&& value) {
  
  var_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.InputBindingData.var)
}
#endif
inline void InputBindingData::set_var(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  var_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.InputBindingData.var)
}
inline void InputBindingData::set_var(const char* value, size_t size) {
  
  var_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.InputBindingData.var)
}
inline ::std::string* InputBindingData::mutable_var() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.InputBindingData.var)
  return var_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* InputBindingData::release_var() {
  // @@protoc_insertion_point(field_release:flyteidl.core.InputBindingData.var)
  
  return var_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void InputBindingData::set_allocated_var(::std::string* var) {
  if (var != nullptr) {
    
  } else {
    
  }
  var_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), var);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.InputBindingData.var)
}

// -------------------------------------------------------------------

// LabelValue

// string static_value = 1;
inline bool LabelValue::has_static_value() const {
  return value_case() == kStaticValue;
}
inline void LabelValue::set_has_static_value() {
  _oneof_case_[0] = kStaticValue;
}
inline void LabelValue::clear_static_value() {
  if (has_static_value()) {
    value_.static_value_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_value();
  }
}
inline const ::std::string& LabelValue::static_value() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.LabelValue.static_value)
  if (has_static_value()) {
    return value_.static_value_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void LabelValue::set_static_value(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:flyteidl.core.LabelValue.static_value)
  if (!has_static_value()) {
    clear_value();
    set_has_static_value();
    value_.static_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.static_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.LabelValue.static_value)
}
#if LANG_CXX11
inline void LabelValue::set_static_value(::std::string&& value) {
  // @@protoc_insertion_point(field_set:flyteidl.core.LabelValue.static_value)
  if (!has_static_value()) {
    clear_value();
    set_has_static_value();
    value_.static_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.static_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.LabelValue.static_value)
}
#endif
inline void LabelValue::set_static_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!has_static_value()) {
    clear_value();
    set_has_static_value();
    value_.static_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.static_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.LabelValue.static_value)
}
inline void LabelValue::set_static_value(const char* value, size_t size) {
  if (!has_static_value()) {
    clear_value();
    set_has_static_value();
    value_.static_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  value_.static_value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.LabelValue.static_value)
}
inline ::std::string* LabelValue::mutable_static_value() {
  if (!has_static_value()) {
    clear_value();
    set_has_static_value();
    value_.static_value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.LabelValue.static_value)
  return value_.static_value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LabelValue::release_static_value() {
  // @@protoc_insertion_point(field_release:flyteidl.core.LabelValue.static_value)
  if (has_static_value()) {
    clear_has_value();
    return value_.static_value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return nullptr;
  }
}
inline void LabelValue::set_allocated_static_value(::std::string* static_value) {
  if (has_value()) {
    clear_value();
  }
  if (static_value != nullptr) {
    set_has_static_value();
    value_.static_value_.UnsafeSetDefault(static_value);
  }
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.LabelValue.static_value)
}

// .google.protobuf.Timestamp time_value = 2;
inline bool LabelValue::has_time_value() const {
  return value_case() == kTimeValue;
}
inline void LabelValue::set_has_time_value() {
  _oneof_case_[0] = kTimeValue;
}
inline ::google::protobuf::Timestamp* LabelValue::release_time_value() {
  // @@protoc_insertion_point(field_release:flyteidl.core.LabelValue.time_value)
  if (has_time_value()) {
    clear_has_value();
      ::google::protobuf::Timestamp* temp = value_.time_value_;
    value_.time_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::google::protobuf::Timestamp& LabelValue::time_value() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.LabelValue.time_value)
  return has_time_value()
      ? *value_.time_value_
      : *reinterpret_cast< ::google::protobuf::Timestamp*>(&::google::protobuf::_Timestamp_default_instance_);
}
inline ::google::protobuf::Timestamp* LabelValue::mutable_time_value() {
  if (!has_time_value()) {
    clear_value();
    set_has_time_value();
    value_.time_value_ = CreateMaybeMessage< ::google::protobuf::Timestamp >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.LabelValue.time_value)
  return value_.time_value_;
}

// .flyteidl.core.ArtifactBindingData triggered_binding = 3;
inline bool LabelValue::has_triggered_binding() const {
  return value_case() == kTriggeredBinding;
}
inline void LabelValue::set_has_triggered_binding() {
  _oneof_case_[0] = kTriggeredBinding;
}
inline void LabelValue::clear_triggered_binding() {
  if (has_triggered_binding()) {
    delete value_.triggered_binding_;
    clear_has_value();
  }
}
inline ::flyteidl::core::ArtifactBindingData* LabelValue::release_triggered_binding() {
  // @@protoc_insertion_point(field_release:flyteidl.core.LabelValue.triggered_binding)
  if (has_triggered_binding()) {
    clear_has_value();
      ::flyteidl::core::ArtifactBindingData* temp = value_.triggered_binding_;
    value_.triggered_binding_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::ArtifactBindingData& LabelValue::triggered_binding() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.LabelValue.triggered_binding)
  return has_triggered_binding()
      ? *value_.triggered_binding_
      : *reinterpret_cast< ::flyteidl::core::ArtifactBindingData*>(&::flyteidl::core::_ArtifactBindingData_default_instance_);
}
inline ::flyteidl::core::ArtifactBindingData* LabelValue::mutable_triggered_binding() {
  if (!has_triggered_binding()) {
    clear_value();
    set_has_triggered_binding();
    value_.triggered_binding_ = CreateMaybeMessage< ::flyteidl::core::ArtifactBindingData >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.LabelValue.triggered_binding)
  return value_.triggered_binding_;
}

// .flyteidl.core.InputBindingData input_binding = 4;
inline bool LabelValue::has_input_binding() const {
  return value_case() == kInputBinding;
}
inline void LabelValue::set_has_input_binding() {
  _oneof_case_[0] = kInputBinding;
}
inline void LabelValue::clear_input_binding() {
  if (has_input_binding()) {
    delete value_.input_binding_;
    clear_has_value();
  }
}
inline ::flyteidl::core::InputBindingData* LabelValue::release_input_binding() {
  // @@protoc_insertion_point(field_release:flyteidl.core.LabelValue.input_binding)
  if (has_input_binding()) {
    clear_has_value();
      ::flyteidl::core::InputBindingData* temp = value_.input_binding_;
    value_.input_binding_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::InputBindingData& LabelValue::input_binding() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.LabelValue.input_binding)
  return has_input_binding()
      ? *value_.input_binding_
      : *reinterpret_cast< ::flyteidl::core::InputBindingData*>(&::flyteidl::core::_InputBindingData_default_instance_);
}
inline ::flyteidl::core::InputBindingData* LabelValue::mutable_input_binding() {
  if (!has_input_binding()) {
    clear_value();
    set_has_input_binding();
    value_.input_binding_ = CreateMaybeMessage< ::flyteidl::core::InputBindingData >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.LabelValue.input_binding)
  return value_.input_binding_;
}

inline bool LabelValue::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void LabelValue::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline LabelValue::ValueCase LabelValue::value_case() const {
  return LabelValue::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Partitions

// map<string, .flyteidl.core.LabelValue> value = 1;
inline int Partitions::value_size() const {
  return value_.size();
}
inline void Partitions::clear_value() {
  value_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::flyteidl::core::LabelValue >&
Partitions::value() const {
  // @@protoc_insertion_point(field_map:flyteidl.core.Partitions.value)
  return value_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::flyteidl::core::LabelValue >*
Partitions::mutable_value() {
  // @@protoc_insertion_point(field_mutable_map:flyteidl.core.Partitions.value)
  return value_.MutableMap();
}

// -------------------------------------------------------------------

// TimePartition

// .flyteidl.core.LabelValue value = 1;
inline bool TimePartition::has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline void TimePartition::clear_value() {
  if (GetArenaNoVirtual() == nullptr && value_ != nullptr) {
    delete value_;
  }
  value_ = nullptr;
}
inline const ::flyteidl::core::LabelValue& TimePartition::value() const {
  const ::flyteidl::core::LabelValue* p = value_;
  // @@protoc_insertion_point(field_get:flyteidl.core.TimePartition.value)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::LabelValue*>(
      &::flyteidl::core::_LabelValue_default_instance_);
}
inline ::flyteidl::core::LabelValue* TimePartition::release_value() {
  // @@protoc_insertion_point(field_release:flyteidl.core.TimePartition.value)
  
  ::flyteidl::core::LabelValue* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::flyteidl::core::LabelValue* TimePartition::mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::LabelValue>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.TimePartition.value)
  return value_;
}
inline void TimePartition::set_allocated_value(::flyteidl::core::LabelValue* value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete value_;
  }
  if (value) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.TimePartition.value)
}

// -------------------------------------------------------------------

// ArtifactID

// .flyteidl.core.ArtifactKey artifact_key = 1;
inline bool ArtifactID::has_artifact_key() const {
  return this != internal_default_instance() && artifact_key_ != nullptr;
}
inline void ArtifactID::clear_artifact_key() {
  if (GetArenaNoVirtual() == nullptr && artifact_key_ != nullptr) {
    delete artifact_key_;
  }
  artifact_key_ = nullptr;
}
inline const ::flyteidl::core::ArtifactKey& ArtifactID::artifact_key() const {
  const ::flyteidl::core::ArtifactKey* p = artifact_key_;
  // @@protoc_insertion_point(field_get:flyteidl.core.ArtifactID.artifact_key)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::ArtifactKey*>(
      &::flyteidl::core::_ArtifactKey_default_instance_);
}
inline ::flyteidl::core::ArtifactKey* ArtifactID::release_artifact_key() {
  // @@protoc_insertion_point(field_release:flyteidl.core.ArtifactID.artifact_key)
  
  ::flyteidl::core::ArtifactKey* temp = artifact_key_;
  artifact_key_ = nullptr;
  return temp;
}
inline ::flyteidl::core::ArtifactKey* ArtifactID::mutable_artifact_key() {
  
  if (artifact_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::ArtifactKey>(GetArenaNoVirtual());
    artifact_key_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.ArtifactID.artifact_key)
  return artifact_key_;
}
inline void ArtifactID::set_allocated_artifact_key(::flyteidl::core::ArtifactKey* artifact_key) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete artifact_key_;
  }
  if (artifact_key) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      artifact_key = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, artifact_key, submessage_arena);
    }
    
  } else {
    
  }
  artifact_key_ = artifact_key;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.ArtifactID.artifact_key)
}

// string version = 2;
inline void ArtifactID::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ArtifactID::version() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.ArtifactID.version)
  return version_.GetNoArena();
}
inline void ArtifactID::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.ArtifactID.version)
}
#if LANG_CXX11
inline void ArtifactID::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.ArtifactID.version)
}
#endif
inline void ArtifactID::set_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.ArtifactID.version)
}
inline void ArtifactID::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.ArtifactID.version)
}
inline ::std::string* ArtifactID::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.core.ArtifactID.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ArtifactID::release_version() {
  // @@protoc_insertion_point(field_release:flyteidl.core.ArtifactID.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ArtifactID::set_allocated_version(::std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.ArtifactID.version)
}

// .flyteidl.core.Partitions partitions = 3;
inline bool ArtifactID::has_partitions() const {
  return this != internal_default_instance() && partitions_ != nullptr;
}
inline void ArtifactID::clear_partitions() {
  if (GetArenaNoVirtual() == nullptr && partitions_ != nullptr) {
    delete partitions_;
  }
  partitions_ = nullptr;
}
inline const ::flyteidl::core::Partitions& ArtifactID::partitions() const {
  const ::flyteidl::core::Partitions* p = partitions_;
  // @@protoc_insertion_point(field_get:flyteidl.core.ArtifactID.partitions)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::Partitions*>(
      &::flyteidl::core::_Partitions_default_instance_);
}
inline ::flyteidl::core::Partitions* ArtifactID::release_partitions() {
  // @@protoc_insertion_point(field_release:flyteidl.core.ArtifactID.partitions)
  
  ::flyteidl::core::Partitions* temp = partitions_;
  partitions_ = nullptr;
  return temp;
}
inline ::flyteidl::core::Partitions* ArtifactID::mutable_partitions() {
  
  if (partitions_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::Partitions>(GetArenaNoVirtual());
    partitions_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.ArtifactID.partitions)
  return partitions_;
}
inline void ArtifactID::set_allocated_partitions(::flyteidl::core::Partitions* partitions) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete partitions_;
  }
  if (partitions) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      partitions = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, partitions, submessage_arena);
    }
    
  } else {
    
  }
  partitions_ = partitions;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.ArtifactID.partitions)
}

// .flyteidl.core.TimePartition time_partition = 4;
inline bool ArtifactID::has_time_partition() const {
  return this != internal_default_instance() && time_partition_ != nullptr;
}
inline void ArtifactID::clear_time_partition() {
  if (GetArenaNoVirtual() == nullptr && time_partition_ != nullptr) {
    delete time_partition_;
  }
  time_partition_ = nullptr;
}
inline const ::flyteidl::core::TimePartition& ArtifactID::time_partition() const {
  const ::flyteidl::core::TimePartition* p = time_partition_;
  // @@protoc_insertion_point(field_get:flyteidl.core.ArtifactID.time_partition)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::TimePartition*>(
      &::flyteidl::core::_TimePartition_default_instance_);
}
inline ::flyteidl::core::TimePartition* ArtifactID::release_time_partition() {
  // @@protoc_insertion_point(field_release:flyteidl.core.ArtifactID.time_partition)
  
  ::flyteidl::core::TimePartition* temp = time_partition_;
  time_partition_ = nullptr;
  return temp;
}
inline ::flyteidl::core::TimePartition* ArtifactID::mutable_time_partition() {
  
  if (time_partition_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::TimePartition>(GetArenaNoVirtual());
    time_partition_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.ArtifactID.time_partition)
  return time_partition_;
}
inline void ArtifactID::set_allocated_time_partition(::flyteidl::core::TimePartition* time_partition) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete time_partition_;
  }
  if (time_partition) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      time_partition = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, time_partition, submessage_arena);
    }
    
  } else {
    
  }
  time_partition_ = time_partition;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.ArtifactID.time_partition)
}

// -------------------------------------------------------------------

// ArtifactTag

// .flyteidl.core.ArtifactKey artifact_key = 1;
inline bool ArtifactTag::has_artifact_key() const {
  return this != internal_default_instance() && artifact_key_ != nullptr;
}
inline void ArtifactTag::clear_artifact_key() {
  if (GetArenaNoVirtual() == nullptr && artifact_key_ != nullptr) {
    delete artifact_key_;
  }
  artifact_key_ = nullptr;
}
inline const ::flyteidl::core::ArtifactKey& ArtifactTag::artifact_key() const {
  const ::flyteidl::core::ArtifactKey* p = artifact_key_;
  // @@protoc_insertion_point(field_get:flyteidl.core.ArtifactTag.artifact_key)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::ArtifactKey*>(
      &::flyteidl::core::_ArtifactKey_default_instance_);
}
inline ::flyteidl::core::ArtifactKey* ArtifactTag::release_artifact_key() {
  // @@protoc_insertion_point(field_release:flyteidl.core.ArtifactTag.artifact_key)
  
  ::flyteidl::core::ArtifactKey* temp = artifact_key_;
  artifact_key_ = nullptr;
  return temp;
}
inline ::flyteidl::core::ArtifactKey* ArtifactTag::mutable_artifact_key() {
  
  if (artifact_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::ArtifactKey>(GetArenaNoVirtual());
    artifact_key_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.ArtifactTag.artifact_key)
  return artifact_key_;
}
inline void ArtifactTag::set_allocated_artifact_key(::flyteidl::core::ArtifactKey* artifact_key) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete artifact_key_;
  }
  if (artifact_key) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      artifact_key = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, artifact_key, submessage_arena);
    }
    
  } else {
    
  }
  artifact_key_ = artifact_key;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.ArtifactTag.artifact_key)
}

// .flyteidl.core.LabelValue value = 2;
inline bool ArtifactTag::has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline void ArtifactTag::clear_value() {
  if (GetArenaNoVirtual() == nullptr && value_ != nullptr) {
    delete value_;
  }
  value_ = nullptr;
}
inline const ::flyteidl::core::LabelValue& ArtifactTag::value() const {
  const ::flyteidl::core::LabelValue* p = value_;
  // @@protoc_insertion_point(field_get:flyteidl.core.ArtifactTag.value)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::LabelValue*>(
      &::flyteidl::core::_LabelValue_default_instance_);
}
inline ::flyteidl::core::LabelValue* ArtifactTag::release_value() {
  // @@protoc_insertion_point(field_release:flyteidl.core.ArtifactTag.value)
  
  ::flyteidl::core::LabelValue* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::flyteidl::core::LabelValue* ArtifactTag::mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::LabelValue>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.ArtifactTag.value)
  return value_;
}
inline void ArtifactTag::set_allocated_value(::flyteidl::core::LabelValue* value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete value_;
  }
  if (value) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.ArtifactTag.value)
}

// -------------------------------------------------------------------

// ArtifactQuery

// .flyteidl.core.ArtifactID artifact_id = 1;
inline bool ArtifactQuery::has_artifact_id() const {
  return identifier_case() == kArtifactId;
}
inline void ArtifactQuery::set_has_artifact_id() {
  _oneof_case_[0] = kArtifactId;
}
inline void ArtifactQuery::clear_artifact_id() {
  if (has_artifact_id()) {
    delete identifier_.artifact_id_;
    clear_has_identifier();
  }
}
inline ::flyteidl::core::ArtifactID* ArtifactQuery::release_artifact_id() {
  // @@protoc_insertion_point(field_release:flyteidl.core.ArtifactQuery.artifact_id)
  if (has_artifact_id()) {
    clear_has_identifier();
      ::flyteidl::core::ArtifactID* temp = identifier_.artifact_id_;
    identifier_.artifact_id_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::ArtifactID& ArtifactQuery::artifact_id() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.ArtifactQuery.artifact_id)
  return has_artifact_id()
      ? *identifier_.artifact_id_
      : *reinterpret_cast< ::flyteidl::core::ArtifactID*>(&::flyteidl::core::_ArtifactID_default_instance_);
}
inline ::flyteidl::core::ArtifactID* ArtifactQuery::mutable_artifact_id() {
  if (!has_artifact_id()) {
    clear_identifier();
    set_has_artifact_id();
    identifier_.artifact_id_ = CreateMaybeMessage< ::flyteidl::core::ArtifactID >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.ArtifactQuery.artifact_id)
  return identifier_.artifact_id_;
}

// .flyteidl.core.ArtifactTag artifact_tag = 2;
inline bool ArtifactQuery::has_artifact_tag() const {
  return identifier_case() == kArtifactTag;
}
inline void ArtifactQuery::set_has_artifact_tag() {
  _oneof_case_[0] = kArtifactTag;
}
inline void ArtifactQuery::clear_artifact_tag() {
  if (has_artifact_tag()) {
    delete identifier_.artifact_tag_;
    clear_has_identifier();
  }
}
inline ::flyteidl::core::ArtifactTag* ArtifactQuery::release_artifact_tag() {
  // @@protoc_insertion_point(field_release:flyteidl.core.ArtifactQuery.artifact_tag)
  if (has_artifact_tag()) {
    clear_has_identifier();
      ::flyteidl::core::ArtifactTag* temp = identifier_.artifact_tag_;
    identifier_.artifact_tag_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::ArtifactTag& ArtifactQuery::artifact_tag() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.ArtifactQuery.artifact_tag)
  return has_artifact_tag()
      ? *identifier_.artifact_tag_
      : *reinterpret_cast< ::flyteidl::core::ArtifactTag*>(&::flyteidl::core::_ArtifactTag_default_instance_);
}
inline ::flyteidl::core::ArtifactTag* ArtifactQuery::mutable_artifact_tag() {
  if (!has_artifact_tag()) {
    clear_identifier();
    set_has_artifact_tag();
    identifier_.artifact_tag_ = CreateMaybeMessage< ::flyteidl::core::ArtifactTag >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.ArtifactQuery.artifact_tag)
  return identifier_.artifact_tag_;
}

// string uri = 3;
inline bool ArtifactQuery::has_uri() const {
  return identifier_case() == kUri;
}
inline void ArtifactQuery::set_has_uri() {
  _oneof_case_[0] = kUri;
}
inline void ArtifactQuery::clear_uri() {
  if (has_uri()) {
    identifier_.uri_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_identifier();
  }
}
inline const ::std::string& ArtifactQuery::uri() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.ArtifactQuery.uri)
  if (has_uri()) {
    return identifier_.uri_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void ArtifactQuery::set_uri(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:flyteidl.core.ArtifactQuery.uri)
  if (!has_uri()) {
    clear_identifier();
    set_has_uri();
    identifier_.uri_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  identifier_.uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.core.ArtifactQuery.uri)
}
#if LANG_CXX11
inline void ArtifactQuery::set_uri(::std::string&& value) {
  // @@protoc_insertion_point(field_set:flyteidl.core.ArtifactQuery.uri)
  if (!has_uri()) {
    clear_identifier();
    set_has_uri();
    identifier_.uri_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  identifier_.uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.core.ArtifactQuery.uri)
}
#endif
inline void ArtifactQuery::set_uri(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!has_uri()) {
    clear_identifier();
    set_has_uri();
    identifier_.uri_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  identifier_.uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.core.ArtifactQuery.uri)
}
inline void ArtifactQuery::set_uri(const char* value, size_t size) {
  if (!has_uri()) {
    clear_identifier();
    set_has_uri();
    identifier_.uri_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  identifier_.uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.core.ArtifactQuery.uri)
}
inline ::std::string* ArtifactQuery::mutable_uri() {
  if (!has_uri()) {
    clear_identifier();
    set_has_uri();
    identifier_.uri_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.ArtifactQuery.uri)
  return identifier_.uri_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ArtifactQuery::release_uri() {
  // @@protoc_insertion_point(field_release:flyteidl.core.ArtifactQuery.uri)
  if (has_uri()) {
    clear_has_identifier();
    return identifier_.uri_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return nullptr;
  }
}
inline void ArtifactQuery::set_allocated_uri(::std::string* uri) {
  if (has_identifier()) {
    clear_identifier();
  }
  if (uri != nullptr) {
    set_has_uri();
    identifier_.uri_.UnsafeSetDefault(uri);
  }
  // @@protoc_insertion_point(field_set_allocated:flyteidl.core.ArtifactQuery.uri)
}

// .flyteidl.core.ArtifactBindingData binding = 4;
inline bool ArtifactQuery::has_binding() const {
  return identifier_case() == kBinding;
}
inline void ArtifactQuery::set_has_binding() {
  _oneof_case_[0] = kBinding;
}
inline void ArtifactQuery::clear_binding() {
  if (has_binding()) {
    delete identifier_.binding_;
    clear_has_identifier();
  }
}
inline ::flyteidl::core::ArtifactBindingData* ArtifactQuery::release_binding() {
  // @@protoc_insertion_point(field_release:flyteidl.core.ArtifactQuery.binding)
  if (has_binding()) {
    clear_has_identifier();
      ::flyteidl::core::ArtifactBindingData* temp = identifier_.binding_;
    identifier_.binding_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::core::ArtifactBindingData& ArtifactQuery::binding() const {
  // @@protoc_insertion_point(field_get:flyteidl.core.ArtifactQuery.binding)
  return has_binding()
      ? *identifier_.binding_
      : *reinterpret_cast< ::flyteidl::core::ArtifactBindingData*>(&::flyteidl::core::_ArtifactBindingData_default_instance_);
}
inline ::flyteidl::core::ArtifactBindingData* ArtifactQuery::mutable_binding() {
  if (!has_binding()) {
    clear_identifier();
    set_has_binding();
    identifier_.binding_ = CreateMaybeMessage< ::flyteidl::core::ArtifactBindingData >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.core.ArtifactQuery.binding)
  return identifier_.binding_;
}

inline bool ArtifactQuery::has_identifier() const {
  return identifier_case() != IDENTIFIER_NOT_SET;
}
inline void ArtifactQuery::clear_has_identifier() {
  _oneof_case_[0] = IDENTIFIER_NOT_SET;
}
inline ArtifactQuery::IdentifierCase ArtifactQuery::identifier_case() const {
  return ArtifactQuery::IdentifierCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace core
}  // namespace flyteidl

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_flyteidl_2fcore_2fartifact_5fid_2eproto
