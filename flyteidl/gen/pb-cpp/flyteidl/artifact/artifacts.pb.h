// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: flyteidl/artifact/artifacts.proto

#ifndef PROTOBUF_INCLUDED_flyteidl_2fartifact_2fartifacts_2eproto
#define PROTOBUF_INCLUDED_flyteidl_2fartifact_2fartifacts_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/any.pb.h>
#include "google/api/annotations.pb.h"
#include "flyteidl/admin/launch_plan.pb.h"
#include "flyteidl/core/literals.pb.h"
#include "flyteidl/core/types.pb.h"
#include "flyteidl/core/identifier.pb.h"
#include "flyteidl/core/artifact_id.pb.h"
#include "flyteidl/core/interface.pb.h"
#include "flyteidl/event/cloudevents.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_flyteidl_2fartifact_2fartifacts_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_flyteidl_2fartifact_2fartifacts_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[24]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_flyteidl_2fartifact_2fartifacts_2eproto();
namespace flyteidl {
namespace artifact {
class AddTagRequest;
class AddTagRequestDefaultTypeInternal;
extern AddTagRequestDefaultTypeInternal _AddTagRequest_default_instance_;
class AddTagResponse;
class AddTagResponseDefaultTypeInternal;
extern AddTagResponseDefaultTypeInternal _AddTagResponse_default_instance_;
class Artifact;
class ArtifactDefaultTypeInternal;
extern ArtifactDefaultTypeInternal _Artifact_default_instance_;
class ArtifactConsumer;
class ArtifactConsumerDefaultTypeInternal;
extern ArtifactConsumerDefaultTypeInternal _ArtifactConsumer_default_instance_;
class ArtifactProducer;
class ArtifactProducerDefaultTypeInternal;
extern ArtifactProducerDefaultTypeInternal _ArtifactProducer_default_instance_;
class ArtifactSpec;
class ArtifactSpecDefaultTypeInternal;
extern ArtifactSpecDefaultTypeInternal _ArtifactSpec_default_instance_;
class CloudEventRequest;
class CloudEventRequestDefaultTypeInternal;
extern CloudEventRequestDefaultTypeInternal _CloudEventRequest_default_instance_;
class CloudEventResponse;
class CloudEventResponseDefaultTypeInternal;
extern CloudEventResponseDefaultTypeInternal _CloudEventResponse_default_instance_;
class CreateArtifactRequest;
class CreateArtifactRequestDefaultTypeInternal;
extern CreateArtifactRequestDefaultTypeInternal _CreateArtifactRequest_default_instance_;
class CreateArtifactRequest_PartitionsEntry_DoNotUse;
class CreateArtifactRequest_PartitionsEntry_DoNotUseDefaultTypeInternal;
extern CreateArtifactRequest_PartitionsEntry_DoNotUseDefaultTypeInternal _CreateArtifactRequest_PartitionsEntry_DoNotUse_default_instance_;
class CreateArtifactResponse;
class CreateArtifactResponseDefaultTypeInternal;
extern CreateArtifactResponseDefaultTypeInternal _CreateArtifactResponse_default_instance_;
class CreateTriggerRequest;
class CreateTriggerRequestDefaultTypeInternal;
extern CreateTriggerRequestDefaultTypeInternal _CreateTriggerRequest_default_instance_;
class CreateTriggerResponse;
class CreateTriggerResponseDefaultTypeInternal;
extern CreateTriggerResponseDefaultTypeInternal _CreateTriggerResponse_default_instance_;
class DeleteTriggerRequest;
class DeleteTriggerRequestDefaultTypeInternal;
extern DeleteTriggerRequestDefaultTypeInternal _DeleteTriggerRequest_default_instance_;
class DeleteTriggerResponse;
class DeleteTriggerResponseDefaultTypeInternal;
extern DeleteTriggerResponseDefaultTypeInternal _DeleteTriggerResponse_default_instance_;
class GetArtifactRequest;
class GetArtifactRequestDefaultTypeInternal;
extern GetArtifactRequestDefaultTypeInternal _GetArtifactRequest_default_instance_;
class GetArtifactResponse;
class GetArtifactResponseDefaultTypeInternal;
extern GetArtifactResponseDefaultTypeInternal _GetArtifactResponse_default_instance_;
class ListArtifactNamesRequest;
class ListArtifactNamesRequestDefaultTypeInternal;
extern ListArtifactNamesRequestDefaultTypeInternal _ListArtifactNamesRequest_default_instance_;
class ListArtifactNamesResponse;
class ListArtifactNamesResponseDefaultTypeInternal;
extern ListArtifactNamesResponseDefaultTypeInternal _ListArtifactNamesResponse_default_instance_;
class RegisterConsumerRequest;
class RegisterConsumerRequestDefaultTypeInternal;
extern RegisterConsumerRequestDefaultTypeInternal _RegisterConsumerRequest_default_instance_;
class RegisterProducerRequest;
class RegisterProducerRequestDefaultTypeInternal;
extern RegisterProducerRequestDefaultTypeInternal _RegisterProducerRequest_default_instance_;
class RegisterResponse;
class RegisterResponseDefaultTypeInternal;
extern RegisterResponseDefaultTypeInternal _RegisterResponse_default_instance_;
class SearchArtifactsRequest;
class SearchArtifactsRequestDefaultTypeInternal;
extern SearchArtifactsRequestDefaultTypeInternal _SearchArtifactsRequest_default_instance_;
class SearchArtifactsResponse;
class SearchArtifactsResponseDefaultTypeInternal;
extern SearchArtifactsResponseDefaultTypeInternal _SearchArtifactsResponse_default_instance_;
}  // namespace artifact
}  // namespace flyteidl
namespace google {
namespace protobuf {
template<> ::flyteidl::artifact::AddTagRequest* Arena::CreateMaybeMessage<::flyteidl::artifact::AddTagRequest>(Arena*);
template<> ::flyteidl::artifact::AddTagResponse* Arena::CreateMaybeMessage<::flyteidl::artifact::AddTagResponse>(Arena*);
template<> ::flyteidl::artifact::Artifact* Arena::CreateMaybeMessage<::flyteidl::artifact::Artifact>(Arena*);
template<> ::flyteidl::artifact::ArtifactConsumer* Arena::CreateMaybeMessage<::flyteidl::artifact::ArtifactConsumer>(Arena*);
template<> ::flyteidl::artifact::ArtifactProducer* Arena::CreateMaybeMessage<::flyteidl::artifact::ArtifactProducer>(Arena*);
template<> ::flyteidl::artifact::ArtifactSpec* Arena::CreateMaybeMessage<::flyteidl::artifact::ArtifactSpec>(Arena*);
template<> ::flyteidl::artifact::CloudEventRequest* Arena::CreateMaybeMessage<::flyteidl::artifact::CloudEventRequest>(Arena*);
template<> ::flyteidl::artifact::CloudEventResponse* Arena::CreateMaybeMessage<::flyteidl::artifact::CloudEventResponse>(Arena*);
template<> ::flyteidl::artifact::CreateArtifactRequest* Arena::CreateMaybeMessage<::flyteidl::artifact::CreateArtifactRequest>(Arena*);
template<> ::flyteidl::artifact::CreateArtifactRequest_PartitionsEntry_DoNotUse* Arena::CreateMaybeMessage<::flyteidl::artifact::CreateArtifactRequest_PartitionsEntry_DoNotUse>(Arena*);
template<> ::flyteidl::artifact::CreateArtifactResponse* Arena::CreateMaybeMessage<::flyteidl::artifact::CreateArtifactResponse>(Arena*);
template<> ::flyteidl::artifact::CreateTriggerRequest* Arena::CreateMaybeMessage<::flyteidl::artifact::CreateTriggerRequest>(Arena*);
template<> ::flyteidl::artifact::CreateTriggerResponse* Arena::CreateMaybeMessage<::flyteidl::artifact::CreateTriggerResponse>(Arena*);
template<> ::flyteidl::artifact::DeleteTriggerRequest* Arena::CreateMaybeMessage<::flyteidl::artifact::DeleteTriggerRequest>(Arena*);
template<> ::flyteidl::artifact::DeleteTriggerResponse* Arena::CreateMaybeMessage<::flyteidl::artifact::DeleteTriggerResponse>(Arena*);
template<> ::flyteidl::artifact::GetArtifactRequest* Arena::CreateMaybeMessage<::flyteidl::artifact::GetArtifactRequest>(Arena*);
template<> ::flyteidl::artifact::GetArtifactResponse* Arena::CreateMaybeMessage<::flyteidl::artifact::GetArtifactResponse>(Arena*);
template<> ::flyteidl::artifact::ListArtifactNamesRequest* Arena::CreateMaybeMessage<::flyteidl::artifact::ListArtifactNamesRequest>(Arena*);
template<> ::flyteidl::artifact::ListArtifactNamesResponse* Arena::CreateMaybeMessage<::flyteidl::artifact::ListArtifactNamesResponse>(Arena*);
template<> ::flyteidl::artifact::RegisterConsumerRequest* Arena::CreateMaybeMessage<::flyteidl::artifact::RegisterConsumerRequest>(Arena*);
template<> ::flyteidl::artifact::RegisterProducerRequest* Arena::CreateMaybeMessage<::flyteidl::artifact::RegisterProducerRequest>(Arena*);
template<> ::flyteidl::artifact::RegisterResponse* Arena::CreateMaybeMessage<::flyteidl::artifact::RegisterResponse>(Arena*);
template<> ::flyteidl::artifact::SearchArtifactsRequest* Arena::CreateMaybeMessage<::flyteidl::artifact::SearchArtifactsRequest>(Arena*);
template<> ::flyteidl::artifact::SearchArtifactsResponse* Arena::CreateMaybeMessage<::flyteidl::artifact::SearchArtifactsResponse>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace flyteidl {
namespace artifact {

// ===================================================================

class Artifact final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.Artifact) */ {
 public:
  Artifact();
  virtual ~Artifact();

  Artifact(const Artifact& from);

  inline Artifact& operator=(const Artifact& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Artifact(Artifact&& from) noexcept
    : Artifact() {
    *this = ::std::move(from);
  }

  inline Artifact& operator=(Artifact&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Artifact& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Artifact* internal_default_instance() {
    return reinterpret_cast<const Artifact*>(
               &_Artifact_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Artifact* other);
  friend void swap(Artifact& a, Artifact& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Artifact* New() const final {
    return CreateMaybeMessage<Artifact>(nullptr);
  }

  Artifact* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Artifact>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Artifact& from);
  void MergeFrom(const Artifact& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Artifact* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string tags = 3;
  int tags_size() const;
  void clear_tags();
  static const int kTagsFieldNumber = 3;
  const ::std::string& tags(int index) const;
  ::std::string* mutable_tags(int index);
  void set_tags(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_tags(int index, ::std::string&& value);
  #endif
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, size_t size);
  ::std::string* add_tags();
  void add_tags(const ::std::string& value);
  #if LANG_CXX11
  void add_tags(::std::string&& value);
  #endif
  void add_tags(const char* value);
  void add_tags(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& tags() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_tags();

  // .flyteidl.core.ArtifactID artifact_id = 1;
  bool has_artifact_id() const;
  void clear_artifact_id();
  static const int kArtifactIdFieldNumber = 1;
  const ::flyteidl::core::ArtifactID& artifact_id() const;
  ::flyteidl::core::ArtifactID* release_artifact_id();
  ::flyteidl::core::ArtifactID* mutable_artifact_id();
  void set_allocated_artifact_id(::flyteidl::core::ArtifactID* artifact_id);

  // .flyteidl.artifact.ArtifactSpec spec = 2;
  bool has_spec() const;
  void clear_spec();
  static const int kSpecFieldNumber = 2;
  const ::flyteidl::artifact::ArtifactSpec& spec() const;
  ::flyteidl::artifact::ArtifactSpec* release_spec();
  ::flyteidl::artifact::ArtifactSpec* mutable_spec();
  void set_allocated_spec(::flyteidl::artifact::ArtifactSpec* spec);

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.Artifact)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField<::std::string> tags_;
  ::flyteidl::core::ArtifactID* artifact_id_;
  ::flyteidl::artifact::ArtifactSpec* spec_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class CreateArtifactRequest_PartitionsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<CreateArtifactRequest_PartitionsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
static bool _ParseMap(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  typedef ::google::protobuf::internal::MapEntry<CreateArtifactRequest_PartitionsEntry_DoNotUse, 
    ::std::string, ::std::string,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  CreateArtifactRequest_PartitionsEntry_DoNotUse();
  CreateArtifactRequest_PartitionsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const CreateArtifactRequest_PartitionsEntry_DoNotUse& other);
  static const CreateArtifactRequest_PartitionsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const CreateArtifactRequest_PartitionsEntry_DoNotUse*>(&_CreateArtifactRequest_PartitionsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class CreateArtifactRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.CreateArtifactRequest) */ {
 public:
  CreateArtifactRequest();
  virtual ~CreateArtifactRequest();

  CreateArtifactRequest(const CreateArtifactRequest& from);

  inline CreateArtifactRequest& operator=(const CreateArtifactRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateArtifactRequest(CreateArtifactRequest&& from) noexcept
    : CreateArtifactRequest() {
    *this = ::std::move(from);
  }

  inline CreateArtifactRequest& operator=(CreateArtifactRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CreateArtifactRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateArtifactRequest* internal_default_instance() {
    return reinterpret_cast<const CreateArtifactRequest*>(
               &_CreateArtifactRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(CreateArtifactRequest* other);
  friend void swap(CreateArtifactRequest& a, CreateArtifactRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateArtifactRequest* New() const final {
    return CreateMaybeMessage<CreateArtifactRequest>(nullptr);
  }

  CreateArtifactRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CreateArtifactRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CreateArtifactRequest& from);
  void MergeFrom(const CreateArtifactRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateArtifactRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, string> partitions = 4;
  int partitions_size() const;
  void clear_partitions();
  static const int kPartitionsFieldNumber = 4;
  const ::google::protobuf::Map< ::std::string, ::std::string >&
      partitions() const;
  ::google::protobuf::Map< ::std::string, ::std::string >*
      mutable_partitions();

  // string version = 3;
  void clear_version();
  static const int kVersionFieldNumber = 3;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // string tag = 5;
  void clear_tag();
  static const int kTagFieldNumber = 5;
  const ::std::string& tag() const;
  void set_tag(const ::std::string& value);
  #if LANG_CXX11
  void set_tag(::std::string&& value);
  #endif
  void set_tag(const char* value);
  void set_tag(const char* value, size_t size);
  ::std::string* mutable_tag();
  ::std::string* release_tag();
  void set_allocated_tag(::std::string* tag);

  // .flyteidl.core.ArtifactKey artifact_key = 1;
  bool has_artifact_key() const;
  void clear_artifact_key();
  static const int kArtifactKeyFieldNumber = 1;
  const ::flyteidl::core::ArtifactKey& artifact_key() const;
  ::flyteidl::core::ArtifactKey* release_artifact_key();
  ::flyteidl::core::ArtifactKey* mutable_artifact_key();
  void set_allocated_artifact_key(::flyteidl::core::ArtifactKey* artifact_key);

  // .flyteidl.artifact.ArtifactSpec spec = 2;
  bool has_spec() const;
  void clear_spec();
  static const int kSpecFieldNumber = 2;
  const ::flyteidl::artifact::ArtifactSpec& spec() const;
  ::flyteidl::artifact::ArtifactSpec* release_spec();
  ::flyteidl::artifact::ArtifactSpec* mutable_spec();
  void set_allocated_spec(::flyteidl::artifact::ArtifactSpec* spec);

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.CreateArtifactRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      CreateArtifactRequest_PartitionsEntry_DoNotUse,
      ::std::string, ::std::string,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      0 > partitions_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr tag_;
  ::flyteidl::core::ArtifactKey* artifact_key_;
  ::flyteidl::artifact::ArtifactSpec* spec_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class ArtifactSpec final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.ArtifactSpec) */ {
 public:
  ArtifactSpec();
  virtual ~ArtifactSpec();

  ArtifactSpec(const ArtifactSpec& from);

  inline ArtifactSpec& operator=(const ArtifactSpec& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ArtifactSpec(ArtifactSpec&& from) noexcept
    : ArtifactSpec() {
    *this = ::std::move(from);
  }

  inline ArtifactSpec& operator=(ArtifactSpec&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ArtifactSpec& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ArtifactSpec* internal_default_instance() {
    return reinterpret_cast<const ArtifactSpec*>(
               &_ArtifactSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(ArtifactSpec* other);
  friend void swap(ArtifactSpec& a, ArtifactSpec& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ArtifactSpec* New() const final {
    return CreateMaybeMessage<ArtifactSpec>(nullptr);
  }

  ArtifactSpec* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ArtifactSpec>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ArtifactSpec& from);
  void MergeFrom(const ArtifactSpec& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArtifactSpec* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string principal = 7;
  void clear_principal();
  static const int kPrincipalFieldNumber = 7;
  const ::std::string& principal() const;
  void set_principal(const ::std::string& value);
  #if LANG_CXX11
  void set_principal(::std::string&& value);
  #endif
  void set_principal(const char* value);
  void set_principal(const char* value, size_t size);
  ::std::string* mutable_principal();
  ::std::string* release_principal();
  void set_allocated_principal(::std::string* principal);

  // string short_description = 8;
  void clear_short_description();
  static const int kShortDescriptionFieldNumber = 8;
  const ::std::string& short_description() const;
  void set_short_description(const ::std::string& value);
  #if LANG_CXX11
  void set_short_description(::std::string&& value);
  #endif
  void set_short_description(const char* value);
  void set_short_description(const char* value, size_t size);
  ::std::string* mutable_short_description();
  ::std::string* release_short_description();
  void set_allocated_short_description(::std::string* short_description);

  // string metadata_type = 11;
  void clear_metadata_type();
  static const int kMetadataTypeFieldNumber = 11;
  const ::std::string& metadata_type() const;
  void set_metadata_type(const ::std::string& value);
  #if LANG_CXX11
  void set_metadata_type(::std::string&& value);
  #endif
  void set_metadata_type(const char* value);
  void set_metadata_type(const char* value, size_t size);
  ::std::string* mutable_metadata_type();
  ::std::string* release_metadata_type();
  void set_allocated_metadata_type(::std::string* metadata_type);

  // .flyteidl.core.Literal value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::flyteidl::core::Literal& value() const;
  ::flyteidl::core::Literal* release_value();
  ::flyteidl::core::Literal* mutable_value();
  void set_allocated_value(::flyteidl::core::Literal* value);

  // .flyteidl.core.LiteralType type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  const ::flyteidl::core::LiteralType& type() const;
  ::flyteidl::core::LiteralType* release_type();
  ::flyteidl::core::LiteralType* mutable_type();
  void set_allocated_type(::flyteidl::core::LiteralType* type);

  // .flyteidl.core.TaskExecutionIdentifier task_execution = 5;
  bool has_task_execution() const;
  void clear_task_execution();
  static const int kTaskExecutionFieldNumber = 5;
  const ::flyteidl::core::TaskExecutionIdentifier& task_execution() const;
  ::flyteidl::core::TaskExecutionIdentifier* release_task_execution();
  ::flyteidl::core::TaskExecutionIdentifier* mutable_task_execution();
  void set_allocated_task_execution(::flyteidl::core::TaskExecutionIdentifier* task_execution);

  // .flyteidl.core.WorkflowExecutionIdentifier execution = 6;
  bool has_execution() const;
  void clear_execution();
  static const int kExecutionFieldNumber = 6;
  const ::flyteidl::core::WorkflowExecutionIdentifier& execution() const;
  ::flyteidl::core::WorkflowExecutionIdentifier* release_execution();
  ::flyteidl::core::WorkflowExecutionIdentifier* mutable_execution();
  void set_allocated_execution(::flyteidl::core::WorkflowExecutionIdentifier* execution);

  // .google.protobuf.Any user_metadata = 10;
  bool has_user_metadata() const;
  void clear_user_metadata();
  static const int kUserMetadataFieldNumber = 10;
  const ::google::protobuf::Any& user_metadata() const;
  ::google::protobuf::Any* release_user_metadata();
  ::google::protobuf::Any* mutable_user_metadata();
  void set_allocated_user_metadata(::google::protobuf::Any* user_metadata);

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.ArtifactSpec)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr principal_;
  ::google::protobuf::internal::ArenaStringPtr short_description_;
  ::google::protobuf::internal::ArenaStringPtr metadata_type_;
  ::flyteidl::core::Literal* value_;
  ::flyteidl::core::LiteralType* type_;
  ::flyteidl::core::TaskExecutionIdentifier* task_execution_;
  ::flyteidl::core::WorkflowExecutionIdentifier* execution_;
  ::google::protobuf::Any* user_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class CreateArtifactResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.CreateArtifactResponse) */ {
 public:
  CreateArtifactResponse();
  virtual ~CreateArtifactResponse();

  CreateArtifactResponse(const CreateArtifactResponse& from);

  inline CreateArtifactResponse& operator=(const CreateArtifactResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateArtifactResponse(CreateArtifactResponse&& from) noexcept
    : CreateArtifactResponse() {
    *this = ::std::move(from);
  }

  inline CreateArtifactResponse& operator=(CreateArtifactResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CreateArtifactResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateArtifactResponse* internal_default_instance() {
    return reinterpret_cast<const CreateArtifactResponse*>(
               &_CreateArtifactResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(CreateArtifactResponse* other);
  friend void swap(CreateArtifactResponse& a, CreateArtifactResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateArtifactResponse* New() const final {
    return CreateMaybeMessage<CreateArtifactResponse>(nullptr);
  }

  CreateArtifactResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CreateArtifactResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CreateArtifactResponse& from);
  void MergeFrom(const CreateArtifactResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateArtifactResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .flyteidl.artifact.Artifact artifact = 1;
  bool has_artifact() const;
  void clear_artifact();
  static const int kArtifactFieldNumber = 1;
  const ::flyteidl::artifact::Artifact& artifact() const;
  ::flyteidl::artifact::Artifact* release_artifact();
  ::flyteidl::artifact::Artifact* mutable_artifact();
  void set_allocated_artifact(::flyteidl::artifact::Artifact* artifact);

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.CreateArtifactResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::flyteidl::artifact::Artifact* artifact_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class GetArtifactRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.GetArtifactRequest) */ {
 public:
  GetArtifactRequest();
  virtual ~GetArtifactRequest();

  GetArtifactRequest(const GetArtifactRequest& from);

  inline GetArtifactRequest& operator=(const GetArtifactRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetArtifactRequest(GetArtifactRequest&& from) noexcept
    : GetArtifactRequest() {
    *this = ::std::move(from);
  }

  inline GetArtifactRequest& operator=(GetArtifactRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GetArtifactRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetArtifactRequest* internal_default_instance() {
    return reinterpret_cast<const GetArtifactRequest*>(
               &_GetArtifactRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(GetArtifactRequest* other);
  friend void swap(GetArtifactRequest& a, GetArtifactRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetArtifactRequest* New() const final {
    return CreateMaybeMessage<GetArtifactRequest>(nullptr);
  }

  GetArtifactRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetArtifactRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetArtifactRequest& from);
  void MergeFrom(const GetArtifactRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetArtifactRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .flyteidl.core.ArtifactQuery query = 1;
  bool has_query() const;
  void clear_query();
  static const int kQueryFieldNumber = 1;
  const ::flyteidl::core::ArtifactQuery& query() const;
  ::flyteidl::core::ArtifactQuery* release_query();
  ::flyteidl::core::ArtifactQuery* mutable_query();
  void set_allocated_query(::flyteidl::core::ArtifactQuery* query);

  // bool details = 2;
  void clear_details();
  static const int kDetailsFieldNumber = 2;
  bool details() const;
  void set_details(bool value);

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.GetArtifactRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::flyteidl::core::ArtifactQuery* query_;
  bool details_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class GetArtifactResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.GetArtifactResponse) */ {
 public:
  GetArtifactResponse();
  virtual ~GetArtifactResponse();

  GetArtifactResponse(const GetArtifactResponse& from);

  inline GetArtifactResponse& operator=(const GetArtifactResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetArtifactResponse(GetArtifactResponse&& from) noexcept
    : GetArtifactResponse() {
    *this = ::std::move(from);
  }

  inline GetArtifactResponse& operator=(GetArtifactResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GetArtifactResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetArtifactResponse* internal_default_instance() {
    return reinterpret_cast<const GetArtifactResponse*>(
               &_GetArtifactResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(GetArtifactResponse* other);
  friend void swap(GetArtifactResponse& a, GetArtifactResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetArtifactResponse* New() const final {
    return CreateMaybeMessage<GetArtifactResponse>(nullptr);
  }

  GetArtifactResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetArtifactResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetArtifactResponse& from);
  void MergeFrom(const GetArtifactResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetArtifactResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .flyteidl.artifact.Artifact artifact = 1;
  bool has_artifact() const;
  void clear_artifact();
  static const int kArtifactFieldNumber = 1;
  const ::flyteidl::artifact::Artifact& artifact() const;
  ::flyteidl::artifact::Artifact* release_artifact();
  ::flyteidl::artifact::Artifact* mutable_artifact();
  void set_allocated_artifact(::flyteidl::artifact::Artifact* artifact);

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.GetArtifactResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::flyteidl::artifact::Artifact* artifact_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class ListArtifactNamesRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.ListArtifactNamesRequest) */ {
 public:
  ListArtifactNamesRequest();
  virtual ~ListArtifactNamesRequest();

  ListArtifactNamesRequest(const ListArtifactNamesRequest& from);

  inline ListArtifactNamesRequest& operator=(const ListArtifactNamesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ListArtifactNamesRequest(ListArtifactNamesRequest&& from) noexcept
    : ListArtifactNamesRequest() {
    *this = ::std::move(from);
  }

  inline ListArtifactNamesRequest& operator=(ListArtifactNamesRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ListArtifactNamesRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListArtifactNamesRequest* internal_default_instance() {
    return reinterpret_cast<const ListArtifactNamesRequest*>(
               &_ListArtifactNamesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(ListArtifactNamesRequest* other);
  friend void swap(ListArtifactNamesRequest& a, ListArtifactNamesRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListArtifactNamesRequest* New() const final {
    return CreateMaybeMessage<ListArtifactNamesRequest>(nullptr);
  }

  ListArtifactNamesRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ListArtifactNamesRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ListArtifactNamesRequest& from);
  void MergeFrom(const ListArtifactNamesRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListArtifactNamesRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string project = 1;
  void clear_project();
  static const int kProjectFieldNumber = 1;
  const ::std::string& project() const;
  void set_project(const ::std::string& value);
  #if LANG_CXX11
  void set_project(::std::string&& value);
  #endif
  void set_project(const char* value);
  void set_project(const char* value, size_t size);
  ::std::string* mutable_project();
  ::std::string* release_project();
  void set_allocated_project(::std::string* project);

  // string domain = 2;
  void clear_domain();
  static const int kDomainFieldNumber = 2;
  const ::std::string& domain() const;
  void set_domain(const ::std::string& value);
  #if LANG_CXX11
  void set_domain(::std::string&& value);
  #endif
  void set_domain(const char* value);
  void set_domain(const char* value, size_t size);
  ::std::string* mutable_domain();
  ::std::string* release_domain();
  void set_allocated_domain(::std::string* domain);

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.ListArtifactNamesRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr project_;
  ::google::protobuf::internal::ArenaStringPtr domain_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class ListArtifactNamesResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.ListArtifactNamesResponse) */ {
 public:
  ListArtifactNamesResponse();
  virtual ~ListArtifactNamesResponse();

  ListArtifactNamesResponse(const ListArtifactNamesResponse& from);

  inline ListArtifactNamesResponse& operator=(const ListArtifactNamesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ListArtifactNamesResponse(ListArtifactNamesResponse&& from) noexcept
    : ListArtifactNamesResponse() {
    *this = ::std::move(from);
  }

  inline ListArtifactNamesResponse& operator=(ListArtifactNamesResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ListArtifactNamesResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListArtifactNamesResponse* internal_default_instance() {
    return reinterpret_cast<const ListArtifactNamesResponse*>(
               &_ListArtifactNamesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(ListArtifactNamesResponse* other);
  friend void swap(ListArtifactNamesResponse& a, ListArtifactNamesResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListArtifactNamesResponse* New() const final {
    return CreateMaybeMessage<ListArtifactNamesResponse>(nullptr);
  }

  ListArtifactNamesResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ListArtifactNamesResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ListArtifactNamesResponse& from);
  void MergeFrom(const ListArtifactNamesResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListArtifactNamesResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .flyteidl.core.ArtifactKey artifact_keys = 1;
  int artifact_keys_size() const;
  void clear_artifact_keys();
  static const int kArtifactKeysFieldNumber = 1;
  ::flyteidl::core::ArtifactKey* mutable_artifact_keys(int index);
  ::google::protobuf::RepeatedPtrField< ::flyteidl::core::ArtifactKey >*
      mutable_artifact_keys();
  const ::flyteidl::core::ArtifactKey& artifact_keys(int index) const;
  ::flyteidl::core::ArtifactKey* add_artifact_keys();
  const ::google::protobuf::RepeatedPtrField< ::flyteidl::core::ArtifactKey >&
      artifact_keys() const;

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.ListArtifactNamesResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::flyteidl::core::ArtifactKey > artifact_keys_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class SearchArtifactsRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.SearchArtifactsRequest) */ {
 public:
  SearchArtifactsRequest();
  virtual ~SearchArtifactsRequest();

  SearchArtifactsRequest(const SearchArtifactsRequest& from);

  inline SearchArtifactsRequest& operator=(const SearchArtifactsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SearchArtifactsRequest(SearchArtifactsRequest&& from) noexcept
    : SearchArtifactsRequest() {
    *this = ::std::move(from);
  }

  inline SearchArtifactsRequest& operator=(SearchArtifactsRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SearchArtifactsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SearchArtifactsRequest* internal_default_instance() {
    return reinterpret_cast<const SearchArtifactsRequest*>(
               &_SearchArtifactsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(SearchArtifactsRequest* other);
  friend void swap(SearchArtifactsRequest& a, SearchArtifactsRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SearchArtifactsRequest* New() const final {
    return CreateMaybeMessage<SearchArtifactsRequest>(nullptr);
  }

  SearchArtifactsRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SearchArtifactsRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SearchArtifactsRequest& from);
  void MergeFrom(const SearchArtifactsRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SearchArtifactsRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string filters = 2;
  void clear_filters();
  static const int kFiltersFieldNumber = 2;
  const ::std::string& filters() const;
  void set_filters(const ::std::string& value);
  #if LANG_CXX11
  void set_filters(::std::string&& value);
  #endif
  void set_filters(const char* value);
  void set_filters(const char* value, size_t size);
  ::std::string* mutable_filters();
  ::std::string* release_filters();
  void set_allocated_filters(::std::string* filters);

  // string token = 3;
  void clear_token();
  static const int kTokenFieldNumber = 3;
  const ::std::string& token() const;
  void set_token(const ::std::string& value);
  #if LANG_CXX11
  void set_token(::std::string&& value);
  #endif
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  ::std::string* mutable_token();
  ::std::string* release_token();
  void set_allocated_token(::std::string* token);

  // .flyteidl.core.ArtifactKey artifact_key = 1;
  bool has_artifact_key() const;
  void clear_artifact_key();
  static const int kArtifactKeyFieldNumber = 1;
  const ::flyteidl::core::ArtifactKey& artifact_key() const;
  ::flyteidl::core::ArtifactKey* release_artifact_key();
  ::flyteidl::core::ArtifactKey* mutable_artifact_key();
  void set_allocated_artifact_key(::flyteidl::core::ArtifactKey* artifact_key);

  // int32 limit = 4;
  void clear_limit();
  static const int kLimitFieldNumber = 4;
  ::google::protobuf::int32 limit() const;
  void set_limit(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.SearchArtifactsRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr filters_;
  ::google::protobuf::internal::ArenaStringPtr token_;
  ::flyteidl::core::ArtifactKey* artifact_key_;
  ::google::protobuf::int32 limit_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class SearchArtifactsResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.SearchArtifactsResponse) */ {
 public:
  SearchArtifactsResponse();
  virtual ~SearchArtifactsResponse();

  SearchArtifactsResponse(const SearchArtifactsResponse& from);

  inline SearchArtifactsResponse& operator=(const SearchArtifactsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SearchArtifactsResponse(SearchArtifactsResponse&& from) noexcept
    : SearchArtifactsResponse() {
    *this = ::std::move(from);
  }

  inline SearchArtifactsResponse& operator=(SearchArtifactsResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const SearchArtifactsResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SearchArtifactsResponse* internal_default_instance() {
    return reinterpret_cast<const SearchArtifactsResponse*>(
               &_SearchArtifactsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(SearchArtifactsResponse* other);
  friend void swap(SearchArtifactsResponse& a, SearchArtifactsResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SearchArtifactsResponse* New() const final {
    return CreateMaybeMessage<SearchArtifactsResponse>(nullptr);
  }

  SearchArtifactsResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SearchArtifactsResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SearchArtifactsResponse& from);
  void MergeFrom(const SearchArtifactsResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SearchArtifactsResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .flyteidl.artifact.Artifact artifacts = 1;
  int artifacts_size() const;
  void clear_artifacts();
  static const int kArtifactsFieldNumber = 1;
  ::flyteidl::artifact::Artifact* mutable_artifacts(int index);
  ::google::protobuf::RepeatedPtrField< ::flyteidl::artifact::Artifact >*
      mutable_artifacts();
  const ::flyteidl::artifact::Artifact& artifacts(int index) const;
  ::flyteidl::artifact::Artifact* add_artifacts();
  const ::google::protobuf::RepeatedPtrField< ::flyteidl::artifact::Artifact >&
      artifacts() const;

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.SearchArtifactsResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::flyteidl::artifact::Artifact > artifacts_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class AddTagRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.AddTagRequest) */ {
 public:
  AddTagRequest();
  virtual ~AddTagRequest();

  AddTagRequest(const AddTagRequest& from);

  inline AddTagRequest& operator=(const AddTagRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AddTagRequest(AddTagRequest&& from) noexcept
    : AddTagRequest() {
    *this = ::std::move(from);
  }

  inline AddTagRequest& operator=(AddTagRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const AddTagRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AddTagRequest* internal_default_instance() {
    return reinterpret_cast<const AddTagRequest*>(
               &_AddTagRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(AddTagRequest* other);
  friend void swap(AddTagRequest& a, AddTagRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AddTagRequest* New() const final {
    return CreateMaybeMessage<AddTagRequest>(nullptr);
  }

  AddTagRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AddTagRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AddTagRequest& from);
  void MergeFrom(const AddTagRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddTagRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // .flyteidl.core.ArtifactID artifact_id = 1;
  bool has_artifact_id() const;
  void clear_artifact_id();
  static const int kArtifactIdFieldNumber = 1;
  const ::flyteidl::core::ArtifactID& artifact_id() const;
  ::flyteidl::core::ArtifactID* release_artifact_id();
  ::flyteidl::core::ArtifactID* mutable_artifact_id();
  void set_allocated_artifact_id(::flyteidl::core::ArtifactID* artifact_id);

  // bool overwrite = 3;
  void clear_overwrite();
  static const int kOverwriteFieldNumber = 3;
  bool overwrite() const;
  void set_overwrite(bool value);

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.AddTagRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::flyteidl::core::ArtifactID* artifact_id_;
  bool overwrite_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class AddTagResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.AddTagResponse) */ {
 public:
  AddTagResponse();
  virtual ~AddTagResponse();

  AddTagResponse(const AddTagResponse& from);

  inline AddTagResponse& operator=(const AddTagResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AddTagResponse(AddTagResponse&& from) noexcept
    : AddTagResponse() {
    *this = ::std::move(from);
  }

  inline AddTagResponse& operator=(AddTagResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const AddTagResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AddTagResponse* internal_default_instance() {
    return reinterpret_cast<const AddTagResponse*>(
               &_AddTagResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(AddTagResponse* other);
  friend void swap(AddTagResponse& a, AddTagResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AddTagResponse* New() const final {
    return CreateMaybeMessage<AddTagResponse>(nullptr);
  }

  AddTagResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AddTagResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AddTagResponse& from);
  void MergeFrom(const AddTagResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddTagResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.AddTagResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class CreateTriggerRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.CreateTriggerRequest) */ {
 public:
  CreateTriggerRequest();
  virtual ~CreateTriggerRequest();

  CreateTriggerRequest(const CreateTriggerRequest& from);

  inline CreateTriggerRequest& operator=(const CreateTriggerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateTriggerRequest(CreateTriggerRequest&& from) noexcept
    : CreateTriggerRequest() {
    *this = ::std::move(from);
  }

  inline CreateTriggerRequest& operator=(CreateTriggerRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CreateTriggerRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateTriggerRequest* internal_default_instance() {
    return reinterpret_cast<const CreateTriggerRequest*>(
               &_CreateTriggerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(CreateTriggerRequest* other);
  friend void swap(CreateTriggerRequest& a, CreateTriggerRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateTriggerRequest* New() const final {
    return CreateMaybeMessage<CreateTriggerRequest>(nullptr);
  }

  CreateTriggerRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CreateTriggerRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CreateTriggerRequest& from);
  void MergeFrom(const CreateTriggerRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateTriggerRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .flyteidl.admin.LaunchPlan trigger_launch_plan = 1;
  bool has_trigger_launch_plan() const;
  void clear_trigger_launch_plan();
  static const int kTriggerLaunchPlanFieldNumber = 1;
  const ::flyteidl::admin::LaunchPlan& trigger_launch_plan() const;
  ::flyteidl::admin::LaunchPlan* release_trigger_launch_plan();
  ::flyteidl::admin::LaunchPlan* mutable_trigger_launch_plan();
  void set_allocated_trigger_launch_plan(::flyteidl::admin::LaunchPlan* trigger_launch_plan);

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.CreateTriggerRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::flyteidl::admin::LaunchPlan* trigger_launch_plan_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class CreateTriggerResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.CreateTriggerResponse) */ {
 public:
  CreateTriggerResponse();
  virtual ~CreateTriggerResponse();

  CreateTriggerResponse(const CreateTriggerResponse& from);

  inline CreateTriggerResponse& operator=(const CreateTriggerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateTriggerResponse(CreateTriggerResponse&& from) noexcept
    : CreateTriggerResponse() {
    *this = ::std::move(from);
  }

  inline CreateTriggerResponse& operator=(CreateTriggerResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CreateTriggerResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateTriggerResponse* internal_default_instance() {
    return reinterpret_cast<const CreateTriggerResponse*>(
               &_CreateTriggerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(CreateTriggerResponse* other);
  friend void swap(CreateTriggerResponse& a, CreateTriggerResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateTriggerResponse* New() const final {
    return CreateMaybeMessage<CreateTriggerResponse>(nullptr);
  }

  CreateTriggerResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CreateTriggerResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CreateTriggerResponse& from);
  void MergeFrom(const CreateTriggerResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateTriggerResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.CreateTriggerResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class DeleteTriggerRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.DeleteTriggerRequest) */ {
 public:
  DeleteTriggerRequest();
  virtual ~DeleteTriggerRequest();

  DeleteTriggerRequest(const DeleteTriggerRequest& from);

  inline DeleteTriggerRequest& operator=(const DeleteTriggerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeleteTriggerRequest(DeleteTriggerRequest&& from) noexcept
    : DeleteTriggerRequest() {
    *this = ::std::move(from);
  }

  inline DeleteTriggerRequest& operator=(DeleteTriggerRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const DeleteTriggerRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteTriggerRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteTriggerRequest*>(
               &_DeleteTriggerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(DeleteTriggerRequest* other);
  friend void swap(DeleteTriggerRequest& a, DeleteTriggerRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeleteTriggerRequest* New() const final {
    return CreateMaybeMessage<DeleteTriggerRequest>(nullptr);
  }

  DeleteTriggerRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DeleteTriggerRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DeleteTriggerRequest& from);
  void MergeFrom(const DeleteTriggerRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteTriggerRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .flyteidl.core.Identifier trigger_id = 1;
  bool has_trigger_id() const;
  void clear_trigger_id();
  static const int kTriggerIdFieldNumber = 1;
  const ::flyteidl::core::Identifier& trigger_id() const;
  ::flyteidl::core::Identifier* release_trigger_id();
  ::flyteidl::core::Identifier* mutable_trigger_id();
  void set_allocated_trigger_id(::flyteidl::core::Identifier* trigger_id);

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.DeleteTriggerRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::flyteidl::core::Identifier* trigger_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class DeleteTriggerResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.DeleteTriggerResponse) */ {
 public:
  DeleteTriggerResponse();
  virtual ~DeleteTriggerResponse();

  DeleteTriggerResponse(const DeleteTriggerResponse& from);

  inline DeleteTriggerResponse& operator=(const DeleteTriggerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeleteTriggerResponse(DeleteTriggerResponse&& from) noexcept
    : DeleteTriggerResponse() {
    *this = ::std::move(from);
  }

  inline DeleteTriggerResponse& operator=(DeleteTriggerResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const DeleteTriggerResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteTriggerResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteTriggerResponse*>(
               &_DeleteTriggerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(DeleteTriggerResponse* other);
  friend void swap(DeleteTriggerResponse& a, DeleteTriggerResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeleteTriggerResponse* New() const final {
    return CreateMaybeMessage<DeleteTriggerResponse>(nullptr);
  }

  DeleteTriggerResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DeleteTriggerResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DeleteTriggerResponse& from);
  void MergeFrom(const DeleteTriggerResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteTriggerResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.DeleteTriggerResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class ArtifactProducer final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.ArtifactProducer) */ {
 public:
  ArtifactProducer();
  virtual ~ArtifactProducer();

  ArtifactProducer(const ArtifactProducer& from);

  inline ArtifactProducer& operator=(const ArtifactProducer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ArtifactProducer(ArtifactProducer&& from) noexcept
    : ArtifactProducer() {
    *this = ::std::move(from);
  }

  inline ArtifactProducer& operator=(ArtifactProducer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ArtifactProducer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ArtifactProducer* internal_default_instance() {
    return reinterpret_cast<const ArtifactProducer*>(
               &_ArtifactProducer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(ArtifactProducer* other);
  friend void swap(ArtifactProducer& a, ArtifactProducer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ArtifactProducer* New() const final {
    return CreateMaybeMessage<ArtifactProducer>(nullptr);
  }

  ArtifactProducer* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ArtifactProducer>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ArtifactProducer& from);
  void MergeFrom(const ArtifactProducer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArtifactProducer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .flyteidl.core.Identifier entity_id = 1;
  bool has_entity_id() const;
  void clear_entity_id();
  static const int kEntityIdFieldNumber = 1;
  const ::flyteidl::core::Identifier& entity_id() const;
  ::flyteidl::core::Identifier* release_entity_id();
  ::flyteidl::core::Identifier* mutable_entity_id();
  void set_allocated_entity_id(::flyteidl::core::Identifier* entity_id);

  // .flyteidl.core.VariableMap outputs = 2;
  bool has_outputs() const;
  void clear_outputs();
  static const int kOutputsFieldNumber = 2;
  const ::flyteidl::core::VariableMap& outputs() const;
  ::flyteidl::core::VariableMap* release_outputs();
  ::flyteidl::core::VariableMap* mutable_outputs();
  void set_allocated_outputs(::flyteidl::core::VariableMap* outputs);

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.ArtifactProducer)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::flyteidl::core::Identifier* entity_id_;
  ::flyteidl::core::VariableMap* outputs_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class RegisterProducerRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.RegisterProducerRequest) */ {
 public:
  RegisterProducerRequest();
  virtual ~RegisterProducerRequest();

  RegisterProducerRequest(const RegisterProducerRequest& from);

  inline RegisterProducerRequest& operator=(const RegisterProducerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegisterProducerRequest(RegisterProducerRequest&& from) noexcept
    : RegisterProducerRequest() {
    *this = ::std::move(from);
  }

  inline RegisterProducerRequest& operator=(RegisterProducerRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RegisterProducerRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegisterProducerRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterProducerRequest*>(
               &_RegisterProducerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(RegisterProducerRequest* other);
  friend void swap(RegisterProducerRequest& a, RegisterProducerRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegisterProducerRequest* New() const final {
    return CreateMaybeMessage<RegisterProducerRequest>(nullptr);
  }

  RegisterProducerRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegisterProducerRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegisterProducerRequest& from);
  void MergeFrom(const RegisterProducerRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterProducerRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .flyteidl.artifact.ArtifactProducer producers = 1;
  int producers_size() const;
  void clear_producers();
  static const int kProducersFieldNumber = 1;
  ::flyteidl::artifact::ArtifactProducer* mutable_producers(int index);
  ::google::protobuf::RepeatedPtrField< ::flyteidl::artifact::ArtifactProducer >*
      mutable_producers();
  const ::flyteidl::artifact::ArtifactProducer& producers(int index) const;
  ::flyteidl::artifact::ArtifactProducer* add_producers();
  const ::google::protobuf::RepeatedPtrField< ::flyteidl::artifact::ArtifactProducer >&
      producers() const;

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.RegisterProducerRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::flyteidl::artifact::ArtifactProducer > producers_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class ArtifactConsumer final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.ArtifactConsumer) */ {
 public:
  ArtifactConsumer();
  virtual ~ArtifactConsumer();

  ArtifactConsumer(const ArtifactConsumer& from);

  inline ArtifactConsumer& operator=(const ArtifactConsumer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ArtifactConsumer(ArtifactConsumer&& from) noexcept
    : ArtifactConsumer() {
    *this = ::std::move(from);
  }

  inline ArtifactConsumer& operator=(ArtifactConsumer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ArtifactConsumer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ArtifactConsumer* internal_default_instance() {
    return reinterpret_cast<const ArtifactConsumer*>(
               &_ArtifactConsumer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(ArtifactConsumer* other);
  friend void swap(ArtifactConsumer& a, ArtifactConsumer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ArtifactConsumer* New() const final {
    return CreateMaybeMessage<ArtifactConsumer>(nullptr);
  }

  ArtifactConsumer* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ArtifactConsumer>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ArtifactConsumer& from);
  void MergeFrom(const ArtifactConsumer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ArtifactConsumer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .flyteidl.core.Identifier entity_id = 1;
  bool has_entity_id() const;
  void clear_entity_id();
  static const int kEntityIdFieldNumber = 1;
  const ::flyteidl::core::Identifier& entity_id() const;
  ::flyteidl::core::Identifier* release_entity_id();
  ::flyteidl::core::Identifier* mutable_entity_id();
  void set_allocated_entity_id(::flyteidl::core::Identifier* entity_id);

  // .flyteidl.core.ParameterMap inputs = 2;
  bool has_inputs() const;
  void clear_inputs();
  static const int kInputsFieldNumber = 2;
  const ::flyteidl::core::ParameterMap& inputs() const;
  ::flyteidl::core::ParameterMap* release_inputs();
  ::flyteidl::core::ParameterMap* mutable_inputs();
  void set_allocated_inputs(::flyteidl::core::ParameterMap* inputs);

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.ArtifactConsumer)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::flyteidl::core::Identifier* entity_id_;
  ::flyteidl::core::ParameterMap* inputs_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class RegisterConsumerRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.RegisterConsumerRequest) */ {
 public:
  RegisterConsumerRequest();
  virtual ~RegisterConsumerRequest();

  RegisterConsumerRequest(const RegisterConsumerRequest& from);

  inline RegisterConsumerRequest& operator=(const RegisterConsumerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegisterConsumerRequest(RegisterConsumerRequest&& from) noexcept
    : RegisterConsumerRequest() {
    *this = ::std::move(from);
  }

  inline RegisterConsumerRequest& operator=(RegisterConsumerRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RegisterConsumerRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegisterConsumerRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterConsumerRequest*>(
               &_RegisterConsumerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(RegisterConsumerRequest* other);
  friend void swap(RegisterConsumerRequest& a, RegisterConsumerRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegisterConsumerRequest* New() const final {
    return CreateMaybeMessage<RegisterConsumerRequest>(nullptr);
  }

  RegisterConsumerRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegisterConsumerRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegisterConsumerRequest& from);
  void MergeFrom(const RegisterConsumerRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterConsumerRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .flyteidl.artifact.ArtifactConsumer consumers = 1;
  int consumers_size() const;
  void clear_consumers();
  static const int kConsumersFieldNumber = 1;
  ::flyteidl::artifact::ArtifactConsumer* mutable_consumers(int index);
  ::google::protobuf::RepeatedPtrField< ::flyteidl::artifact::ArtifactConsumer >*
      mutable_consumers();
  const ::flyteidl::artifact::ArtifactConsumer& consumers(int index) const;
  ::flyteidl::artifact::ArtifactConsumer* add_consumers();
  const ::google::protobuf::RepeatedPtrField< ::flyteidl::artifact::ArtifactConsumer >&
      consumers() const;

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.RegisterConsumerRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::flyteidl::artifact::ArtifactConsumer > consumers_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class RegisterResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.RegisterResponse) */ {
 public:
  RegisterResponse();
  virtual ~RegisterResponse();

  RegisterResponse(const RegisterResponse& from);

  inline RegisterResponse& operator=(const RegisterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegisterResponse(RegisterResponse&& from) noexcept
    : RegisterResponse() {
    *this = ::std::move(from);
  }

  inline RegisterResponse& operator=(RegisterResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const RegisterResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegisterResponse* internal_default_instance() {
    return reinterpret_cast<const RegisterResponse*>(
               &_RegisterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(RegisterResponse* other);
  friend void swap(RegisterResponse& a, RegisterResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegisterResponse* New() const final {
    return CreateMaybeMessage<RegisterResponse>(nullptr);
  }

  RegisterResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegisterResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegisterResponse& from);
  void MergeFrom(const RegisterResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.RegisterResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class CloudEventRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.CloudEventRequest) */ {
 public:
  CloudEventRequest();
  virtual ~CloudEventRequest();

  CloudEventRequest(const CloudEventRequest& from);

  inline CloudEventRequest& operator=(const CloudEventRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CloudEventRequest(CloudEventRequest&& from) noexcept
    : CloudEventRequest() {
    *this = ::std::move(from);
  }

  inline CloudEventRequest& operator=(CloudEventRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CloudEventRequest& default_instance();

  enum EventCase {
    kWorkflowExecutionEvent = 1,
    kTaskExecutionEvent = 2,
    kNodeExecutionEvent = 3,
    EVENT_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CloudEventRequest* internal_default_instance() {
    return reinterpret_cast<const CloudEventRequest*>(
               &_CloudEventRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(CloudEventRequest* other);
  friend void swap(CloudEventRequest& a, CloudEventRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CloudEventRequest* New() const final {
    return CreateMaybeMessage<CloudEventRequest>(nullptr);
  }

  CloudEventRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CloudEventRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CloudEventRequest& from);
  void MergeFrom(const CloudEventRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CloudEventRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .flyteidl.event.CloudEventWorkflowExecution workflow_execution_event = 1;
  bool has_workflow_execution_event() const;
  void clear_workflow_execution_event();
  static const int kWorkflowExecutionEventFieldNumber = 1;
  const ::flyteidl::event::CloudEventWorkflowExecution& workflow_execution_event() const;
  ::flyteidl::event::CloudEventWorkflowExecution* release_workflow_execution_event();
  ::flyteidl::event::CloudEventWorkflowExecution* mutable_workflow_execution_event();
  void set_allocated_workflow_execution_event(::flyteidl::event::CloudEventWorkflowExecution* workflow_execution_event);

  // .flyteidl.event.CloudEventTaskExecution task_execution_event = 2;
  bool has_task_execution_event() const;
  void clear_task_execution_event();
  static const int kTaskExecutionEventFieldNumber = 2;
  const ::flyteidl::event::CloudEventTaskExecution& task_execution_event() const;
  ::flyteidl::event::CloudEventTaskExecution* release_task_execution_event();
  ::flyteidl::event::CloudEventTaskExecution* mutable_task_execution_event();
  void set_allocated_task_execution_event(::flyteidl::event::CloudEventTaskExecution* task_execution_event);

  // .flyteidl.event.CloudEventNodeExecution node_execution_event = 3;
  bool has_node_execution_event() const;
  void clear_node_execution_event();
  static const int kNodeExecutionEventFieldNumber = 3;
  const ::flyteidl::event::CloudEventNodeExecution& node_execution_event() const;
  ::flyteidl::event::CloudEventNodeExecution* release_node_execution_event();
  ::flyteidl::event::CloudEventNodeExecution* mutable_node_execution_event();
  void set_allocated_node_execution_event(::flyteidl::event::CloudEventNodeExecution* node_execution_event);

  void clear_event();
  EventCase event_case() const;
  // @@protoc_insertion_point(class_scope:flyteidl.artifact.CloudEventRequest)
 private:
  class HasBitSetters;
  void set_has_workflow_execution_event();
  void set_has_task_execution_event();
  void set_has_node_execution_event();

  inline bool has_event() const;
  inline void clear_has_event();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union EventUnion {
    EventUnion() {}
    ::flyteidl::event::CloudEventWorkflowExecution* workflow_execution_event_;
    ::flyteidl::event::CloudEventTaskExecution* task_execution_event_;
    ::flyteidl::event::CloudEventNodeExecution* node_execution_event_;
  } event_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// -------------------------------------------------------------------

class CloudEventResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:flyteidl.artifact.CloudEventResponse) */ {
 public:
  CloudEventResponse();
  virtual ~CloudEventResponse();

  CloudEventResponse(const CloudEventResponse& from);

  inline CloudEventResponse& operator=(const CloudEventResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CloudEventResponse(CloudEventResponse&& from) noexcept
    : CloudEventResponse() {
    *this = ::std::move(from);
  }

  inline CloudEventResponse& operator=(CloudEventResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const CloudEventResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CloudEventResponse* internal_default_instance() {
    return reinterpret_cast<const CloudEventResponse*>(
               &_CloudEventResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(CloudEventResponse* other);
  friend void swap(CloudEventResponse& a, CloudEventResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CloudEventResponse* New() const final {
    return CreateMaybeMessage<CloudEventResponse>(nullptr);
  }

  CloudEventResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CloudEventResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CloudEventResponse& from);
  void MergeFrom(const CloudEventResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CloudEventResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:flyteidl.artifact.CloudEventResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flyteidl_2fartifact_2fartifacts_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Artifact

// .flyteidl.core.ArtifactID artifact_id = 1;
inline bool Artifact::has_artifact_id() const {
  return this != internal_default_instance() && artifact_id_ != nullptr;
}
inline const ::flyteidl::core::ArtifactID& Artifact::artifact_id() const {
  const ::flyteidl::core::ArtifactID* p = artifact_id_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.Artifact.artifact_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::ArtifactID*>(
      &::flyteidl::core::_ArtifactID_default_instance_);
}
inline ::flyteidl::core::ArtifactID* Artifact::release_artifact_id() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.Artifact.artifact_id)
  
  ::flyteidl::core::ArtifactID* temp = artifact_id_;
  artifact_id_ = nullptr;
  return temp;
}
inline ::flyteidl::core::ArtifactID* Artifact::mutable_artifact_id() {
  
  if (artifact_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::ArtifactID>(GetArenaNoVirtual());
    artifact_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.Artifact.artifact_id)
  return artifact_id_;
}
inline void Artifact::set_allocated_artifact_id(::flyteidl::core::ArtifactID* artifact_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(artifact_id_);
  }
  if (artifact_id) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      artifact_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, artifact_id, submessage_arena);
    }
    
  } else {
    
  }
  artifact_id_ = artifact_id;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.Artifact.artifact_id)
}

// .flyteidl.artifact.ArtifactSpec spec = 2;
inline bool Artifact::has_spec() const {
  return this != internal_default_instance() && spec_ != nullptr;
}
inline void Artifact::clear_spec() {
  if (GetArenaNoVirtual() == nullptr && spec_ != nullptr) {
    delete spec_;
  }
  spec_ = nullptr;
}
inline const ::flyteidl::artifact::ArtifactSpec& Artifact::spec() const {
  const ::flyteidl::artifact::ArtifactSpec* p = spec_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.Artifact.spec)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::artifact::ArtifactSpec*>(
      &::flyteidl::artifact::_ArtifactSpec_default_instance_);
}
inline ::flyteidl::artifact::ArtifactSpec* Artifact::release_spec() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.Artifact.spec)
  
  ::flyteidl::artifact::ArtifactSpec* temp = spec_;
  spec_ = nullptr;
  return temp;
}
inline ::flyteidl::artifact::ArtifactSpec* Artifact::mutable_spec() {
  
  if (spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::artifact::ArtifactSpec>(GetArenaNoVirtual());
    spec_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.Artifact.spec)
  return spec_;
}
inline void Artifact::set_allocated_spec(::flyteidl::artifact::ArtifactSpec* spec) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete spec_;
  }
  if (spec) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      spec = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    
  } else {
    
  }
  spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.Artifact.spec)
}

// repeated string tags = 3;
inline int Artifact::tags_size() const {
  return tags_.size();
}
inline void Artifact::clear_tags() {
  tags_.Clear();
}
inline const ::std::string& Artifact::tags(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.artifact.Artifact.tags)
  return tags_.Get(index);
}
inline ::std::string* Artifact::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.Artifact.tags)
  return tags_.Mutable(index);
}
inline void Artifact::set_tags(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:flyteidl.artifact.Artifact.tags)
  tags_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Artifact::set_tags(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:flyteidl.artifact.Artifact.tags)
  tags_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Artifact::set_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:flyteidl.artifact.Artifact.tags)
}
inline void Artifact::set_tags(int index, const char* value, size_t size) {
  tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:flyteidl.artifact.Artifact.tags)
}
inline ::std::string* Artifact::add_tags() {
  // @@protoc_insertion_point(field_add_mutable:flyteidl.artifact.Artifact.tags)
  return tags_.Add();
}
inline void Artifact::add_tags(const ::std::string& value) {
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:flyteidl.artifact.Artifact.tags)
}
#if LANG_CXX11
inline void Artifact::add_tags(::std::string&& value) {
  tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:flyteidl.artifact.Artifact.tags)
}
#endif
inline void Artifact::add_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:flyteidl.artifact.Artifact.tags)
}
inline void Artifact::add_tags(const char* value, size_t size) {
  tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:flyteidl.artifact.Artifact.tags)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
Artifact::tags() const {
  // @@protoc_insertion_point(field_list:flyteidl.artifact.Artifact.tags)
  return tags_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
Artifact::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.artifact.Artifact.tags)
  return &tags_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// CreateArtifactRequest

// .flyteidl.core.ArtifactKey artifact_key = 1;
inline bool CreateArtifactRequest::has_artifact_key() const {
  return this != internal_default_instance() && artifact_key_ != nullptr;
}
inline const ::flyteidl::core::ArtifactKey& CreateArtifactRequest::artifact_key() const {
  const ::flyteidl::core::ArtifactKey* p = artifact_key_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.CreateArtifactRequest.artifact_key)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::ArtifactKey*>(
      &::flyteidl::core::_ArtifactKey_default_instance_);
}
inline ::flyteidl::core::ArtifactKey* CreateArtifactRequest::release_artifact_key() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.CreateArtifactRequest.artifact_key)
  
  ::flyteidl::core::ArtifactKey* temp = artifact_key_;
  artifact_key_ = nullptr;
  return temp;
}
inline ::flyteidl::core::ArtifactKey* CreateArtifactRequest::mutable_artifact_key() {
  
  if (artifact_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::ArtifactKey>(GetArenaNoVirtual());
    artifact_key_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.CreateArtifactRequest.artifact_key)
  return artifact_key_;
}
inline void CreateArtifactRequest::set_allocated_artifact_key(::flyteidl::core::ArtifactKey* artifact_key) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(artifact_key_);
  }
  if (artifact_key) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      artifact_key = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, artifact_key, submessage_arena);
    }
    
  } else {
    
  }
  artifact_key_ = artifact_key;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.CreateArtifactRequest.artifact_key)
}

// string version = 3;
inline void CreateArtifactRequest::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CreateArtifactRequest::version() const {
  // @@protoc_insertion_point(field_get:flyteidl.artifact.CreateArtifactRequest.version)
  return version_.GetNoArena();
}
inline void CreateArtifactRequest::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.artifact.CreateArtifactRequest.version)
}
#if LANG_CXX11
inline void CreateArtifactRequest::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.artifact.CreateArtifactRequest.version)
}
#endif
inline void CreateArtifactRequest::set_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.artifact.CreateArtifactRequest.version)
}
inline void CreateArtifactRequest::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.artifact.CreateArtifactRequest.version)
}
inline ::std::string* CreateArtifactRequest::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.CreateArtifactRequest.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateArtifactRequest::release_version() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.CreateArtifactRequest.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateArtifactRequest::set_allocated_version(::std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.CreateArtifactRequest.version)
}

// .flyteidl.artifact.ArtifactSpec spec = 2;
inline bool CreateArtifactRequest::has_spec() const {
  return this != internal_default_instance() && spec_ != nullptr;
}
inline void CreateArtifactRequest::clear_spec() {
  if (GetArenaNoVirtual() == nullptr && spec_ != nullptr) {
    delete spec_;
  }
  spec_ = nullptr;
}
inline const ::flyteidl::artifact::ArtifactSpec& CreateArtifactRequest::spec() const {
  const ::flyteidl::artifact::ArtifactSpec* p = spec_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.CreateArtifactRequest.spec)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::artifact::ArtifactSpec*>(
      &::flyteidl::artifact::_ArtifactSpec_default_instance_);
}
inline ::flyteidl::artifact::ArtifactSpec* CreateArtifactRequest::release_spec() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.CreateArtifactRequest.spec)
  
  ::flyteidl::artifact::ArtifactSpec* temp = spec_;
  spec_ = nullptr;
  return temp;
}
inline ::flyteidl::artifact::ArtifactSpec* CreateArtifactRequest::mutable_spec() {
  
  if (spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::artifact::ArtifactSpec>(GetArenaNoVirtual());
    spec_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.CreateArtifactRequest.spec)
  return spec_;
}
inline void CreateArtifactRequest::set_allocated_spec(::flyteidl::artifact::ArtifactSpec* spec) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete spec_;
  }
  if (spec) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      spec = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, spec, submessage_arena);
    }
    
  } else {
    
  }
  spec_ = spec;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.CreateArtifactRequest.spec)
}

// map<string, string> partitions = 4;
inline int CreateArtifactRequest::partitions_size() const {
  return partitions_.size();
}
inline void CreateArtifactRequest::clear_partitions() {
  partitions_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::std::string >&
CreateArtifactRequest::partitions() const {
  // @@protoc_insertion_point(field_map:flyteidl.artifact.CreateArtifactRequest.partitions)
  return partitions_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::std::string >*
CreateArtifactRequest::mutable_partitions() {
  // @@protoc_insertion_point(field_mutable_map:flyteidl.artifact.CreateArtifactRequest.partitions)
  return partitions_.MutableMap();
}

// string tag = 5;
inline void CreateArtifactRequest::clear_tag() {
  tag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CreateArtifactRequest::tag() const {
  // @@protoc_insertion_point(field_get:flyteidl.artifact.CreateArtifactRequest.tag)
  return tag_.GetNoArena();
}
inline void CreateArtifactRequest::set_tag(const ::std::string& value) {
  
  tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.artifact.CreateArtifactRequest.tag)
}
#if LANG_CXX11
inline void CreateArtifactRequest::set_tag(::std::string&& value) {
  
  tag_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.artifact.CreateArtifactRequest.tag)
}
#endif
inline void CreateArtifactRequest::set_tag(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.artifact.CreateArtifactRequest.tag)
}
inline void CreateArtifactRequest::set_tag(const char* value, size_t size) {
  
  tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.artifact.CreateArtifactRequest.tag)
}
inline ::std::string* CreateArtifactRequest::mutable_tag() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.CreateArtifactRequest.tag)
  return tag_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateArtifactRequest::release_tag() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.CreateArtifactRequest.tag)
  
  return tag_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateArtifactRequest::set_allocated_tag(::std::string* tag) {
  if (tag != nullptr) {
    
  } else {
    
  }
  tag_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tag);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.CreateArtifactRequest.tag)
}

// -------------------------------------------------------------------

// ArtifactSpec

// .flyteidl.core.Literal value = 1;
inline bool ArtifactSpec::has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline const ::flyteidl::core::Literal& ArtifactSpec::value() const {
  const ::flyteidl::core::Literal* p = value_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.ArtifactSpec.value)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::Literal*>(
      &::flyteidl::core::_Literal_default_instance_);
}
inline ::flyteidl::core::Literal* ArtifactSpec::release_value() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.ArtifactSpec.value)
  
  ::flyteidl::core::Literal* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::flyteidl::core::Literal* ArtifactSpec::mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::Literal>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.ArtifactSpec.value)
  return value_;
}
inline void ArtifactSpec::set_allocated_value(::flyteidl::core::Literal* value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(value_);
  }
  if (value) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.ArtifactSpec.value)
}

// .flyteidl.core.LiteralType type = 2;
inline bool ArtifactSpec::has_type() const {
  return this != internal_default_instance() && type_ != nullptr;
}
inline const ::flyteidl::core::LiteralType& ArtifactSpec::type() const {
  const ::flyteidl::core::LiteralType* p = type_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.ArtifactSpec.type)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::LiteralType*>(
      &::flyteidl::core::_LiteralType_default_instance_);
}
inline ::flyteidl::core::LiteralType* ArtifactSpec::release_type() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.ArtifactSpec.type)
  
  ::flyteidl::core::LiteralType* temp = type_;
  type_ = nullptr;
  return temp;
}
inline ::flyteidl::core::LiteralType* ArtifactSpec::mutable_type() {
  
  if (type_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::LiteralType>(GetArenaNoVirtual());
    type_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.ArtifactSpec.type)
  return type_;
}
inline void ArtifactSpec::set_allocated_type(::flyteidl::core::LiteralType* type) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(type_);
  }
  if (type) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      type = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, type, submessage_arena);
    }
    
  } else {
    
  }
  type_ = type;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.ArtifactSpec.type)
}

// .flyteidl.core.TaskExecutionIdentifier task_execution = 5;
inline bool ArtifactSpec::has_task_execution() const {
  return this != internal_default_instance() && task_execution_ != nullptr;
}
inline const ::flyteidl::core::TaskExecutionIdentifier& ArtifactSpec::task_execution() const {
  const ::flyteidl::core::TaskExecutionIdentifier* p = task_execution_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.ArtifactSpec.task_execution)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::TaskExecutionIdentifier*>(
      &::flyteidl::core::_TaskExecutionIdentifier_default_instance_);
}
inline ::flyteidl::core::TaskExecutionIdentifier* ArtifactSpec::release_task_execution() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.ArtifactSpec.task_execution)
  
  ::flyteidl::core::TaskExecutionIdentifier* temp = task_execution_;
  task_execution_ = nullptr;
  return temp;
}
inline ::flyteidl::core::TaskExecutionIdentifier* ArtifactSpec::mutable_task_execution() {
  
  if (task_execution_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::TaskExecutionIdentifier>(GetArenaNoVirtual());
    task_execution_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.ArtifactSpec.task_execution)
  return task_execution_;
}
inline void ArtifactSpec::set_allocated_task_execution(::flyteidl::core::TaskExecutionIdentifier* task_execution) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(task_execution_);
  }
  if (task_execution) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      task_execution = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, task_execution, submessage_arena);
    }
    
  } else {
    
  }
  task_execution_ = task_execution;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.ArtifactSpec.task_execution)
}

// .flyteidl.core.WorkflowExecutionIdentifier execution = 6;
inline bool ArtifactSpec::has_execution() const {
  return this != internal_default_instance() && execution_ != nullptr;
}
inline const ::flyteidl::core::WorkflowExecutionIdentifier& ArtifactSpec::execution() const {
  const ::flyteidl::core::WorkflowExecutionIdentifier* p = execution_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.ArtifactSpec.execution)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::WorkflowExecutionIdentifier*>(
      &::flyteidl::core::_WorkflowExecutionIdentifier_default_instance_);
}
inline ::flyteidl::core::WorkflowExecutionIdentifier* ArtifactSpec::release_execution() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.ArtifactSpec.execution)
  
  ::flyteidl::core::WorkflowExecutionIdentifier* temp = execution_;
  execution_ = nullptr;
  return temp;
}
inline ::flyteidl::core::WorkflowExecutionIdentifier* ArtifactSpec::mutable_execution() {
  
  if (execution_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::WorkflowExecutionIdentifier>(GetArenaNoVirtual());
    execution_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.ArtifactSpec.execution)
  return execution_;
}
inline void ArtifactSpec::set_allocated_execution(::flyteidl::core::WorkflowExecutionIdentifier* execution) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(execution_);
  }
  if (execution) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      execution = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, execution, submessage_arena);
    }
    
  } else {
    
  }
  execution_ = execution;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.ArtifactSpec.execution)
}

// string principal = 7;
inline void ArtifactSpec::clear_principal() {
  principal_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ArtifactSpec::principal() const {
  // @@protoc_insertion_point(field_get:flyteidl.artifact.ArtifactSpec.principal)
  return principal_.GetNoArena();
}
inline void ArtifactSpec::set_principal(const ::std::string& value) {
  
  principal_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.artifact.ArtifactSpec.principal)
}
#if LANG_CXX11
inline void ArtifactSpec::set_principal(::std::string&& value) {
  
  principal_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.artifact.ArtifactSpec.principal)
}
#endif
inline void ArtifactSpec::set_principal(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  principal_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.artifact.ArtifactSpec.principal)
}
inline void ArtifactSpec::set_principal(const char* value, size_t size) {
  
  principal_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.artifact.ArtifactSpec.principal)
}
inline ::std::string* ArtifactSpec::mutable_principal() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.ArtifactSpec.principal)
  return principal_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ArtifactSpec::release_principal() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.ArtifactSpec.principal)
  
  return principal_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ArtifactSpec::set_allocated_principal(::std::string* principal) {
  if (principal != nullptr) {
    
  } else {
    
  }
  principal_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), principal);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.ArtifactSpec.principal)
}

// string short_description = 8;
inline void ArtifactSpec::clear_short_description() {
  short_description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ArtifactSpec::short_description() const {
  // @@protoc_insertion_point(field_get:flyteidl.artifact.ArtifactSpec.short_description)
  return short_description_.GetNoArena();
}
inline void ArtifactSpec::set_short_description(const ::std::string& value) {
  
  short_description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.artifact.ArtifactSpec.short_description)
}
#if LANG_CXX11
inline void ArtifactSpec::set_short_description(::std::string&& value) {
  
  short_description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.artifact.ArtifactSpec.short_description)
}
#endif
inline void ArtifactSpec::set_short_description(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  short_description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.artifact.ArtifactSpec.short_description)
}
inline void ArtifactSpec::set_short_description(const char* value, size_t size) {
  
  short_description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.artifact.ArtifactSpec.short_description)
}
inline ::std::string* ArtifactSpec::mutable_short_description() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.ArtifactSpec.short_description)
  return short_description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ArtifactSpec::release_short_description() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.ArtifactSpec.short_description)
  
  return short_description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ArtifactSpec::set_allocated_short_description(::std::string* short_description) {
  if (short_description != nullptr) {
    
  } else {
    
  }
  short_description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), short_description);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.ArtifactSpec.short_description)
}

// .google.protobuf.Any user_metadata = 10;
inline bool ArtifactSpec::has_user_metadata() const {
  return this != internal_default_instance() && user_metadata_ != nullptr;
}
inline const ::google::protobuf::Any& ArtifactSpec::user_metadata() const {
  const ::google::protobuf::Any* p = user_metadata_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.ArtifactSpec.user_metadata)
  return p != nullptr ? *p : *reinterpret_cast<const ::google::protobuf::Any*>(
      &::google::protobuf::_Any_default_instance_);
}
inline ::google::protobuf::Any* ArtifactSpec::release_user_metadata() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.ArtifactSpec.user_metadata)
  
  ::google::protobuf::Any* temp = user_metadata_;
  user_metadata_ = nullptr;
  return temp;
}
inline ::google::protobuf::Any* ArtifactSpec::mutable_user_metadata() {
  
  if (user_metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::google::protobuf::Any>(GetArenaNoVirtual());
    user_metadata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.ArtifactSpec.user_metadata)
  return user_metadata_;
}
inline void ArtifactSpec::set_allocated_user_metadata(::google::protobuf::Any* user_metadata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(user_metadata_);
  }
  if (user_metadata) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      user_metadata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, user_metadata, submessage_arena);
    }
    
  } else {
    
  }
  user_metadata_ = user_metadata;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.ArtifactSpec.user_metadata)
}

// string metadata_type = 11;
inline void ArtifactSpec::clear_metadata_type() {
  metadata_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ArtifactSpec::metadata_type() const {
  // @@protoc_insertion_point(field_get:flyteidl.artifact.ArtifactSpec.metadata_type)
  return metadata_type_.GetNoArena();
}
inline void ArtifactSpec::set_metadata_type(const ::std::string& value) {
  
  metadata_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.artifact.ArtifactSpec.metadata_type)
}
#if LANG_CXX11
inline void ArtifactSpec::set_metadata_type(::std::string&& value) {
  
  metadata_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.artifact.ArtifactSpec.metadata_type)
}
#endif
inline void ArtifactSpec::set_metadata_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  metadata_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.artifact.ArtifactSpec.metadata_type)
}
inline void ArtifactSpec::set_metadata_type(const char* value, size_t size) {
  
  metadata_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.artifact.ArtifactSpec.metadata_type)
}
inline ::std::string* ArtifactSpec::mutable_metadata_type() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.ArtifactSpec.metadata_type)
  return metadata_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ArtifactSpec::release_metadata_type() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.ArtifactSpec.metadata_type)
  
  return metadata_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ArtifactSpec::set_allocated_metadata_type(::std::string* metadata_type) {
  if (metadata_type != nullptr) {
    
  } else {
    
  }
  metadata_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), metadata_type);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.ArtifactSpec.metadata_type)
}

// -------------------------------------------------------------------

// CreateArtifactResponse

// .flyteidl.artifact.Artifact artifact = 1;
inline bool CreateArtifactResponse::has_artifact() const {
  return this != internal_default_instance() && artifact_ != nullptr;
}
inline void CreateArtifactResponse::clear_artifact() {
  if (GetArenaNoVirtual() == nullptr && artifact_ != nullptr) {
    delete artifact_;
  }
  artifact_ = nullptr;
}
inline const ::flyteidl::artifact::Artifact& CreateArtifactResponse::artifact() const {
  const ::flyteidl::artifact::Artifact* p = artifact_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.CreateArtifactResponse.artifact)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::artifact::Artifact*>(
      &::flyteidl::artifact::_Artifact_default_instance_);
}
inline ::flyteidl::artifact::Artifact* CreateArtifactResponse::release_artifact() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.CreateArtifactResponse.artifact)
  
  ::flyteidl::artifact::Artifact* temp = artifact_;
  artifact_ = nullptr;
  return temp;
}
inline ::flyteidl::artifact::Artifact* CreateArtifactResponse::mutable_artifact() {
  
  if (artifact_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::artifact::Artifact>(GetArenaNoVirtual());
    artifact_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.CreateArtifactResponse.artifact)
  return artifact_;
}
inline void CreateArtifactResponse::set_allocated_artifact(::flyteidl::artifact::Artifact* artifact) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete artifact_;
  }
  if (artifact) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      artifact = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, artifact, submessage_arena);
    }
    
  } else {
    
  }
  artifact_ = artifact;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.CreateArtifactResponse.artifact)
}

// -------------------------------------------------------------------

// GetArtifactRequest

// .flyteidl.core.ArtifactQuery query = 1;
inline bool GetArtifactRequest::has_query() const {
  return this != internal_default_instance() && query_ != nullptr;
}
inline const ::flyteidl::core::ArtifactQuery& GetArtifactRequest::query() const {
  const ::flyteidl::core::ArtifactQuery* p = query_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.GetArtifactRequest.query)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::ArtifactQuery*>(
      &::flyteidl::core::_ArtifactQuery_default_instance_);
}
inline ::flyteidl::core::ArtifactQuery* GetArtifactRequest::release_query() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.GetArtifactRequest.query)
  
  ::flyteidl::core::ArtifactQuery* temp = query_;
  query_ = nullptr;
  return temp;
}
inline ::flyteidl::core::ArtifactQuery* GetArtifactRequest::mutable_query() {
  
  if (query_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::ArtifactQuery>(GetArenaNoVirtual());
    query_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.GetArtifactRequest.query)
  return query_;
}
inline void GetArtifactRequest::set_allocated_query(::flyteidl::core::ArtifactQuery* query) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(query_);
  }
  if (query) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      query = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, query, submessage_arena);
    }
    
  } else {
    
  }
  query_ = query;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.GetArtifactRequest.query)
}

// bool details = 2;
inline void GetArtifactRequest::clear_details() {
  details_ = false;
}
inline bool GetArtifactRequest::details() const {
  // @@protoc_insertion_point(field_get:flyteidl.artifact.GetArtifactRequest.details)
  return details_;
}
inline void GetArtifactRequest::set_details(bool value) {
  
  details_ = value;
  // @@protoc_insertion_point(field_set:flyteidl.artifact.GetArtifactRequest.details)
}

// -------------------------------------------------------------------

// GetArtifactResponse

// .flyteidl.artifact.Artifact artifact = 1;
inline bool GetArtifactResponse::has_artifact() const {
  return this != internal_default_instance() && artifact_ != nullptr;
}
inline void GetArtifactResponse::clear_artifact() {
  if (GetArenaNoVirtual() == nullptr && artifact_ != nullptr) {
    delete artifact_;
  }
  artifact_ = nullptr;
}
inline const ::flyteidl::artifact::Artifact& GetArtifactResponse::artifact() const {
  const ::flyteidl::artifact::Artifact* p = artifact_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.GetArtifactResponse.artifact)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::artifact::Artifact*>(
      &::flyteidl::artifact::_Artifact_default_instance_);
}
inline ::flyteidl::artifact::Artifact* GetArtifactResponse::release_artifact() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.GetArtifactResponse.artifact)
  
  ::flyteidl::artifact::Artifact* temp = artifact_;
  artifact_ = nullptr;
  return temp;
}
inline ::flyteidl::artifact::Artifact* GetArtifactResponse::mutable_artifact() {
  
  if (artifact_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::artifact::Artifact>(GetArenaNoVirtual());
    artifact_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.GetArtifactResponse.artifact)
  return artifact_;
}
inline void GetArtifactResponse::set_allocated_artifact(::flyteidl::artifact::Artifact* artifact) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete artifact_;
  }
  if (artifact) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      artifact = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, artifact, submessage_arena);
    }
    
  } else {
    
  }
  artifact_ = artifact;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.GetArtifactResponse.artifact)
}

// -------------------------------------------------------------------

// ListArtifactNamesRequest

// string project = 1;
inline void ListArtifactNamesRequest::clear_project() {
  project_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ListArtifactNamesRequest::project() const {
  // @@protoc_insertion_point(field_get:flyteidl.artifact.ListArtifactNamesRequest.project)
  return project_.GetNoArena();
}
inline void ListArtifactNamesRequest::set_project(const ::std::string& value) {
  
  project_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.artifact.ListArtifactNamesRequest.project)
}
#if LANG_CXX11
inline void ListArtifactNamesRequest::set_project(::std::string&& value) {
  
  project_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.artifact.ListArtifactNamesRequest.project)
}
#endif
inline void ListArtifactNamesRequest::set_project(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  project_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.artifact.ListArtifactNamesRequest.project)
}
inline void ListArtifactNamesRequest::set_project(const char* value, size_t size) {
  
  project_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.artifact.ListArtifactNamesRequest.project)
}
inline ::std::string* ListArtifactNamesRequest::mutable_project() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.ListArtifactNamesRequest.project)
  return project_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ListArtifactNamesRequest::release_project() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.ListArtifactNamesRequest.project)
  
  return project_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ListArtifactNamesRequest::set_allocated_project(::std::string* project) {
  if (project != nullptr) {
    
  } else {
    
  }
  project_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), project);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.ListArtifactNamesRequest.project)
}

// string domain = 2;
inline void ListArtifactNamesRequest::clear_domain() {
  domain_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ListArtifactNamesRequest::domain() const {
  // @@protoc_insertion_point(field_get:flyteidl.artifact.ListArtifactNamesRequest.domain)
  return domain_.GetNoArena();
}
inline void ListArtifactNamesRequest::set_domain(const ::std::string& value) {
  
  domain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.artifact.ListArtifactNamesRequest.domain)
}
#if LANG_CXX11
inline void ListArtifactNamesRequest::set_domain(::std::string&& value) {
  
  domain_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.artifact.ListArtifactNamesRequest.domain)
}
#endif
inline void ListArtifactNamesRequest::set_domain(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  domain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.artifact.ListArtifactNamesRequest.domain)
}
inline void ListArtifactNamesRequest::set_domain(const char* value, size_t size) {
  
  domain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.artifact.ListArtifactNamesRequest.domain)
}
inline ::std::string* ListArtifactNamesRequest::mutable_domain() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.ListArtifactNamesRequest.domain)
  return domain_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ListArtifactNamesRequest::release_domain() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.ListArtifactNamesRequest.domain)
  
  return domain_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ListArtifactNamesRequest::set_allocated_domain(::std::string* domain) {
  if (domain != nullptr) {
    
  } else {
    
  }
  domain_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), domain);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.ListArtifactNamesRequest.domain)
}

// -------------------------------------------------------------------

// ListArtifactNamesResponse

// repeated .flyteidl.core.ArtifactKey artifact_keys = 1;
inline int ListArtifactNamesResponse::artifact_keys_size() const {
  return artifact_keys_.size();
}
inline ::flyteidl::core::ArtifactKey* ListArtifactNamesResponse::mutable_artifact_keys(int index) {
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.ListArtifactNamesResponse.artifact_keys)
  return artifact_keys_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::flyteidl::core::ArtifactKey >*
ListArtifactNamesResponse::mutable_artifact_keys() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.artifact.ListArtifactNamesResponse.artifact_keys)
  return &artifact_keys_;
}
inline const ::flyteidl::core::ArtifactKey& ListArtifactNamesResponse::artifact_keys(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.artifact.ListArtifactNamesResponse.artifact_keys)
  return artifact_keys_.Get(index);
}
inline ::flyteidl::core::ArtifactKey* ListArtifactNamesResponse::add_artifact_keys() {
  // @@protoc_insertion_point(field_add:flyteidl.artifact.ListArtifactNamesResponse.artifact_keys)
  return artifact_keys_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::flyteidl::core::ArtifactKey >&
ListArtifactNamesResponse::artifact_keys() const {
  // @@protoc_insertion_point(field_list:flyteidl.artifact.ListArtifactNamesResponse.artifact_keys)
  return artifact_keys_;
}

// -------------------------------------------------------------------

// SearchArtifactsRequest

// .flyteidl.core.ArtifactKey artifact_key = 1;
inline bool SearchArtifactsRequest::has_artifact_key() const {
  return this != internal_default_instance() && artifact_key_ != nullptr;
}
inline const ::flyteidl::core::ArtifactKey& SearchArtifactsRequest::artifact_key() const {
  const ::flyteidl::core::ArtifactKey* p = artifact_key_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.SearchArtifactsRequest.artifact_key)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::ArtifactKey*>(
      &::flyteidl::core::_ArtifactKey_default_instance_);
}
inline ::flyteidl::core::ArtifactKey* SearchArtifactsRequest::release_artifact_key() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.SearchArtifactsRequest.artifact_key)
  
  ::flyteidl::core::ArtifactKey* temp = artifact_key_;
  artifact_key_ = nullptr;
  return temp;
}
inline ::flyteidl::core::ArtifactKey* SearchArtifactsRequest::mutable_artifact_key() {
  
  if (artifact_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::ArtifactKey>(GetArenaNoVirtual());
    artifact_key_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.SearchArtifactsRequest.artifact_key)
  return artifact_key_;
}
inline void SearchArtifactsRequest::set_allocated_artifact_key(::flyteidl::core::ArtifactKey* artifact_key) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(artifact_key_);
  }
  if (artifact_key) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      artifact_key = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, artifact_key, submessage_arena);
    }
    
  } else {
    
  }
  artifact_key_ = artifact_key;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.SearchArtifactsRequest.artifact_key)
}

// string filters = 2;
inline void SearchArtifactsRequest::clear_filters() {
  filters_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SearchArtifactsRequest::filters() const {
  // @@protoc_insertion_point(field_get:flyteidl.artifact.SearchArtifactsRequest.filters)
  return filters_.GetNoArena();
}
inline void SearchArtifactsRequest::set_filters(const ::std::string& value) {
  
  filters_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.artifact.SearchArtifactsRequest.filters)
}
#if LANG_CXX11
inline void SearchArtifactsRequest::set_filters(::std::string&& value) {
  
  filters_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.artifact.SearchArtifactsRequest.filters)
}
#endif
inline void SearchArtifactsRequest::set_filters(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  filters_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.artifact.SearchArtifactsRequest.filters)
}
inline void SearchArtifactsRequest::set_filters(const char* value, size_t size) {
  
  filters_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.artifact.SearchArtifactsRequest.filters)
}
inline ::std::string* SearchArtifactsRequest::mutable_filters() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.SearchArtifactsRequest.filters)
  return filters_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SearchArtifactsRequest::release_filters() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.SearchArtifactsRequest.filters)
  
  return filters_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SearchArtifactsRequest::set_allocated_filters(::std::string* filters) {
  if (filters != nullptr) {
    
  } else {
    
  }
  filters_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), filters);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.SearchArtifactsRequest.filters)
}

// string token = 3;
inline void SearchArtifactsRequest::clear_token() {
  token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SearchArtifactsRequest::token() const {
  // @@protoc_insertion_point(field_get:flyteidl.artifact.SearchArtifactsRequest.token)
  return token_.GetNoArena();
}
inline void SearchArtifactsRequest::set_token(const ::std::string& value) {
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.artifact.SearchArtifactsRequest.token)
}
#if LANG_CXX11
inline void SearchArtifactsRequest::set_token(::std::string&& value) {
  
  token_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.artifact.SearchArtifactsRequest.token)
}
#endif
inline void SearchArtifactsRequest::set_token(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.artifact.SearchArtifactsRequest.token)
}
inline void SearchArtifactsRequest::set_token(const char* value, size_t size) {
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.artifact.SearchArtifactsRequest.token)
}
inline ::std::string* SearchArtifactsRequest::mutable_token() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.SearchArtifactsRequest.token)
  return token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SearchArtifactsRequest::release_token() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.SearchArtifactsRequest.token)
  
  return token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SearchArtifactsRequest::set_allocated_token(::std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.SearchArtifactsRequest.token)
}

// int32 limit = 4;
inline void SearchArtifactsRequest::clear_limit() {
  limit_ = 0;
}
inline ::google::protobuf::int32 SearchArtifactsRequest::limit() const {
  // @@protoc_insertion_point(field_get:flyteidl.artifact.SearchArtifactsRequest.limit)
  return limit_;
}
inline void SearchArtifactsRequest::set_limit(::google::protobuf::int32 value) {
  
  limit_ = value;
  // @@protoc_insertion_point(field_set:flyteidl.artifact.SearchArtifactsRequest.limit)
}

// -------------------------------------------------------------------

// SearchArtifactsResponse

// repeated .flyteidl.artifact.Artifact artifacts = 1;
inline int SearchArtifactsResponse::artifacts_size() const {
  return artifacts_.size();
}
inline void SearchArtifactsResponse::clear_artifacts() {
  artifacts_.Clear();
}
inline ::flyteidl::artifact::Artifact* SearchArtifactsResponse::mutable_artifacts(int index) {
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.SearchArtifactsResponse.artifacts)
  return artifacts_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::flyteidl::artifact::Artifact >*
SearchArtifactsResponse::mutable_artifacts() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.artifact.SearchArtifactsResponse.artifacts)
  return &artifacts_;
}
inline const ::flyteidl::artifact::Artifact& SearchArtifactsResponse::artifacts(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.artifact.SearchArtifactsResponse.artifacts)
  return artifacts_.Get(index);
}
inline ::flyteidl::artifact::Artifact* SearchArtifactsResponse::add_artifacts() {
  // @@protoc_insertion_point(field_add:flyteidl.artifact.SearchArtifactsResponse.artifacts)
  return artifacts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::flyteidl::artifact::Artifact >&
SearchArtifactsResponse::artifacts() const {
  // @@protoc_insertion_point(field_list:flyteidl.artifact.SearchArtifactsResponse.artifacts)
  return artifacts_;
}

// -------------------------------------------------------------------

// AddTagRequest

// .flyteidl.core.ArtifactID artifact_id = 1;
inline bool AddTagRequest::has_artifact_id() const {
  return this != internal_default_instance() && artifact_id_ != nullptr;
}
inline const ::flyteidl::core::ArtifactID& AddTagRequest::artifact_id() const {
  const ::flyteidl::core::ArtifactID* p = artifact_id_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.AddTagRequest.artifact_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::ArtifactID*>(
      &::flyteidl::core::_ArtifactID_default_instance_);
}
inline ::flyteidl::core::ArtifactID* AddTagRequest::release_artifact_id() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.AddTagRequest.artifact_id)
  
  ::flyteidl::core::ArtifactID* temp = artifact_id_;
  artifact_id_ = nullptr;
  return temp;
}
inline ::flyteidl::core::ArtifactID* AddTagRequest::mutable_artifact_id() {
  
  if (artifact_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::ArtifactID>(GetArenaNoVirtual());
    artifact_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.AddTagRequest.artifact_id)
  return artifact_id_;
}
inline void AddTagRequest::set_allocated_artifact_id(::flyteidl::core::ArtifactID* artifact_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(artifact_id_);
  }
  if (artifact_id) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      artifact_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, artifact_id, submessage_arena);
    }
    
  } else {
    
  }
  artifact_id_ = artifact_id;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.AddTagRequest.artifact_id)
}

// string value = 2;
inline void AddTagRequest::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AddTagRequest::value() const {
  // @@protoc_insertion_point(field_get:flyteidl.artifact.AddTagRequest.value)
  return value_.GetNoArena();
}
inline void AddTagRequest::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:flyteidl.artifact.AddTagRequest.value)
}
#if LANG_CXX11
inline void AddTagRequest::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:flyteidl.artifact.AddTagRequest.value)
}
#endif
inline void AddTagRequest::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:flyteidl.artifact.AddTagRequest.value)
}
inline void AddTagRequest::set_value(const char* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:flyteidl.artifact.AddTagRequest.value)
}
inline ::std::string* AddTagRequest::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.AddTagRequest.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AddTagRequest::release_value() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.AddTagRequest.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AddTagRequest::set_allocated_value(::std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.AddTagRequest.value)
}

// bool overwrite = 3;
inline void AddTagRequest::clear_overwrite() {
  overwrite_ = false;
}
inline bool AddTagRequest::overwrite() const {
  // @@protoc_insertion_point(field_get:flyteidl.artifact.AddTagRequest.overwrite)
  return overwrite_;
}
inline void AddTagRequest::set_overwrite(bool value) {
  
  overwrite_ = value;
  // @@protoc_insertion_point(field_set:flyteidl.artifact.AddTagRequest.overwrite)
}

// -------------------------------------------------------------------

// AddTagResponse

// -------------------------------------------------------------------

// CreateTriggerRequest

// .flyteidl.admin.LaunchPlan trigger_launch_plan = 1;
inline bool CreateTriggerRequest::has_trigger_launch_plan() const {
  return this != internal_default_instance() && trigger_launch_plan_ != nullptr;
}
inline const ::flyteidl::admin::LaunchPlan& CreateTriggerRequest::trigger_launch_plan() const {
  const ::flyteidl::admin::LaunchPlan* p = trigger_launch_plan_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.CreateTriggerRequest.trigger_launch_plan)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::admin::LaunchPlan*>(
      &::flyteidl::admin::_LaunchPlan_default_instance_);
}
inline ::flyteidl::admin::LaunchPlan* CreateTriggerRequest::release_trigger_launch_plan() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.CreateTriggerRequest.trigger_launch_plan)
  
  ::flyteidl::admin::LaunchPlan* temp = trigger_launch_plan_;
  trigger_launch_plan_ = nullptr;
  return temp;
}
inline ::flyteidl::admin::LaunchPlan* CreateTriggerRequest::mutable_trigger_launch_plan() {
  
  if (trigger_launch_plan_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::admin::LaunchPlan>(GetArenaNoVirtual());
    trigger_launch_plan_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.CreateTriggerRequest.trigger_launch_plan)
  return trigger_launch_plan_;
}
inline void CreateTriggerRequest::set_allocated_trigger_launch_plan(::flyteidl::admin::LaunchPlan* trigger_launch_plan) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(trigger_launch_plan_);
  }
  if (trigger_launch_plan) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      trigger_launch_plan = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, trigger_launch_plan, submessage_arena);
    }
    
  } else {
    
  }
  trigger_launch_plan_ = trigger_launch_plan;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.CreateTriggerRequest.trigger_launch_plan)
}

// -------------------------------------------------------------------

// CreateTriggerResponse

// -------------------------------------------------------------------

// DeleteTriggerRequest

// .flyteidl.core.Identifier trigger_id = 1;
inline bool DeleteTriggerRequest::has_trigger_id() const {
  return this != internal_default_instance() && trigger_id_ != nullptr;
}
inline const ::flyteidl::core::Identifier& DeleteTriggerRequest::trigger_id() const {
  const ::flyteidl::core::Identifier* p = trigger_id_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.DeleteTriggerRequest.trigger_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::Identifier*>(
      &::flyteidl::core::_Identifier_default_instance_);
}
inline ::flyteidl::core::Identifier* DeleteTriggerRequest::release_trigger_id() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.DeleteTriggerRequest.trigger_id)
  
  ::flyteidl::core::Identifier* temp = trigger_id_;
  trigger_id_ = nullptr;
  return temp;
}
inline ::flyteidl::core::Identifier* DeleteTriggerRequest::mutable_trigger_id() {
  
  if (trigger_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::Identifier>(GetArenaNoVirtual());
    trigger_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.DeleteTriggerRequest.trigger_id)
  return trigger_id_;
}
inline void DeleteTriggerRequest::set_allocated_trigger_id(::flyteidl::core::Identifier* trigger_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(trigger_id_);
  }
  if (trigger_id) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      trigger_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, trigger_id, submessage_arena);
    }
    
  } else {
    
  }
  trigger_id_ = trigger_id;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.DeleteTriggerRequest.trigger_id)
}

// -------------------------------------------------------------------

// DeleteTriggerResponse

// -------------------------------------------------------------------

// ArtifactProducer

// .flyteidl.core.Identifier entity_id = 1;
inline bool ArtifactProducer::has_entity_id() const {
  return this != internal_default_instance() && entity_id_ != nullptr;
}
inline const ::flyteidl::core::Identifier& ArtifactProducer::entity_id() const {
  const ::flyteidl::core::Identifier* p = entity_id_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.ArtifactProducer.entity_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::Identifier*>(
      &::flyteidl::core::_Identifier_default_instance_);
}
inline ::flyteidl::core::Identifier* ArtifactProducer::release_entity_id() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.ArtifactProducer.entity_id)
  
  ::flyteidl::core::Identifier* temp = entity_id_;
  entity_id_ = nullptr;
  return temp;
}
inline ::flyteidl::core::Identifier* ArtifactProducer::mutable_entity_id() {
  
  if (entity_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::Identifier>(GetArenaNoVirtual());
    entity_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.ArtifactProducer.entity_id)
  return entity_id_;
}
inline void ArtifactProducer::set_allocated_entity_id(::flyteidl::core::Identifier* entity_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(entity_id_);
  }
  if (entity_id) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      entity_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, entity_id, submessage_arena);
    }
    
  } else {
    
  }
  entity_id_ = entity_id;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.ArtifactProducer.entity_id)
}

// .flyteidl.core.VariableMap outputs = 2;
inline bool ArtifactProducer::has_outputs() const {
  return this != internal_default_instance() && outputs_ != nullptr;
}
inline const ::flyteidl::core::VariableMap& ArtifactProducer::outputs() const {
  const ::flyteidl::core::VariableMap* p = outputs_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.ArtifactProducer.outputs)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::VariableMap*>(
      &::flyteidl::core::_VariableMap_default_instance_);
}
inline ::flyteidl::core::VariableMap* ArtifactProducer::release_outputs() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.ArtifactProducer.outputs)
  
  ::flyteidl::core::VariableMap* temp = outputs_;
  outputs_ = nullptr;
  return temp;
}
inline ::flyteidl::core::VariableMap* ArtifactProducer::mutable_outputs() {
  
  if (outputs_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::VariableMap>(GetArenaNoVirtual());
    outputs_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.ArtifactProducer.outputs)
  return outputs_;
}
inline void ArtifactProducer::set_allocated_outputs(::flyteidl::core::VariableMap* outputs) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(outputs_);
  }
  if (outputs) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      outputs = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, outputs, submessage_arena);
    }
    
  } else {
    
  }
  outputs_ = outputs;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.ArtifactProducer.outputs)
}

// -------------------------------------------------------------------

// RegisterProducerRequest

// repeated .flyteidl.artifact.ArtifactProducer producers = 1;
inline int RegisterProducerRequest::producers_size() const {
  return producers_.size();
}
inline void RegisterProducerRequest::clear_producers() {
  producers_.Clear();
}
inline ::flyteidl::artifact::ArtifactProducer* RegisterProducerRequest::mutable_producers(int index) {
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.RegisterProducerRequest.producers)
  return producers_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::flyteidl::artifact::ArtifactProducer >*
RegisterProducerRequest::mutable_producers() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.artifact.RegisterProducerRequest.producers)
  return &producers_;
}
inline const ::flyteidl::artifact::ArtifactProducer& RegisterProducerRequest::producers(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.artifact.RegisterProducerRequest.producers)
  return producers_.Get(index);
}
inline ::flyteidl::artifact::ArtifactProducer* RegisterProducerRequest::add_producers() {
  // @@protoc_insertion_point(field_add:flyteidl.artifact.RegisterProducerRequest.producers)
  return producers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::flyteidl::artifact::ArtifactProducer >&
RegisterProducerRequest::producers() const {
  // @@protoc_insertion_point(field_list:flyteidl.artifact.RegisterProducerRequest.producers)
  return producers_;
}

// -------------------------------------------------------------------

// ArtifactConsumer

// .flyteidl.core.Identifier entity_id = 1;
inline bool ArtifactConsumer::has_entity_id() const {
  return this != internal_default_instance() && entity_id_ != nullptr;
}
inline const ::flyteidl::core::Identifier& ArtifactConsumer::entity_id() const {
  const ::flyteidl::core::Identifier* p = entity_id_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.ArtifactConsumer.entity_id)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::Identifier*>(
      &::flyteidl::core::_Identifier_default_instance_);
}
inline ::flyteidl::core::Identifier* ArtifactConsumer::release_entity_id() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.ArtifactConsumer.entity_id)
  
  ::flyteidl::core::Identifier* temp = entity_id_;
  entity_id_ = nullptr;
  return temp;
}
inline ::flyteidl::core::Identifier* ArtifactConsumer::mutable_entity_id() {
  
  if (entity_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::Identifier>(GetArenaNoVirtual());
    entity_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.ArtifactConsumer.entity_id)
  return entity_id_;
}
inline void ArtifactConsumer::set_allocated_entity_id(::flyteidl::core::Identifier* entity_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(entity_id_);
  }
  if (entity_id) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      entity_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, entity_id, submessage_arena);
    }
    
  } else {
    
  }
  entity_id_ = entity_id;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.ArtifactConsumer.entity_id)
}

// .flyteidl.core.ParameterMap inputs = 2;
inline bool ArtifactConsumer::has_inputs() const {
  return this != internal_default_instance() && inputs_ != nullptr;
}
inline const ::flyteidl::core::ParameterMap& ArtifactConsumer::inputs() const {
  const ::flyteidl::core::ParameterMap* p = inputs_;
  // @@protoc_insertion_point(field_get:flyteidl.artifact.ArtifactConsumer.inputs)
  return p != nullptr ? *p : *reinterpret_cast<const ::flyteidl::core::ParameterMap*>(
      &::flyteidl::core::_ParameterMap_default_instance_);
}
inline ::flyteidl::core::ParameterMap* ArtifactConsumer::release_inputs() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.ArtifactConsumer.inputs)
  
  ::flyteidl::core::ParameterMap* temp = inputs_;
  inputs_ = nullptr;
  return temp;
}
inline ::flyteidl::core::ParameterMap* ArtifactConsumer::mutable_inputs() {
  
  if (inputs_ == nullptr) {
    auto* p = CreateMaybeMessage<::flyteidl::core::ParameterMap>(GetArenaNoVirtual());
    inputs_ = p;
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.ArtifactConsumer.inputs)
  return inputs_;
}
inline void ArtifactConsumer::set_allocated_inputs(::flyteidl::core::ParameterMap* inputs) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(inputs_);
  }
  if (inputs) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      inputs = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, inputs, submessage_arena);
    }
    
  } else {
    
  }
  inputs_ = inputs;
  // @@protoc_insertion_point(field_set_allocated:flyteidl.artifact.ArtifactConsumer.inputs)
}

// -------------------------------------------------------------------

// RegisterConsumerRequest

// repeated .flyteidl.artifact.ArtifactConsumer consumers = 1;
inline int RegisterConsumerRequest::consumers_size() const {
  return consumers_.size();
}
inline void RegisterConsumerRequest::clear_consumers() {
  consumers_.Clear();
}
inline ::flyteidl::artifact::ArtifactConsumer* RegisterConsumerRequest::mutable_consumers(int index) {
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.RegisterConsumerRequest.consumers)
  return consumers_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::flyteidl::artifact::ArtifactConsumer >*
RegisterConsumerRequest::mutable_consumers() {
  // @@protoc_insertion_point(field_mutable_list:flyteidl.artifact.RegisterConsumerRequest.consumers)
  return &consumers_;
}
inline const ::flyteidl::artifact::ArtifactConsumer& RegisterConsumerRequest::consumers(int index) const {
  // @@protoc_insertion_point(field_get:flyteidl.artifact.RegisterConsumerRequest.consumers)
  return consumers_.Get(index);
}
inline ::flyteidl::artifact::ArtifactConsumer* RegisterConsumerRequest::add_consumers() {
  // @@protoc_insertion_point(field_add:flyteidl.artifact.RegisterConsumerRequest.consumers)
  return consumers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::flyteidl::artifact::ArtifactConsumer >&
RegisterConsumerRequest::consumers() const {
  // @@protoc_insertion_point(field_list:flyteidl.artifact.RegisterConsumerRequest.consumers)
  return consumers_;
}

// -------------------------------------------------------------------

// RegisterResponse

// -------------------------------------------------------------------

// CloudEventRequest

// .flyteidl.event.CloudEventWorkflowExecution workflow_execution_event = 1;
inline bool CloudEventRequest::has_workflow_execution_event() const {
  return event_case() == kWorkflowExecutionEvent;
}
inline void CloudEventRequest::set_has_workflow_execution_event() {
  _oneof_case_[0] = kWorkflowExecutionEvent;
}
inline ::flyteidl::event::CloudEventWorkflowExecution* CloudEventRequest::release_workflow_execution_event() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.CloudEventRequest.workflow_execution_event)
  if (has_workflow_execution_event()) {
    clear_has_event();
      ::flyteidl::event::CloudEventWorkflowExecution* temp = event_.workflow_execution_event_;
    event_.workflow_execution_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::event::CloudEventWorkflowExecution& CloudEventRequest::workflow_execution_event() const {
  // @@protoc_insertion_point(field_get:flyteidl.artifact.CloudEventRequest.workflow_execution_event)
  return has_workflow_execution_event()
      ? *event_.workflow_execution_event_
      : *reinterpret_cast< ::flyteidl::event::CloudEventWorkflowExecution*>(&::flyteidl::event::_CloudEventWorkflowExecution_default_instance_);
}
inline ::flyteidl::event::CloudEventWorkflowExecution* CloudEventRequest::mutable_workflow_execution_event() {
  if (!has_workflow_execution_event()) {
    clear_event();
    set_has_workflow_execution_event();
    event_.workflow_execution_event_ = CreateMaybeMessage< ::flyteidl::event::CloudEventWorkflowExecution >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.CloudEventRequest.workflow_execution_event)
  return event_.workflow_execution_event_;
}

// .flyteidl.event.CloudEventTaskExecution task_execution_event = 2;
inline bool CloudEventRequest::has_task_execution_event() const {
  return event_case() == kTaskExecutionEvent;
}
inline void CloudEventRequest::set_has_task_execution_event() {
  _oneof_case_[0] = kTaskExecutionEvent;
}
inline ::flyteidl::event::CloudEventTaskExecution* CloudEventRequest::release_task_execution_event() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.CloudEventRequest.task_execution_event)
  if (has_task_execution_event()) {
    clear_has_event();
      ::flyteidl::event::CloudEventTaskExecution* temp = event_.task_execution_event_;
    event_.task_execution_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::event::CloudEventTaskExecution& CloudEventRequest::task_execution_event() const {
  // @@protoc_insertion_point(field_get:flyteidl.artifact.CloudEventRequest.task_execution_event)
  return has_task_execution_event()
      ? *event_.task_execution_event_
      : *reinterpret_cast< ::flyteidl::event::CloudEventTaskExecution*>(&::flyteidl::event::_CloudEventTaskExecution_default_instance_);
}
inline ::flyteidl::event::CloudEventTaskExecution* CloudEventRequest::mutable_task_execution_event() {
  if (!has_task_execution_event()) {
    clear_event();
    set_has_task_execution_event();
    event_.task_execution_event_ = CreateMaybeMessage< ::flyteidl::event::CloudEventTaskExecution >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.CloudEventRequest.task_execution_event)
  return event_.task_execution_event_;
}

// .flyteidl.event.CloudEventNodeExecution node_execution_event = 3;
inline bool CloudEventRequest::has_node_execution_event() const {
  return event_case() == kNodeExecutionEvent;
}
inline void CloudEventRequest::set_has_node_execution_event() {
  _oneof_case_[0] = kNodeExecutionEvent;
}
inline ::flyteidl::event::CloudEventNodeExecution* CloudEventRequest::release_node_execution_event() {
  // @@protoc_insertion_point(field_release:flyteidl.artifact.CloudEventRequest.node_execution_event)
  if (has_node_execution_event()) {
    clear_has_event();
      ::flyteidl::event::CloudEventNodeExecution* temp = event_.node_execution_event_;
    event_.node_execution_event_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::flyteidl::event::CloudEventNodeExecution& CloudEventRequest::node_execution_event() const {
  // @@protoc_insertion_point(field_get:flyteidl.artifact.CloudEventRequest.node_execution_event)
  return has_node_execution_event()
      ? *event_.node_execution_event_
      : *reinterpret_cast< ::flyteidl::event::CloudEventNodeExecution*>(&::flyteidl::event::_CloudEventNodeExecution_default_instance_);
}
inline ::flyteidl::event::CloudEventNodeExecution* CloudEventRequest::mutable_node_execution_event() {
  if (!has_node_execution_event()) {
    clear_event();
    set_has_node_execution_event();
    event_.node_execution_event_ = CreateMaybeMessage< ::flyteidl::event::CloudEventNodeExecution >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:flyteidl.artifact.CloudEventRequest.node_execution_event)
  return event_.node_execution_event_;
}

inline bool CloudEventRequest::has_event() const {
  return event_case() != EVENT_NOT_SET;
}
inline void CloudEventRequest::clear_has_event() {
  _oneof_case_[0] = EVENT_NOT_SET;
}
inline CloudEventRequest::EventCase CloudEventRequest::event_case() const {
  return CloudEventRequest::EventCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// CloudEventResponse

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace artifact
}  // namespace flyteidl

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_flyteidl_2fartifact_2fartifacts_2eproto
