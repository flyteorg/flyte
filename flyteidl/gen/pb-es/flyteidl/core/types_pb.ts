// @generated by protoc-gen-es v1.7.2 with parameter "target=ts"
// @generated from file flyteidl/core/types.proto (package flyteidl.core, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, Struct } from "@bufbuild/protobuf";

/**
 * Define a set of simple types.
 *
 * @generated from enum flyteidl.core.SimpleType
 */
export enum SimpleType {
  /**
   * @generated from enum value: NONE = 0;
   */
  NONE = 0,

  /**
   * @generated from enum value: INTEGER = 1;
   */
  INTEGER = 1,

  /**
   * @generated from enum value: FLOAT = 2;
   */
  FLOAT = 2,

  /**
   * @generated from enum value: STRING = 3;
   */
  STRING = 3,

  /**
   * @generated from enum value: BOOLEAN = 4;
   */
  BOOLEAN = 4,

  /**
   * @generated from enum value: DATETIME = 5;
   */
  DATETIME = 5,

  /**
   * @generated from enum value: DURATION = 6;
   */
  DURATION = 6,

  /**
   * @generated from enum value: BINARY = 7;
   */
  BINARY = 7,

  /**
   * @generated from enum value: ERROR = 8;
   */
  ERROR = 8,

  /**
   * @generated from enum value: STRUCT = 9;
   */
  STRUCT = 9,
}
// Retrieve enum metadata with: proto3.getEnumType(SimpleType)
proto3.util.setEnumType(SimpleType, "flyteidl.core.SimpleType", [
  { no: 0, name: "NONE" },
  { no: 1, name: "INTEGER" },
  { no: 2, name: "FLOAT" },
  { no: 3, name: "STRING" },
  { no: 4, name: "BOOLEAN" },
  { no: 5, name: "DATETIME" },
  { no: 6, name: "DURATION" },
  { no: 7, name: "BINARY" },
  { no: 8, name: "ERROR" },
  { no: 9, name: "STRUCT" },
]);

/**
 * Defines schema columns and types to strongly type-validate schemas interoperability.
 *
 * @generated from message flyteidl.core.SchemaType
 */
export class SchemaType extends Message<SchemaType> {
  /**
   * A list of ordered columns this schema comprises of.
   *
   * @generated from field: repeated flyteidl.core.SchemaType.SchemaColumn columns = 3;
   */
  columns: SchemaType_SchemaColumn[] = [];

  constructor(data?: PartialMessage<SchemaType>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.core.SchemaType";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 3, name: "columns", kind: "message", T: SchemaType_SchemaColumn, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SchemaType {
    return new SchemaType().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SchemaType {
    return new SchemaType().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SchemaType {
    return new SchemaType().fromJsonString(jsonString, options);
  }

  static equals(a: SchemaType | PlainMessage<SchemaType> | undefined, b: SchemaType | PlainMessage<SchemaType> | undefined): boolean {
    return proto3.util.equals(SchemaType, a, b);
  }
}

/**
 * @generated from message flyteidl.core.SchemaType.SchemaColumn
 */
export class SchemaType_SchemaColumn extends Message<SchemaType_SchemaColumn> {
  /**
   * A unique name -within the schema type- for the column
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * The column type. This allows a limited set of types currently.
   *
   * @generated from field: flyteidl.core.SchemaType.SchemaColumn.SchemaColumnType type = 2;
   */
  type = SchemaType_SchemaColumn_SchemaColumnType.INTEGER;

  constructor(data?: PartialMessage<SchemaType_SchemaColumn>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.core.SchemaType.SchemaColumn";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "type", kind: "enum", T: proto3.getEnumType(SchemaType_SchemaColumn_SchemaColumnType) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SchemaType_SchemaColumn {
    return new SchemaType_SchemaColumn().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SchemaType_SchemaColumn {
    return new SchemaType_SchemaColumn().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SchemaType_SchemaColumn {
    return new SchemaType_SchemaColumn().fromJsonString(jsonString, options);
  }

  static equals(a: SchemaType_SchemaColumn | PlainMessage<SchemaType_SchemaColumn> | undefined, b: SchemaType_SchemaColumn | PlainMessage<SchemaType_SchemaColumn> | undefined): boolean {
    return proto3.util.equals(SchemaType_SchemaColumn, a, b);
  }
}

/**
 * @generated from enum flyteidl.core.SchemaType.SchemaColumn.SchemaColumnType
 */
export enum SchemaType_SchemaColumn_SchemaColumnType {
  /**
   * @generated from enum value: INTEGER = 0;
   */
  INTEGER = 0,

  /**
   * @generated from enum value: FLOAT = 1;
   */
  FLOAT = 1,

  /**
   * @generated from enum value: STRING = 2;
   */
  STRING = 2,

  /**
   * @generated from enum value: BOOLEAN = 3;
   */
  BOOLEAN = 3,

  /**
   * @generated from enum value: DATETIME = 4;
   */
  DATETIME = 4,

  /**
   * @generated from enum value: DURATION = 5;
   */
  DURATION = 5,
}
// Retrieve enum metadata with: proto3.getEnumType(SchemaType_SchemaColumn_SchemaColumnType)
proto3.util.setEnumType(SchemaType_SchemaColumn_SchemaColumnType, "flyteidl.core.SchemaType.SchemaColumn.SchemaColumnType", [
  { no: 0, name: "INTEGER" },
  { no: 1, name: "FLOAT" },
  { no: 2, name: "STRING" },
  { no: 3, name: "BOOLEAN" },
  { no: 4, name: "DATETIME" },
  { no: 5, name: "DURATION" },
]);

/**
 * @generated from message flyteidl.core.StructuredDatasetType
 */
export class StructuredDatasetType extends Message<StructuredDatasetType> {
  /**
   * A list of ordered columns this schema comprises of.
   *
   * @generated from field: repeated flyteidl.core.StructuredDatasetType.DatasetColumn columns = 1;
   */
  columns: StructuredDatasetType_DatasetColumn[] = [];

  /**
   * This is the storage format, the format of the bits at rest
   * parquet, feather, csv, etc.
   * For two types to be compatible, the format will need to be an exact match.
   *
   * @generated from field: string format = 2;
   */
  format = "";

  /**
   * This is a string representing the type that the bytes in external_schema_bytes are formatted in.
   * This is an optional field that will not be used for type checking.
   *
   * @generated from field: string external_schema_type = 3;
   */
  externalSchemaType = "";

  /**
   * The serialized bytes of a third-party schema library like Arrow.
   * This is an optional field that will not be used for type checking.
   *
   * @generated from field: bytes external_schema_bytes = 4;
   */
  externalSchemaBytes = new Uint8Array(0);

  constructor(data?: PartialMessage<StructuredDatasetType>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.core.StructuredDatasetType";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "columns", kind: "message", T: StructuredDatasetType_DatasetColumn, repeated: true },
    { no: 2, name: "format", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "external_schema_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "external_schema_bytes", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StructuredDatasetType {
    return new StructuredDatasetType().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StructuredDatasetType {
    return new StructuredDatasetType().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StructuredDatasetType {
    return new StructuredDatasetType().fromJsonString(jsonString, options);
  }

  static equals(a: StructuredDatasetType | PlainMessage<StructuredDatasetType> | undefined, b: StructuredDatasetType | PlainMessage<StructuredDatasetType> | undefined): boolean {
    return proto3.util.equals(StructuredDatasetType, a, b);
  }
}

/**
 * @generated from message flyteidl.core.StructuredDatasetType.DatasetColumn
 */
export class StructuredDatasetType_DatasetColumn extends Message<StructuredDatasetType_DatasetColumn> {
  /**
   * A unique name within the schema type for the column.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * The column type.
   *
   * @generated from field: flyteidl.core.LiteralType literal_type = 2;
   */
  literalType?: LiteralType;

  constructor(data?: PartialMessage<StructuredDatasetType_DatasetColumn>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.core.StructuredDatasetType.DatasetColumn";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "literal_type", kind: "message", T: LiteralType },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StructuredDatasetType_DatasetColumn {
    return new StructuredDatasetType_DatasetColumn().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StructuredDatasetType_DatasetColumn {
    return new StructuredDatasetType_DatasetColumn().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StructuredDatasetType_DatasetColumn {
    return new StructuredDatasetType_DatasetColumn().fromJsonString(jsonString, options);
  }

  static equals(a: StructuredDatasetType_DatasetColumn | PlainMessage<StructuredDatasetType_DatasetColumn> | undefined, b: StructuredDatasetType_DatasetColumn | PlainMessage<StructuredDatasetType_DatasetColumn> | undefined): boolean {
    return proto3.util.equals(StructuredDatasetType_DatasetColumn, a, b);
  }
}

/**
 * Defines type behavior for blob objects
 *
 * @generated from message flyteidl.core.BlobType
 */
export class BlobType extends Message<BlobType> {
  /**
   * Format can be a free form string understood by SDK/UI etc like
   * csv, parquet etc
   *
   * @generated from field: string format = 1;
   */
  format = "";

  /**
   * @generated from field: flyteidl.core.BlobType.BlobDimensionality dimensionality = 2;
   */
  dimensionality = BlobType_BlobDimensionality.SINGLE;

  constructor(data?: PartialMessage<BlobType>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.core.BlobType";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "format", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "dimensionality", kind: "enum", T: proto3.getEnumType(BlobType_BlobDimensionality) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): BlobType {
    return new BlobType().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): BlobType {
    return new BlobType().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): BlobType {
    return new BlobType().fromJsonString(jsonString, options);
  }

  static equals(a: BlobType | PlainMessage<BlobType> | undefined, b: BlobType | PlainMessage<BlobType> | undefined): boolean {
    return proto3.util.equals(BlobType, a, b);
  }
}

/**
 * @generated from enum flyteidl.core.BlobType.BlobDimensionality
 */
export enum BlobType_BlobDimensionality {
  /**
   * @generated from enum value: SINGLE = 0;
   */
  SINGLE = 0,

  /**
   * @generated from enum value: MULTIPART = 1;
   */
  MULTIPART = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(BlobType_BlobDimensionality)
proto3.util.setEnumType(BlobType_BlobDimensionality, "flyteidl.core.BlobType.BlobDimensionality", [
  { no: 0, name: "SINGLE" },
  { no: 1, name: "MULTIPART" },
]);

/**
 * Enables declaring enum types, with predefined string values
 * For len(values) > 0, the first value in the ordered list is regarded as the default value. If you wish
 * To provide no defaults, make the first value as undefined.
 *
 * @generated from message flyteidl.core.EnumType
 */
export class EnumType extends Message<EnumType> {
  /**
   * Predefined set of enum values.
   *
   * @generated from field: repeated string values = 1;
   */
  values: string[] = [];

  constructor(data?: PartialMessage<EnumType>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.core.EnumType";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "values", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): EnumType {
    return new EnumType().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): EnumType {
    return new EnumType().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): EnumType {
    return new EnumType().fromJsonString(jsonString, options);
  }

  static equals(a: EnumType | PlainMessage<EnumType> | undefined, b: EnumType | PlainMessage<EnumType> | undefined): boolean {
    return proto3.util.equals(EnumType, a, b);
  }
}

/**
 * Defines a tagged union type, also known as a variant (and formally as the sum type).
 *
 * A sum type S is defined by a sequence of types (A, B, C, ...), each tagged by a string tag
 * A value of type S is constructed from a value of any of the variant types. The specific choice of type is recorded by
 * storing the varaint's tag with the literal value and can be examined in runtime.
 *
 * Type S is typically written as
 * S := Apple A | Banana B | Cantaloupe C | ...
 *
 * Notably, a nullable (optional) type is a sum type between some type X and the singleton type representing a null-value:
 * Optional X := X | Null
 *
 * See also: https://en.wikipedia.org/wiki/Tagged_union
 *
 * @generated from message flyteidl.core.UnionType
 */
export class UnionType extends Message<UnionType> {
  /**
   * Predefined set of variants in union.
   *
   * @generated from field: repeated flyteidl.core.LiteralType variants = 1;
   */
  variants: LiteralType[] = [];

  constructor(data?: PartialMessage<UnionType>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.core.UnionType";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "variants", kind: "message", T: LiteralType, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UnionType {
    return new UnionType().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UnionType {
    return new UnionType().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UnionType {
    return new UnionType().fromJsonString(jsonString, options);
  }

  static equals(a: UnionType | PlainMessage<UnionType> | undefined, b: UnionType | PlainMessage<UnionType> | undefined): boolean {
    return proto3.util.equals(UnionType, a, b);
  }
}

/**
 * Hints to improve type matching
 * e.g. allows distinguishing output from custom type transformers
 * even if the underlying IDL serialization matches.
 *
 * @generated from message flyteidl.core.TypeStructure
 */
export class TypeStructure extends Message<TypeStructure> {
  /**
   * Must exactly match for types to be castable
   *
   * @generated from field: string tag = 1;
   */
  tag = "";

  /**
   * dataclass_type only exists for dataclasses.
   * This is used to resolve the type of the fields of dataclass
   * The key is the field name, and the value is the literal type of the field
   * e.g. For dataclass Foo, with fields a, and a is a string
   * Foo.a will be resolved as a literal type of string from dataclass_type
   *
   * @generated from field: map<string, flyteidl.core.LiteralType> dataclass_type = 2;
   */
  dataclassType: { [key: string]: LiteralType } = {};

  constructor(data?: PartialMessage<TypeStructure>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.core.TypeStructure";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "tag", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "dataclass_type", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: LiteralType} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TypeStructure {
    return new TypeStructure().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TypeStructure {
    return new TypeStructure().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TypeStructure {
    return new TypeStructure().fromJsonString(jsonString, options);
  }

  static equals(a: TypeStructure | PlainMessage<TypeStructure> | undefined, b: TypeStructure | PlainMessage<TypeStructure> | undefined): boolean {
    return proto3.util.equals(TypeStructure, a, b);
  }
}

/**
 * TypeAnnotation encapsulates registration time information about a type. This can be used for various control-plane operations. TypeAnnotation will not be available at runtime when a task runs.
 *
 * @generated from message flyteidl.core.TypeAnnotation
 */
export class TypeAnnotation extends Message<TypeAnnotation> {
  /**
   * A arbitrary JSON payload to describe a type.
   *
   * @generated from field: google.protobuf.Struct annotations = 1;
   */
  annotations?: Struct;

  constructor(data?: PartialMessage<TypeAnnotation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.core.TypeAnnotation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "annotations", kind: "message", T: Struct },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TypeAnnotation {
    return new TypeAnnotation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TypeAnnotation {
    return new TypeAnnotation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TypeAnnotation {
    return new TypeAnnotation().fromJsonString(jsonString, options);
  }

  static equals(a: TypeAnnotation | PlainMessage<TypeAnnotation> | undefined, b: TypeAnnotation | PlainMessage<TypeAnnotation> | undefined): boolean {
    return proto3.util.equals(TypeAnnotation, a, b);
  }
}

/**
 * Defines a strong type to allow type checking between interfaces.
 *
 * @generated from message flyteidl.core.LiteralType
 */
export class LiteralType extends Message<LiteralType> {
  /**
   * @generated from oneof flyteidl.core.LiteralType.type
   */
  type: {
    /**
     * A simple type that can be compared one-to-one with another.
     *
     * @generated from field: flyteidl.core.SimpleType simple = 1;
     */
    value: SimpleType;
    case: "simple";
  } | {
    /**
     * A complex type that requires matching of inner fields.
     *
     * @generated from field: flyteidl.core.SchemaType schema = 2;
     */
    value: SchemaType;
    case: "schema";
  } | {
    /**
     * Defines the type of the value of a collection. Only homogeneous collections are allowed.
     *
     * @generated from field: flyteidl.core.LiteralType collection_type = 3;
     */
    value: LiteralType;
    case: "collectionType";
  } | {
    /**
     * Defines the type of the value of a map type. The type of the key is always a string.
     *
     * @generated from field: flyteidl.core.LiteralType map_value_type = 4;
     */
    value: LiteralType;
    case: "mapValueType";
  } | {
    /**
     * A blob might have specialized implementation details depending on associated metadata.
     *
     * @generated from field: flyteidl.core.BlobType blob = 5;
     */
    value: BlobType;
    case: "blob";
  } | {
    /**
     * Defines an enum with pre-defined string values.
     *
     * @generated from field: flyteidl.core.EnumType enum_type = 7;
     */
    value: EnumType;
    case: "enumType";
  } | {
    /**
     * Generalized schema support
     *
     * @generated from field: flyteidl.core.StructuredDatasetType structured_dataset_type = 8;
     */
    value: StructuredDatasetType;
    case: "structuredDatasetType";
  } | {
    /**
     * Defines an union type with pre-defined LiteralTypes.
     *
     * @generated from field: flyteidl.core.UnionType union_type = 10;
     */
    value: UnionType;
    case: "unionType";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * This field contains type metadata that is descriptive of the type, but is NOT considered in type-checking.  This might be used by
   * consumers to identify special behavior or display extended information for the type.
   *
   * @generated from field: google.protobuf.Struct metadata = 6;
   */
  metadata?: Struct;

  /**
   * This field contains arbitrary data that might have special semantic
   * meaning for the client but does not effect internal flyte behavior.
   *
   * @generated from field: flyteidl.core.TypeAnnotation annotation = 9;
   */
  annotation?: TypeAnnotation;

  /**
   * Hints to improve type matching.
   *
   * @generated from field: flyteidl.core.TypeStructure structure = 11;
   */
  structure?: TypeStructure;

  constructor(data?: PartialMessage<LiteralType>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.core.LiteralType";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "simple", kind: "enum", T: proto3.getEnumType(SimpleType), oneof: "type" },
    { no: 2, name: "schema", kind: "message", T: SchemaType, oneof: "type" },
    { no: 3, name: "collection_type", kind: "message", T: LiteralType, oneof: "type" },
    { no: 4, name: "map_value_type", kind: "message", T: LiteralType, oneof: "type" },
    { no: 5, name: "blob", kind: "message", T: BlobType, oneof: "type" },
    { no: 7, name: "enum_type", kind: "message", T: EnumType, oneof: "type" },
    { no: 8, name: "structured_dataset_type", kind: "message", T: StructuredDatasetType, oneof: "type" },
    { no: 10, name: "union_type", kind: "message", T: UnionType, oneof: "type" },
    { no: 6, name: "metadata", kind: "message", T: Struct },
    { no: 9, name: "annotation", kind: "message", T: TypeAnnotation },
    { no: 11, name: "structure", kind: "message", T: TypeStructure },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LiteralType {
    return new LiteralType().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LiteralType {
    return new LiteralType().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LiteralType {
    return new LiteralType().fromJsonString(jsonString, options);
  }

  static equals(a: LiteralType | PlainMessage<LiteralType> | undefined, b: LiteralType | PlainMessage<LiteralType> | undefined): boolean {
    return proto3.util.equals(LiteralType, a, b);
  }
}

/**
 * A reference to an output produced by a node. The type can be retrieved -and validated- from
 * the underlying interface of the node.
 *
 * @generated from message flyteidl.core.OutputReference
 */
export class OutputReference extends Message<OutputReference> {
  /**
   * Node id must exist at the graph layer.
   *
   * @generated from field: string node_id = 1;
   */
  nodeId = "";

  /**
   * Variable name must refer to an output variable for the node.
   *
   * @generated from field: string var = 2;
   */
  var = "";

  /**
   * @generated from field: repeated flyteidl.core.PromiseAttribute attr_path = 3;
   */
  attrPath: PromiseAttribute[] = [];

  constructor(data?: PartialMessage<OutputReference>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.core.OutputReference";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "node_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "var", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "attr_path", kind: "message", T: PromiseAttribute, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OutputReference {
    return new OutputReference().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OutputReference {
    return new OutputReference().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OutputReference {
    return new OutputReference().fromJsonString(jsonString, options);
  }

  static equals(a: OutputReference | PlainMessage<OutputReference> | undefined, b: OutputReference | PlainMessage<OutputReference> | undefined): boolean {
    return proto3.util.equals(OutputReference, a, b);
  }
}

/**
 * @generated from message flyteidl.core.PromiseAttribute
 */
export class PromiseAttribute extends Message<PromiseAttribute> {
  /**
   * @generated from oneof flyteidl.core.PromiseAttribute.value
   */
  value: {
    /**
     * @generated from field: string string_value = 1;
     */
    value: string;
    case: "stringValue";
  } | {
    /**
     * @generated from field: int32 int_value = 2;
     */
    value: number;
    case: "intValue";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<PromiseAttribute>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.core.PromiseAttribute";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "string_value", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "value" },
    { no: 2, name: "int_value", kind: "scalar", T: 5 /* ScalarType.INT32 */, oneof: "value" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PromiseAttribute {
    return new PromiseAttribute().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PromiseAttribute {
    return new PromiseAttribute().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PromiseAttribute {
    return new PromiseAttribute().fromJsonString(jsonString, options);
  }

  static equals(a: PromiseAttribute | PlainMessage<PromiseAttribute> | undefined, b: PromiseAttribute | PlainMessage<PromiseAttribute> | undefined): boolean {
    return proto3.util.equals(PromiseAttribute, a, b);
  }
}

/**
 * Represents an error thrown from a node.
 *
 * @generated from message flyteidl.core.Error
 */
export class Error extends Message<Error> {
  /**
   * The node id that threw the error.
   *
   * @generated from field: string failed_node_id = 1;
   */
  failedNodeId = "";

  /**
   * Error message thrown.
   *
   * @generated from field: string message = 2;
   */
  message = "";

  constructor(data?: PartialMessage<Error>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.core.Error";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "failed_node_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Error {
    return new Error().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Error {
    return new Error().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Error {
    return new Error().fromJsonString(jsonString, options);
  }

  static equals(a: Error | PlainMessage<Error> | undefined, b: Error | PlainMessage<Error> | undefined): boolean {
    return proto3.util.equals(Error, a, b);
  }
}

