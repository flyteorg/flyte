// @generated by protoc-gen-es v1.7.2 with parameter "target=ts"
// @generated from file flyteidl/core/execution.proto (package flyteidl.core, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Duration, Message, proto3 } from "@bufbuild/protobuf";

/**
 * Indicates various phases of Workflow Execution
 *
 * @generated from message flyteidl.core.WorkflowExecution
 */
export class WorkflowExecution extends Message<WorkflowExecution> {
  constructor(data?: PartialMessage<WorkflowExecution>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.core.WorkflowExecution";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): WorkflowExecution {
    return new WorkflowExecution().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): WorkflowExecution {
    return new WorkflowExecution().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): WorkflowExecution {
    return new WorkflowExecution().fromJsonString(jsonString, options);
  }

  static equals(a: WorkflowExecution | PlainMessage<WorkflowExecution> | undefined, b: WorkflowExecution | PlainMessage<WorkflowExecution> | undefined): boolean {
    return proto3.util.equals(WorkflowExecution, a, b);
  }
}

/**
 * @generated from enum flyteidl.core.WorkflowExecution.Phase
 */
export enum WorkflowExecution_Phase {
  /**
   * @generated from enum value: UNDEFINED = 0;
   */
  UNDEFINED = 0,

  /**
   * @generated from enum value: QUEUED = 1;
   */
  QUEUED = 1,

  /**
   * @generated from enum value: RUNNING = 2;
   */
  RUNNING = 2,

  /**
   * @generated from enum value: SUCCEEDING = 3;
   */
  SUCCEEDING = 3,

  /**
   * @generated from enum value: SUCCEEDED = 4;
   */
  SUCCEEDED = 4,

  /**
   * @generated from enum value: FAILING = 5;
   */
  FAILING = 5,

  /**
   * @generated from enum value: FAILED = 6;
   */
  FAILED = 6,

  /**
   * @generated from enum value: ABORTED = 7;
   */
  ABORTED = 7,

  /**
   * @generated from enum value: TIMED_OUT = 8;
   */
  TIMED_OUT = 8,

  /**
   * @generated from enum value: ABORTING = 9;
   */
  ABORTING = 9,
}
// Retrieve enum metadata with: proto3.getEnumType(WorkflowExecution_Phase)
proto3.util.setEnumType(WorkflowExecution_Phase, "flyteidl.core.WorkflowExecution.Phase", [
  { no: 0, name: "UNDEFINED" },
  { no: 1, name: "QUEUED" },
  { no: 2, name: "RUNNING" },
  { no: 3, name: "SUCCEEDING" },
  { no: 4, name: "SUCCEEDED" },
  { no: 5, name: "FAILING" },
  { no: 6, name: "FAILED" },
  { no: 7, name: "ABORTED" },
  { no: 8, name: "TIMED_OUT" },
  { no: 9, name: "ABORTING" },
]);

/**
 * Indicates various phases of Node Execution that only include the time spent to run the nodes/workflows
 *
 * @generated from message flyteidl.core.NodeExecution
 */
export class NodeExecution extends Message<NodeExecution> {
  constructor(data?: PartialMessage<NodeExecution>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.core.NodeExecution";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NodeExecution {
    return new NodeExecution().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NodeExecution {
    return new NodeExecution().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NodeExecution {
    return new NodeExecution().fromJsonString(jsonString, options);
  }

  static equals(a: NodeExecution | PlainMessage<NodeExecution> | undefined, b: NodeExecution | PlainMessage<NodeExecution> | undefined): boolean {
    return proto3.util.equals(NodeExecution, a, b);
  }
}

/**
 * @generated from enum flyteidl.core.NodeExecution.Phase
 */
export enum NodeExecution_Phase {
  /**
   * @generated from enum value: UNDEFINED = 0;
   */
  UNDEFINED = 0,

  /**
   * @generated from enum value: QUEUED = 1;
   */
  QUEUED = 1,

  /**
   * @generated from enum value: RUNNING = 2;
   */
  RUNNING = 2,

  /**
   * @generated from enum value: SUCCEEDED = 3;
   */
  SUCCEEDED = 3,

  /**
   * @generated from enum value: FAILING = 4;
   */
  FAILING = 4,

  /**
   * @generated from enum value: FAILED = 5;
   */
  FAILED = 5,

  /**
   * @generated from enum value: ABORTED = 6;
   */
  ABORTED = 6,

  /**
   * @generated from enum value: SKIPPED = 7;
   */
  SKIPPED = 7,

  /**
   * @generated from enum value: TIMED_OUT = 8;
   */
  TIMED_OUT = 8,

  /**
   * @generated from enum value: DYNAMIC_RUNNING = 9;
   */
  DYNAMIC_RUNNING = 9,

  /**
   * @generated from enum value: RECOVERED = 10;
   */
  RECOVERED = 10,
}
// Retrieve enum metadata with: proto3.getEnumType(NodeExecution_Phase)
proto3.util.setEnumType(NodeExecution_Phase, "flyteidl.core.NodeExecution.Phase", [
  { no: 0, name: "UNDEFINED" },
  { no: 1, name: "QUEUED" },
  { no: 2, name: "RUNNING" },
  { no: 3, name: "SUCCEEDED" },
  { no: 4, name: "FAILING" },
  { no: 5, name: "FAILED" },
  { no: 6, name: "ABORTED" },
  { no: 7, name: "SKIPPED" },
  { no: 8, name: "TIMED_OUT" },
  { no: 9, name: "DYNAMIC_RUNNING" },
  { no: 10, name: "RECOVERED" },
]);

/**
 * Phases that task plugins can go through. Not all phases may be applicable to a specific plugin task,
 * but this is the cumulative list that customers may want to know about for their task.
 *
 * @generated from message flyteidl.core.TaskExecution
 */
export class TaskExecution extends Message<TaskExecution> {
  constructor(data?: PartialMessage<TaskExecution>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.core.TaskExecution";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TaskExecution {
    return new TaskExecution().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TaskExecution {
    return new TaskExecution().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TaskExecution {
    return new TaskExecution().fromJsonString(jsonString, options);
  }

  static equals(a: TaskExecution | PlainMessage<TaskExecution> | undefined, b: TaskExecution | PlainMessage<TaskExecution> | undefined): boolean {
    return proto3.util.equals(TaskExecution, a, b);
  }
}

/**
 * @generated from enum flyteidl.core.TaskExecution.Phase
 */
export enum TaskExecution_Phase {
  /**
   * @generated from enum value: UNDEFINED = 0;
   */
  UNDEFINED = 0,

  /**
   * @generated from enum value: QUEUED = 1;
   */
  QUEUED = 1,

  /**
   * @generated from enum value: RUNNING = 2;
   */
  RUNNING = 2,

  /**
   * @generated from enum value: SUCCEEDED = 3;
   */
  SUCCEEDED = 3,

  /**
   * @generated from enum value: ABORTED = 4;
   */
  ABORTED = 4,

  /**
   * @generated from enum value: FAILED = 5;
   */
  FAILED = 5,

  /**
   * To indicate cases where task is initializing, like: ErrImagePull, ContainerCreating, PodInitializing
   *
   * @generated from enum value: INITIALIZING = 6;
   */
  INITIALIZING = 6,

  /**
   * To address cases, where underlying resource is not available: Backoff error, Resource quota exceeded
   *
   * @generated from enum value: WAITING_FOR_RESOURCES = 7;
   */
  WAITING_FOR_RESOURCES = 7,
}
// Retrieve enum metadata with: proto3.getEnumType(TaskExecution_Phase)
proto3.util.setEnumType(TaskExecution_Phase, "flyteidl.core.TaskExecution.Phase", [
  { no: 0, name: "UNDEFINED" },
  { no: 1, name: "QUEUED" },
  { no: 2, name: "RUNNING" },
  { no: 3, name: "SUCCEEDED" },
  { no: 4, name: "ABORTED" },
  { no: 5, name: "FAILED" },
  { no: 6, name: "INITIALIZING" },
  { no: 7, name: "WAITING_FOR_RESOURCES" },
]);

/**
 * Represents the error message from the execution.
 *
 * @generated from message flyteidl.core.ExecutionError
 */
export class ExecutionError extends Message<ExecutionError> {
  /**
   * Error code indicates a grouping of a type of error.
   * More Info: <Link>
   *
   * @generated from field: string code = 1;
   */
  code = "";

  /**
   * Detailed description of the error - including stack trace.
   *
   * @generated from field: string message = 2;
   */
  message = "";

  /**
   * Full error contents accessible via a URI
   *
   * @generated from field: string error_uri = 3;
   */
  errorUri = "";

  /**
   * @generated from field: flyteidl.core.ExecutionError.ErrorKind kind = 4;
   */
  kind = ExecutionError_ErrorKind.UNKNOWN;

  constructor(data?: PartialMessage<ExecutionError>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.core.ExecutionError";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "code", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "error_uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "kind", kind: "enum", T: proto3.getEnumType(ExecutionError_ErrorKind) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExecutionError {
    return new ExecutionError().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExecutionError {
    return new ExecutionError().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExecutionError {
    return new ExecutionError().fromJsonString(jsonString, options);
  }

  static equals(a: ExecutionError | PlainMessage<ExecutionError> | undefined, b: ExecutionError | PlainMessage<ExecutionError> | undefined): boolean {
    return proto3.util.equals(ExecutionError, a, b);
  }
}

/**
 * Error type: System or User
 *
 * @generated from enum flyteidl.core.ExecutionError.ErrorKind
 */
export enum ExecutionError_ErrorKind {
  /**
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * @generated from enum value: USER = 1;
   */
  USER = 1,

  /**
   * @generated from enum value: SYSTEM = 2;
   */
  SYSTEM = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(ExecutionError_ErrorKind)
proto3.util.setEnumType(ExecutionError_ErrorKind, "flyteidl.core.ExecutionError.ErrorKind", [
  { no: 0, name: "UNKNOWN" },
  { no: 1, name: "USER" },
  { no: 2, name: "SYSTEM" },
]);

/**
 * Log information for the task that is specific to a log sink
 * When our log story is flushed out, we may have more metadata here like log link expiry
 *
 * @generated from message flyteidl.core.TaskLog
 */
export class TaskLog extends Message<TaskLog> {
  /**
   * @generated from field: string uri = 1;
   */
  uri = "";

  /**
   * @generated from field: string name = 2;
   */
  name = "";

  /**
   * @generated from field: flyteidl.core.TaskLog.MessageFormat message_format = 3;
   */
  messageFormat = TaskLog_MessageFormat.UNKNOWN;

  /**
   * @generated from field: google.protobuf.Duration ttl = 4;
   */
  ttl?: Duration;

  /**
   * @generated from field: bool ShowWhilePending = 5;
   */
  ShowWhilePending = false;

  constructor(data?: PartialMessage<TaskLog>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.core.TaskLog";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "uri", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "message_format", kind: "enum", T: proto3.getEnumType(TaskLog_MessageFormat) },
    { no: 4, name: "ttl", kind: "message", T: Duration },
    { no: 5, name: "ShowWhilePending", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TaskLog {
    return new TaskLog().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TaskLog {
    return new TaskLog().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TaskLog {
    return new TaskLog().fromJsonString(jsonString, options);
  }

  static equals(a: TaskLog | PlainMessage<TaskLog> | undefined, b: TaskLog | PlainMessage<TaskLog> | undefined): boolean {
    return proto3.util.equals(TaskLog, a, b);
  }
}

/**
 * @generated from enum flyteidl.core.TaskLog.MessageFormat
 */
export enum TaskLog_MessageFormat {
  /**
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * @generated from enum value: CSV = 1;
   */
  CSV = 1,

  /**
   * @generated from enum value: JSON = 2;
   */
  JSON = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(TaskLog_MessageFormat)
proto3.util.setEnumType(TaskLog_MessageFormat, "flyteidl.core.TaskLog.MessageFormat", [
  { no: 0, name: "UNKNOWN" },
  { no: 1, name: "CSV" },
  { no: 2, name: "JSON" },
]);

/**
 * Represents customized execution run-time attributes.
 *
 * @generated from message flyteidl.core.QualityOfServiceSpec
 */
export class QualityOfServiceSpec extends Message<QualityOfServiceSpec> {
  /**
   * Indicates how much queueing delay an execution can tolerate.
   *
   * @generated from field: google.protobuf.Duration queueing_budget = 1;
   */
  queueingBudget?: Duration;

  constructor(data?: PartialMessage<QualityOfServiceSpec>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.core.QualityOfServiceSpec";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "queueing_budget", kind: "message", T: Duration },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QualityOfServiceSpec {
    return new QualityOfServiceSpec().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QualityOfServiceSpec {
    return new QualityOfServiceSpec().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QualityOfServiceSpec {
    return new QualityOfServiceSpec().fromJsonString(jsonString, options);
  }

  static equals(a: QualityOfServiceSpec | PlainMessage<QualityOfServiceSpec> | undefined, b: QualityOfServiceSpec | PlainMessage<QualityOfServiceSpec> | undefined): boolean {
    return proto3.util.equals(QualityOfServiceSpec, a, b);
  }
}

/**
 * Indicates the priority of an execution.
 *
 * @generated from message flyteidl.core.QualityOfService
 */
export class QualityOfService extends Message<QualityOfService> {
  /**
   * @generated from oneof flyteidl.core.QualityOfService.designation
   */
  designation: {
    /**
     * @generated from field: flyteidl.core.QualityOfService.Tier tier = 1;
     */
    value: QualityOfService_Tier;
    case: "tier";
  } | {
    /**
     * @generated from field: flyteidl.core.QualityOfServiceSpec spec = 2;
     */
    value: QualityOfServiceSpec;
    case: "spec";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<QualityOfService>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.core.QualityOfService";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "tier", kind: "enum", T: proto3.getEnumType(QualityOfService_Tier), oneof: "designation" },
    { no: 2, name: "spec", kind: "message", T: QualityOfServiceSpec, oneof: "designation" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QualityOfService {
    return new QualityOfService().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QualityOfService {
    return new QualityOfService().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QualityOfService {
    return new QualityOfService().fromJsonString(jsonString, options);
  }

  static equals(a: QualityOfService | PlainMessage<QualityOfService> | undefined, b: QualityOfService | PlainMessage<QualityOfService> | undefined): boolean {
    return proto3.util.equals(QualityOfService, a, b);
  }
}

/**
 * @generated from enum flyteidl.core.QualityOfService.Tier
 */
export enum QualityOfService_Tier {
  /**
   * Default: no quality of service specified.
   *
   * @generated from enum value: UNDEFINED = 0;
   */
  UNDEFINED = 0,

  /**
   * @generated from enum value: HIGH = 1;
   */
  HIGH = 1,

  /**
   * @generated from enum value: MEDIUM = 2;
   */
  MEDIUM = 2,

  /**
   * @generated from enum value: LOW = 3;
   */
  LOW = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(QualityOfService_Tier)
proto3.util.setEnumType(QualityOfService_Tier, "flyteidl.core.QualityOfService.Tier", [
  { no: 0, name: "UNDEFINED" },
  { no: 1, name: "HIGH" },
  { no: 2, name: "MEDIUM" },
  { no: 3, name: "LOW" },
]);

