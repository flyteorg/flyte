// @generated by protoc-gen-es v1.7.2 with parameter "target=ts"
// @generated from file flyteidl/cacheservice/cacheservice.proto (package flyteidl.cacheservice, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Duration, Message, proto3, Timestamp } from "@bufbuild/protobuf";
import { Identifier } from "../core/identifier_pb.js";
import { LiteralMap } from "../core/literals_pb.js";

/**
 *
 * Additional metadata as key-value pairs
 *
 * @generated from message flyteidl.cacheservice.KeyMapMetadata
 */
export class KeyMapMetadata extends Message<KeyMapMetadata> {
  /**
   * Additional metadata as key-value pairs
   *
   * @generated from field: map<string, string> values = 1;
   */
  values: { [key: string]: string } = {};

  constructor(data?: PartialMessage<KeyMapMetadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.cacheservice.KeyMapMetadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "values", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): KeyMapMetadata {
    return new KeyMapMetadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): KeyMapMetadata {
    return new KeyMapMetadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): KeyMapMetadata {
    return new KeyMapMetadata().fromJsonString(jsonString, options);
  }

  static equals(a: KeyMapMetadata | PlainMessage<KeyMapMetadata> | undefined, b: KeyMapMetadata | PlainMessage<KeyMapMetadata> | undefined): boolean {
    return proto3.util.equals(KeyMapMetadata, a, b);
  }
}

/**
 *
 * Metadata for cached outputs, including the source identifier and timestamps.
 *
 * @generated from message flyteidl.cacheservice.Metadata
 */
export class Metadata extends Message<Metadata> {
  /**
   * Source task or workflow identifier
   *
   * @generated from field: flyteidl.core.Identifier source_identifier = 1;
   */
  sourceIdentifier?: Identifier;

  /**
   * Additional metadata as key-value pairs
   *
   * @generated from field: flyteidl.cacheservice.KeyMapMetadata key_map = 2;
   */
  keyMap?: KeyMapMetadata;

  /**
   * Creation timestamp
   *
   * @generated from field: google.protobuf.Timestamp created_at = 3;
   */
  createdAt?: Timestamp;

  /**
   * Last update timestamp
   *
   * @generated from field: google.protobuf.Timestamp last_updated_at = 4;
   */
  lastUpdatedAt?: Timestamp;

  constructor(data?: PartialMessage<Metadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.cacheservice.Metadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "source_identifier", kind: "message", T: Identifier },
    { no: 2, name: "key_map", kind: "message", T: KeyMapMetadata },
    { no: 3, name: "created_at", kind: "message", T: Timestamp },
    { no: 4, name: "last_updated_at", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Metadata {
    return new Metadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Metadata {
    return new Metadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Metadata {
    return new Metadata().fromJsonString(jsonString, options);
  }

  static equals(a: Metadata | PlainMessage<Metadata> | undefined, b: Metadata | PlainMessage<Metadata> | undefined): boolean {
    return proto3.util.equals(Metadata, a, b);
  }
}

/**
 *
 * Represents cached output, either as literals or an URI, with associated metadata.
 *
 * @generated from message flyteidl.cacheservice.CachedOutput
 */
export class CachedOutput extends Message<CachedOutput> {
  /**
   * @generated from oneof flyteidl.cacheservice.CachedOutput.output
   */
  output: {
    /**
     * Output literals
     *
     * @generated from field: flyteidl.core.LiteralMap output_literals = 1;
     */
    value: LiteralMap;
    case: "outputLiterals";
  } | {
    /**
     * URI to output data
     *
     * @generated from field: string output_uri = 2;
     */
    value: string;
    case: "outputUri";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * Associated metadata
   *
   * @generated from field: flyteidl.cacheservice.Metadata metadata = 3;
   */
  metadata?: Metadata;

  constructor(data?: PartialMessage<CachedOutput>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.cacheservice.CachedOutput";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "output_literals", kind: "message", T: LiteralMap, oneof: "output" },
    { no: 2, name: "output_uri", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "output" },
    { no: 3, name: "metadata", kind: "message", T: Metadata },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CachedOutput {
    return new CachedOutput().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CachedOutput {
    return new CachedOutput().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CachedOutput {
    return new CachedOutput().fromJsonString(jsonString, options);
  }

  static equals(a: CachedOutput | PlainMessage<CachedOutput> | undefined, b: CachedOutput | PlainMessage<CachedOutput> | undefined): boolean {
    return proto3.util.equals(CachedOutput, a, b);
  }
}

/**
 *
 * Request to retrieve cached data by key.
 *
 * @generated from message flyteidl.cacheservice.GetCacheRequest
 */
export class GetCacheRequest extends Message<GetCacheRequest> {
  /**
   * Cache key
   *
   * @generated from field: string key = 1;
   */
  key = "";

  constructor(data?: PartialMessage<GetCacheRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.cacheservice.GetCacheRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetCacheRequest {
    return new GetCacheRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetCacheRequest {
    return new GetCacheRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetCacheRequest {
    return new GetCacheRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetCacheRequest | PlainMessage<GetCacheRequest> | undefined, b: GetCacheRequest | PlainMessage<GetCacheRequest> | undefined): boolean {
    return proto3.util.equals(GetCacheRequest, a, b);
  }
}

/**
 *
 * Response with cached data for a given key.
 *
 * @generated from message flyteidl.cacheservice.GetCacheResponse
 */
export class GetCacheResponse extends Message<GetCacheResponse> {
  /**
   * Cached output
   *
   * @generated from field: flyteidl.cacheservice.CachedOutput output = 1;
   */
  output?: CachedOutput;

  constructor(data?: PartialMessage<GetCacheResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.cacheservice.GetCacheResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "output", kind: "message", T: CachedOutput },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetCacheResponse {
    return new GetCacheResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetCacheResponse {
    return new GetCacheResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetCacheResponse {
    return new GetCacheResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetCacheResponse | PlainMessage<GetCacheResponse> | undefined, b: GetCacheResponse | PlainMessage<GetCacheResponse> | undefined): boolean {
    return proto3.util.equals(GetCacheResponse, a, b);
  }
}

/**
 *
 * Request to store/update cached data by key.
 *
 * @generated from message flyteidl.cacheservice.PutCacheRequest
 */
export class PutCacheRequest extends Message<PutCacheRequest> {
  /**
   * Cache key
   *
   * @generated from field: string key = 1;
   */
  key = "";

  /**
   * Output to cache
   *
   * @generated from field: flyteidl.cacheservice.CachedOutput output = 2;
   */
  output?: CachedOutput;

  /**
   * Overwrite flag
   *
   * @generated from field: bool overwrite = 3;
   */
  overwrite = false;

  constructor(data?: PartialMessage<PutCacheRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.cacheservice.PutCacheRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "output", kind: "message", T: CachedOutput },
    { no: 3, name: "overwrite", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PutCacheRequest {
    return new PutCacheRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PutCacheRequest {
    return new PutCacheRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PutCacheRequest {
    return new PutCacheRequest().fromJsonString(jsonString, options);
  }

  static equals(a: PutCacheRequest | PlainMessage<PutCacheRequest> | undefined, b: PutCacheRequest | PlainMessage<PutCacheRequest> | undefined): boolean {
    return proto3.util.equals(PutCacheRequest, a, b);
  }
}

/**
 *
 * Response message of cache store/update operation.
 *
 * Empty, success indicated by no errors
 *
 * @generated from message flyteidl.cacheservice.PutCacheResponse
 */
export class PutCacheResponse extends Message<PutCacheResponse> {
  constructor(data?: PartialMessage<PutCacheResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.cacheservice.PutCacheResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PutCacheResponse {
    return new PutCacheResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PutCacheResponse {
    return new PutCacheResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PutCacheResponse {
    return new PutCacheResponse().fromJsonString(jsonString, options);
  }

  static equals(a: PutCacheResponse | PlainMessage<PutCacheResponse> | undefined, b: PutCacheResponse | PlainMessage<PutCacheResponse> | undefined): boolean {
    return proto3.util.equals(PutCacheResponse, a, b);
  }
}

/**
 *
 * Request to delete cached data by key.
 *
 * @generated from message flyteidl.cacheservice.DeleteCacheRequest
 */
export class DeleteCacheRequest extends Message<DeleteCacheRequest> {
  /**
   * Cache key
   *
   * @generated from field: string key = 1;
   */
  key = "";

  constructor(data?: PartialMessage<DeleteCacheRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.cacheservice.DeleteCacheRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteCacheRequest {
    return new DeleteCacheRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteCacheRequest {
    return new DeleteCacheRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteCacheRequest {
    return new DeleteCacheRequest().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteCacheRequest | PlainMessage<DeleteCacheRequest> | undefined, b: DeleteCacheRequest | PlainMessage<DeleteCacheRequest> | undefined): boolean {
    return proto3.util.equals(DeleteCacheRequest, a, b);
  }
}

/**
 *
 * Response message of cache deletion operation.
 *
 * Empty, success indicated by no errors
 *
 * @generated from message flyteidl.cacheservice.DeleteCacheResponse
 */
export class DeleteCacheResponse extends Message<DeleteCacheResponse> {
  constructor(data?: PartialMessage<DeleteCacheResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.cacheservice.DeleteCacheResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DeleteCacheResponse {
    return new DeleteCacheResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DeleteCacheResponse {
    return new DeleteCacheResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DeleteCacheResponse {
    return new DeleteCacheResponse().fromJsonString(jsonString, options);
  }

  static equals(a: DeleteCacheResponse | PlainMessage<DeleteCacheResponse> | undefined, b: DeleteCacheResponse | PlainMessage<DeleteCacheResponse> | undefined): boolean {
    return proto3.util.equals(DeleteCacheResponse, a, b);
  }
}

/**
 * A reservation including owner, heartbeat interval, expiration timestamp, and various metadata.
 *
 * @generated from message flyteidl.cacheservice.Reservation
 */
export class Reservation extends Message<Reservation> {
  /**
   * The unique ID for the reservation - same as the cache key
   *
   * @generated from field: string key = 1;
   */
  key = "";

  /**
   * The unique ID of the owner for the reservation
   *
   * @generated from field: string owner_id = 2;
   */
  ownerId = "";

  /**
   * Requested reservation extension heartbeat interval
   *
   * @generated from field: google.protobuf.Duration heartbeat_interval = 3;
   */
  heartbeatInterval?: Duration;

  /**
   * Expiration timestamp of this reservation
   *
   * @generated from field: google.protobuf.Timestamp expires_at = 4;
   */
  expiresAt?: Timestamp;

  constructor(data?: PartialMessage<Reservation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.cacheservice.Reservation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "owner_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "heartbeat_interval", kind: "message", T: Duration },
    { no: 4, name: "expires_at", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Reservation {
    return new Reservation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Reservation {
    return new Reservation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Reservation {
    return new Reservation().fromJsonString(jsonString, options);
  }

  static equals(a: Reservation | PlainMessage<Reservation> | undefined, b: Reservation | PlainMessage<Reservation> | undefined): boolean {
    return proto3.util.equals(Reservation, a, b);
  }
}

/**
 *
 * Request to get or extend a reservation for a cache key
 *
 * @generated from message flyteidl.cacheservice.GetOrExtendReservationRequest
 */
export class GetOrExtendReservationRequest extends Message<GetOrExtendReservationRequest> {
  /**
   * The unique ID for the reservation - same as the cache key
   *
   * @generated from field: string key = 1;
   */
  key = "";

  /**
   * The unique ID of the owner for the reservation
   *
   * @generated from field: string owner_id = 2;
   */
  ownerId = "";

  /**
   * Requested reservation extension heartbeat interval
   *
   * @generated from field: google.protobuf.Duration heartbeat_interval = 3;
   */
  heartbeatInterval?: Duration;

  constructor(data?: PartialMessage<GetOrExtendReservationRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.cacheservice.GetOrExtendReservationRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "owner_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "heartbeat_interval", kind: "message", T: Duration },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetOrExtendReservationRequest {
    return new GetOrExtendReservationRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetOrExtendReservationRequest {
    return new GetOrExtendReservationRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetOrExtendReservationRequest {
    return new GetOrExtendReservationRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetOrExtendReservationRequest | PlainMessage<GetOrExtendReservationRequest> | undefined, b: GetOrExtendReservationRequest | PlainMessage<GetOrExtendReservationRequest> | undefined): boolean {
    return proto3.util.equals(GetOrExtendReservationRequest, a, b);
  }
}

/**
 *
 * Request to get or extend a reservation for a cache key
 *
 * @generated from message flyteidl.cacheservice.GetOrExtendReservationResponse
 */
export class GetOrExtendReservationResponse extends Message<GetOrExtendReservationResponse> {
  /**
   * The reservation that was created or extended
   *
   * @generated from field: flyteidl.cacheservice.Reservation reservation = 1;
   */
  reservation?: Reservation;

  constructor(data?: PartialMessage<GetOrExtendReservationResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.cacheservice.GetOrExtendReservationResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "reservation", kind: "message", T: Reservation },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetOrExtendReservationResponse {
    return new GetOrExtendReservationResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetOrExtendReservationResponse {
    return new GetOrExtendReservationResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetOrExtendReservationResponse {
    return new GetOrExtendReservationResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetOrExtendReservationResponse | PlainMessage<GetOrExtendReservationResponse> | undefined, b: GetOrExtendReservationResponse | PlainMessage<GetOrExtendReservationResponse> | undefined): boolean {
    return proto3.util.equals(GetOrExtendReservationResponse, a, b);
  }
}

/**
 *
 * Request to release the reservation for a cache key
 *
 * @generated from message flyteidl.cacheservice.ReleaseReservationRequest
 */
export class ReleaseReservationRequest extends Message<ReleaseReservationRequest> {
  /**
   * The unique ID for the reservation - same as the cache key
   *
   * @generated from field: string key = 1;
   */
  key = "";

  /**
   * The unique ID of the owner for the reservation
   *
   * @generated from field: string owner_id = 2;
   */
  ownerId = "";

  constructor(data?: PartialMessage<ReleaseReservationRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.cacheservice.ReleaseReservationRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "owner_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReleaseReservationRequest {
    return new ReleaseReservationRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReleaseReservationRequest {
    return new ReleaseReservationRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReleaseReservationRequest {
    return new ReleaseReservationRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ReleaseReservationRequest | PlainMessage<ReleaseReservationRequest> | undefined, b: ReleaseReservationRequest | PlainMessage<ReleaseReservationRequest> | undefined): boolean {
    return proto3.util.equals(ReleaseReservationRequest, a, b);
  }
}

/**
 *
 * Response message of release reservation operation.
 *
 * Empty, success indicated by no errors
 *
 * @generated from message flyteidl.cacheservice.ReleaseReservationResponse
 */
export class ReleaseReservationResponse extends Message<ReleaseReservationResponse> {
  constructor(data?: PartialMessage<ReleaseReservationResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "flyteidl.cacheservice.ReleaseReservationResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ReleaseReservationResponse {
    return new ReleaseReservationResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ReleaseReservationResponse {
    return new ReleaseReservationResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ReleaseReservationResponse {
    return new ReleaseReservationResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ReleaseReservationResponse | PlainMessage<ReleaseReservationResponse> | undefined, b: ReleaseReservationResponse | PlainMessage<ReleaseReservationResponse> | undefined): boolean {
    return proto3.util.equals(ReleaseReservationResponse, a, b);
  }
}

