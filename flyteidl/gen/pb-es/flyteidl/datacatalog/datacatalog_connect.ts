// @generated by protoc-gen-connect-es v1.3.0 with parameter "target=ts"
// @generated from file flyteidl/datacatalog/datacatalog.proto (package datacatalog, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import { AddTagRequest, AddTagResponse, CreateArtifactRequest, CreateArtifactResponse, CreateDatasetRequest, CreateDatasetResponse, GetArtifactRequest, GetArtifactResponse, GetDatasetRequest, GetDatasetResponse, GetOrExtendReservationRequest, GetOrExtendReservationResponse, ListArtifactsRequest, ListArtifactsResponse, ListDatasetsRequest, ListDatasetsResponse, ReleaseReservationRequest, ReleaseReservationResponse, UpdateArtifactRequest, UpdateArtifactResponse } from "./datacatalog_pb.js";
import { MethodKind } from "@bufbuild/protobuf";

/**
 *
 * Data Catalog service definition
 * Data Catalog is a service for indexing parameterized, strongly-typed data artifacts across revisions.
 * Artifacts are associated with a Dataset, and can be tagged for retrieval.
 *
 * @generated from service datacatalog.DataCatalog
 */
export const DataCatalog = {
  typeName: "datacatalog.DataCatalog",
  methods: {
    /**
     * Create a new Dataset. Datasets are unique based on the DatasetID. Datasets are logical groupings of artifacts.
     * Each dataset can have one or more artifacts
     *
     * @generated from rpc datacatalog.DataCatalog.CreateDataset
     */
    createDataset: {
      name: "CreateDataset",
      I: CreateDatasetRequest,
      O: CreateDatasetResponse,
      kind: MethodKind.Unary,
    },
    /**
     * Get a Dataset by the DatasetID. This returns the Dataset with the associated metadata.
     *
     * @generated from rpc datacatalog.DataCatalog.GetDataset
     */
    getDataset: {
      name: "GetDataset",
      I: GetDatasetRequest,
      O: GetDatasetResponse,
      kind: MethodKind.Unary,
    },
    /**
     * Create an artifact and the artifact data associated with it. An artifact can be a hive partition or arbitrary
     * files or data values
     *
     * @generated from rpc datacatalog.DataCatalog.CreateArtifact
     */
    createArtifact: {
      name: "CreateArtifact",
      I: CreateArtifactRequest,
      O: CreateArtifactResponse,
      kind: MethodKind.Unary,
    },
    /**
     * Retrieve an artifact by an identifying handle. This returns an artifact along with the artifact data.
     *
     * @generated from rpc datacatalog.DataCatalog.GetArtifact
     */
    getArtifact: {
      name: "GetArtifact",
      I: GetArtifactRequest,
      O: GetArtifactResponse,
      kind: MethodKind.Unary,
    },
    /**
     * Associate a tag with an artifact. Tags are unique within a Dataset.
     *
     * @generated from rpc datacatalog.DataCatalog.AddTag
     */
    addTag: {
      name: "AddTag",
      I: AddTagRequest,
      O: AddTagResponse,
      kind: MethodKind.Unary,
    },
    /**
     * Return a paginated list of artifacts
     *
     * @generated from rpc datacatalog.DataCatalog.ListArtifacts
     */
    listArtifacts: {
      name: "ListArtifacts",
      I: ListArtifactsRequest,
      O: ListArtifactsResponse,
      kind: MethodKind.Unary,
    },
    /**
     * Return a paginated list of datasets
     *
     * @generated from rpc datacatalog.DataCatalog.ListDatasets
     */
    listDatasets: {
      name: "ListDatasets",
      I: ListDatasetsRequest,
      O: ListDatasetsResponse,
      kind: MethodKind.Unary,
    },
    /**
     * Updates an existing artifact, overwriting the stored artifact data in the underlying blob storage.
     *
     * @generated from rpc datacatalog.DataCatalog.UpdateArtifact
     */
    updateArtifact: {
      name: "UpdateArtifact",
      I: UpdateArtifactRequest,
      O: UpdateArtifactResponse,
      kind: MethodKind.Unary,
    },
    /**
     * Attempts to get or extend a reservation for the corresponding artifact. If one already exists
     * (ie. another entity owns the reservation) then that reservation is retrieved.
     * Once you acquire a reservation, you need to  periodically extend the reservation with an
     * identical call. If the reservation is not extended before the defined expiration, it may be
     * acquired by another task.
     * Note: We may have multiple concurrent tasks with the same signature and the same input that
     * try to populate the same artifact at the same time. Thus with reservation, only one task can
     * run at a time, until the reservation expires.
     * Note: If task A does not extend the reservation in time and the reservation expires, another
     * task B may take over the reservation, resulting in two tasks A and B running in parallel. So
     * a third task C may get the Artifact from A or B, whichever writes last.
     *
     * @generated from rpc datacatalog.DataCatalog.GetOrExtendReservation
     */
    getOrExtendReservation: {
      name: "GetOrExtendReservation",
      I: GetOrExtendReservationRequest,
      O: GetOrExtendReservationResponse,
      kind: MethodKind.Unary,
    },
    /**
     * Release the reservation when the task holding the spot fails so that the other tasks
     * can grab the spot.
     *
     * @generated from rpc datacatalog.DataCatalog.ReleaseReservation
     */
    releaseReservation: {
      name: "ReleaseReservation",
      I: ReleaseReservationRequest,
      O: ReleaseReservationResponse,
      kind: MethodKind.Unary,
    },
  }
} as const;

