{
  "swagger": "2.0",
  "info": {
    "title": "flyteidl/service/agent.proto",
    "version": "version not set"
  },
  "tags": [
    {
      "name": "SyncAgentService"
    },
    {
      "name": "AsyncAgentService"
    },
    {
      "name": "AgentMetadataService"
    }
  ],
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "paths": {
    "/api/v1/agent/task": {
      "post": {
        "summary": "CreateTask sends a task create request to the agent service.",
        "operationId": "AsyncAgentService_CreateTask",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/adminCreateTaskResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "description": "Represents a request structure to create task.",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/adminCreateTaskRequest"
            }
          }
        ],
        "tags": [
          "AsyncAgentService"
        ]
      }
    },
    "/api/v1/agent/task/logs/{task_category.name}/{task_category.version}/{resource_meta}": {
      "get": {
        "summary": "GetTaskLogs returns task execution logs, if available.",
        "operationId": "AsyncAgentService_GetTaskLogs",
        "responses": {
          "200": {
            "description": "A successful response.(streaming responses)",
            "schema": {
              "type": "object",
              "properties": {
                "result": {
                  "$ref": "#/definitions/adminGetTaskLogsResponse"
                },
                "error": {
                  "$ref": "#/definitions/googlerpcStatus"
                }
              },
              "title": "Stream result of adminGetTaskLogsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "task_category.name",
            "description": "The name of the task type.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "task_category.version",
            "description": "The version of the task type.",
            "in": "path",
            "required": true,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "resource_meta",
            "description": "Metadata is created by the agent. It could be a string (jobId) or a dict (more complex metadata).",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "task_type",
            "description": "A predefined yet extensible Task type identifier.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "lines",
            "description": "Number of lines to return.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "uint64"
          },
          {
            "name": "token",
            "description": "In the case of multiple pages of results, the server-provided token can be used to fetch the next page\nin a query. If there are no more results, this value will be empty.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "AsyncAgentService"
        ]
      }
    },
    "/api/v1/agent/task/metrics/{task_category.name}/{task_category.version}/{resource_meta}": {
      "get": {
        "summary": "GetTaskMetrics returns one or more task execution metrics, if available.",
        "description": "Errors include\n * OutOfRange if metrics are not available for the specified task time range\n * various other errors",
        "operationId": "AsyncAgentService_GetTaskMetrics",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/adminGetTaskMetricsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "task_category.name",
            "description": "The name of the task type.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "task_category.version",
            "description": "The version of the task type.",
            "in": "path",
            "required": true,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "resource_meta",
            "description": "Metadata is created by the agent. It could be a string (jobId) or a dict (more complex metadata).",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "task_type",
            "description": "A predefined yet extensible Task type identifier.",
            "in": "query",
            "required": false,
            "type": "string"
          },
          {
            "name": "queries",
            "description": "The metrics to query. If empty, will return a default set of metrics.\ne.g. EXECUTION_METRIC_USED_CPU_AVG or EXECUTION_METRIC_USED_MEMORY_BYTES_AVG",
            "in": "query",
            "required": false,
            "type": "array",
            "items": {
              "type": "string"
            },
            "collectionFormat": "multi"
          },
          {
            "name": "start_time",
            "description": "Start timestamp, inclusive.",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "date-time"
          },
          {
            "name": "end_time",
            "description": "End timestamp, inclusive..",
            "in": "query",
            "required": false,
            "type": "string",
            "format": "date-time"
          },
          {
            "name": "step",
            "description": "Query resolution step width in duration format or float number of seconds.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "AsyncAgentService"
        ]
      }
    },
    "/api/v1/agent/task/stream": {
      "post": {
        "summary": "ExecuteTaskSync streams the create request and inputs to the agent service and streams the outputs back.",
        "operationId": "SyncAgentService_ExecuteTaskSync",
        "responses": {
          "200": {
            "description": "A successful response.(streaming responses)",
            "schema": {
              "type": "object",
              "properties": {
                "result": {
                  "$ref": "#/definitions/adminExecuteTaskSyncResponse"
                },
                "error": {
                  "$ref": "#/definitions/googlerpcStatus"
                }
              },
              "title": "Stream result of adminExecuteTaskSyncResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "description": " (streaming inputs)",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/adminExecuteTaskSyncRequest"
            }
          }
        ],
        "tags": [
          "SyncAgentService"
        ]
      }
    },
    "/api/v1/agent/task/{task_category.name}/{task_category.version}/{resource_meta}": {
      "get": {
        "summary": "Get job status.",
        "operationId": "AsyncAgentService_GetTask",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/adminGetTaskResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "task_category.name",
            "description": "The name of the task type.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "task_category.version",
            "description": "The version of the task type.",
            "in": "path",
            "required": true,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "resource_meta",
            "description": "Metadata about the resource to be pass to the agent.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "task_type",
            "description": "A predefined yet extensible Task type identifier.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "AsyncAgentService"
        ]
      }
    },
    "/api/v1/agent/task_executions/{task_category.name}/{task_category.version}/{resource_meta}": {
      "delete": {
        "summary": "Delete the task resource.",
        "operationId": "AsyncAgentService_DeleteTask",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/adminDeleteTaskResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "task_category.name",
            "description": "The name of the task type.",
            "in": "path",
            "required": true,
            "type": "string"
          },
          {
            "name": "task_category.version",
            "description": "The version of the task type.",
            "in": "path",
            "required": true,
            "type": "integer",
            "format": "int32"
          },
          {
            "name": "resource_meta",
            "description": "Metadata about the resource to be pass to the agent.",
            "in": "path",
            "required": true,
            "type": "string",
            "format": "byte"
          },
          {
            "name": "task_type",
            "description": "A predefined yet extensible Task type identifier.",
            "in": "query",
            "required": false,
            "type": "string"
          }
        ],
        "tags": [
          "AsyncAgentService"
        ]
      }
    },
    "/api/v1/agent/{name}": {
      "get": {
        "summary": "Fetch a :ref:`ref_flyteidl.admin.Agent` definition.",
        "operationId": "AgentMetadataService_GetAgent",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/adminGetAgentResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "parameters": [
          {
            "name": "name",
            "description": "The name of the agent.",
            "in": "path",
            "required": true,
            "type": "string"
          }
        ],
        "tags": [
          "AgentMetadataService"
        ]
      }
    },
    "/api/v1/agents": {
      "get": {
        "summary": "Fetch a list of :ref:`ref_flyteidl.admin.Agent` definitions.",
        "operationId": "AgentMetadataService_ListAgents",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/adminListAgentsResponse"
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "schema": {
              "$ref": "#/definitions/googlerpcStatus"
            }
          }
        },
        "tags": [
          "AgentMetadataService"
        ]
      }
    }
  },
  "definitions": {
    "BlobTypeBlobDimensionality": {
      "type": "string",
      "enum": [
        "SINGLE",
        "MULTIPART"
      ],
      "default": "SINGLE"
    },
    "ContainerArchitecture": {
      "type": "string",
      "enum": [
        "UNKNOWN",
        "AMD64",
        "ARM64",
        "ARM_V6",
        "ARM_V7"
      ],
      "default": "UNKNOWN",
      "description": "Architecture-type the container image supports."
    },
    "DataLoadingConfigLiteralMapFormat": {
      "type": "string",
      "enum": [
        "JSON",
        "YAML",
        "PROTO"
      ],
      "default": "JSON",
      "description": "- JSON: JSON / YAML for the metadata (which contains inlined primitive values). The representation is inline with the standard json specification as specified - https://www.json.org/json-en.html\n - PROTO: Proto is a serialized binary of `core.LiteralMap` defined in flyteidl/core",
      "title": "LiteralMapFormat decides the encoding format in which the input metadata should be made available to the containers.\nIf the user has access to the protocol buffer definitions, it is recommended to use the PROTO format.\nJSON and YAML do not need any protobuf definitions to read it\nAll remote references in core.LiteralMap are replaced with local filesystem references (the data is downloaded to local filesystem)"
    },
    "IOStrategyDownloadMode": {
      "type": "string",
      "enum": [
        "DOWNLOAD_EAGER",
        "DOWNLOAD_STREAM",
        "DO_NOT_DOWNLOAD"
      ],
      "default": "DOWNLOAD_EAGER",
      "description": "- DOWNLOAD_EAGER: All data will be downloaded before the main container is executed\n - DOWNLOAD_STREAM: Data will be downloaded as a stream and an End-Of-Stream marker will be written to indicate all data has been downloaded. Refer to protocol for details\n - DO_NOT_DOWNLOAD: Large objects (offloaded) will not be downloaded",
      "title": "Mode to use for downloading"
    },
    "IOStrategyUploadMode": {
      "type": "string",
      "enum": [
        "UPLOAD_ON_EXIT",
        "UPLOAD_EAGER",
        "DO_NOT_UPLOAD"
      ],
      "default": "UPLOAD_ON_EXIT",
      "description": "- UPLOAD_ON_EXIT: All data will be uploaded after the main container exits\n - UPLOAD_EAGER: Data will be uploaded as it appears. Refer to protocol specification for details\n - DO_NOT_UPLOAD: Data will not be uploaded, only references will be written",
      "title": "Mode to use for uploading"
    },
    "ResourcesResourceEntry": {
      "type": "object",
      "properties": {
        "name": {
          "$ref": "#/definitions/ResourcesResourceName",
          "description": "Resource name."
        },
        "value": {
          "type": "string",
          "title": "Value must be a valid k8s quantity. See\nhttps://github.com/kubernetes/apimachinery/blob/master/pkg/api/resource/quantity.go#L30-L80"
        }
      },
      "description": "Encapsulates a resource name and value."
    },
    "ResourcesResourceName": {
      "type": "string",
      "enum": [
        "UNKNOWN",
        "CPU",
        "GPU",
        "MEMORY",
        "STORAGE",
        "EPHEMERAL_STORAGE"
      ],
      "default": "UNKNOWN",
      "description": "Known resource names.\n\n - EPHEMERAL_STORAGE: For Kubernetes-based deployments, pods use ephemeral local storage for scratch space, caching, and for logs."
    },
    "RuntimeMetadataRuntimeType": {
      "type": "string",
      "enum": [
        "OTHER",
        "FLYTE_SDK"
      ],
      "default": "OTHER"
    },
    "SchemaColumnSchemaColumnType": {
      "type": "string",
      "enum": [
        "INTEGER",
        "FLOAT",
        "STRING",
        "BOOLEAN",
        "DATETIME",
        "DURATION"
      ],
      "default": "INTEGER"
    },
    "SchemaTypeSchemaColumn": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "title": "A unique name -within the schema type- for the column"
        },
        "type": {
          "$ref": "#/definitions/SchemaColumnSchemaColumnType",
          "description": "The column type. This allows a limited set of types currently."
        }
      }
    },
    "SecretMountType": {
      "type": "string",
      "enum": [
        "ANY",
        "ENV_VAR",
        "FILE"
      ],
      "default": "ANY",
      "description": " - ANY: Default case, indicates the client can tolerate either mounting options.\n - ENV_VAR: ENV_VAR indicates the secret needs to be mounted as an environment variable.\n - FILE: FILE indicates the secret needs to be mounted as a file."
    },
    "SqlDialect": {
      "type": "string",
      "enum": [
        "UNDEFINED",
        "ANSI",
        "HIVE",
        "OTHER"
      ],
      "default": "UNDEFINED",
      "description": "The dialect of the SQL statement. This is used to validate and parse SQL statements at compilation time to avoid\nexpensive runtime operations. If set to an unsupported dialect, no validation will be done on the statement.\nWe support the following dialect: ansi, hive."
    },
    "StructuredDatasetTypeDatasetColumn": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "A unique name within the schema type for the column."
        },
        "literal_type": {
          "$ref": "#/definitions/coreLiteralType",
          "description": "The column type."
        }
      }
    },
    "TaskLogMessageFormat": {
      "type": "string",
      "enum": [
        "UNKNOWN",
        "CSV",
        "JSON"
      ],
      "default": "UNKNOWN"
    },
    "adminAgent": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "Name is the developer-assigned name of the agent."
        },
        "supported_task_types": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "SupportedTaskTypes are the types of the tasks that the agent can handle."
        },
        "is_sync": {
          "type": "boolean",
          "description": "IsSync indicates whether this agent is a sync agent. Sync agents are expected to return their\nresults synchronously when called by propeller. Given that sync agents can affect the performance\nof the system, it's important to enforce strict timeout policies.\nAn Async agent, on the other hand, is required to be able to identify jobs by an\nidentifier and query for job statuses as jobs progress."
        },
        "supported_task_categories": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/adminTaskCategory"
          },
          "description": "Supported_task_categories are the categories of the tasks that the agent can handle."
        }
      },
      "description": "A message containing the agent metadata."
    },
    "adminCreateRequestHeader": {
      "type": "object",
      "properties": {
        "template": {
          "$ref": "#/definitions/coreTaskTemplate",
          "description": "Template of the task that encapsulates all the metadata of the task."
        },
        "output_prefix": {
          "type": "string",
          "title": "Prefix for where task output data will be written. (e.g. s3://my-bucket/randomstring)"
        },
        "task_execution_metadata": {
          "$ref": "#/definitions/flyteidladminTaskExecutionMetadata",
          "description": "subset of runtime task execution metadata."
        },
        "max_dataset_size_bytes": {
          "type": "string",
          "format": "int64",
          "description": "MaxDatasetSizeBytes is the maximum size of the dataset that can be generated by the task."
        }
      }
    },
    "adminCreateTaskRequest": {
      "type": "object",
      "properties": {
        "inputs": {
          "$ref": "#/definitions/coreLiteralMap",
          "title": "The inputs required to start the execution. All required inputs must be\nincluded in this map. If not required and not provided, defaults apply.\n+optional"
        },
        "template": {
          "$ref": "#/definitions/coreTaskTemplate",
          "description": "Template of the task that encapsulates all the metadata of the task."
        },
        "output_prefix": {
          "type": "string",
          "title": "Prefix for where task output data will be written. (e.g. s3://my-bucket/randomstring)"
        },
        "task_execution_metadata": {
          "$ref": "#/definitions/flyteidladminTaskExecutionMetadata",
          "description": "subset of runtime task execution metadata."
        }
      },
      "description": "Represents a request structure to create task."
    },
    "adminCreateTaskResponse": {
      "type": "object",
      "properties": {
        "resource_meta": {
          "type": "string",
          "format": "byte",
          "description": "ResourceMeta is created by the agent. It could be a string (jobId) or a dict (more complex metadata)."
        }
      },
      "description": "Represents a create response structure."
    },
    "adminDeleteTaskResponse": {
      "type": "object",
      "description": "Response to delete a task."
    },
    "adminExecuteTaskSyncRequest": {
      "type": "object",
      "properties": {
        "header": {
          "$ref": "#/definitions/adminCreateRequestHeader"
        },
        "inputs": {
          "$ref": "#/definitions/coreLiteralMap"
        }
      }
    },
    "adminExecuteTaskSyncResponse": {
      "type": "object",
      "properties": {
        "header": {
          "$ref": "#/definitions/adminExecuteTaskSyncResponseHeader"
        },
        "outputs": {
          "$ref": "#/definitions/coreLiteralMap"
        }
      }
    },
    "adminExecuteTaskSyncResponseHeader": {
      "type": "object",
      "properties": {
        "resource": {
          "$ref": "#/definitions/adminResource"
        }
      }
    },
    "adminGetAgentResponse": {
      "type": "object",
      "properties": {
        "agent": {
          "$ref": "#/definitions/adminAgent"
        }
      },
      "description": "A response containing an agent."
    },
    "adminGetTaskLogsResponse": {
      "type": "object",
      "properties": {
        "header": {
          "$ref": "#/definitions/adminGetTaskLogsResponseHeader"
        },
        "body": {
          "$ref": "#/definitions/adminGetTaskLogsResponseBody"
        }
      },
      "description": "A response containing the logs for a task execution."
    },
    "adminGetTaskLogsResponseBody": {
      "type": "object",
      "properties": {
        "results": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "The execution log results."
        }
      }
    },
    "adminGetTaskLogsResponseHeader": {
      "type": "object",
      "properties": {
        "token": {
          "type": "string",
          "description": "In the case of multiple pages of results, the server-provided token can be used to fetch the next page\nin a query. If there are no more results, this value will be empty."
        }
      }
    },
    "adminGetTaskMetricsResponse": {
      "type": "object",
      "properties": {
        "results": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/coreExecutionMetricResult"
          },
          "description": "The execution metric results."
        }
      },
      "description": "A response containing a list of metrics for a task execution."
    },
    "adminGetTaskResponse": {
      "type": "object",
      "properties": {
        "resource": {
          "$ref": "#/definitions/adminResource"
        }
      },
      "description": "Response to get an individual task resource."
    },
    "adminListAgentsResponse": {
      "type": "object",
      "properties": {
        "agents": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/adminAgent"
          }
        }
      },
      "description": "A response containing a list of agents."
    },
    "adminResource": {
      "type": "object",
      "properties": {
        "state": {
          "$ref": "#/definitions/flyteidladminState",
          "description": "DEPRECATED. The state of the execution is used to control its visibility in the UI/CLI."
        },
        "outputs": {
          "$ref": "#/definitions/coreLiteralMap",
          "title": "The outputs of the execution. It's typically used by sql task. Agent service will create a\nStructured dataset pointing to the query result table.\n+optional"
        },
        "message": {
          "type": "string",
          "description": "A descriptive message for the current state. e.g. waiting for cluster."
        },
        "log_links": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/coreTaskLog"
          },
          "description": "log information for the task execution."
        },
        "phase": {
          "$ref": "#/definitions/coreTaskExecutionPhase",
          "description": "The phase of the execution is used to determine the phase of the plugin's execution."
        },
        "custom_info": {
          "type": "object",
          "description": "Custom data specific to the agent."
        }
      }
    },
    "adminTaskCategory": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "description": "The name of the task type."
        },
        "version": {
          "type": "integer",
          "format": "int32",
          "description": "The version of the task type."
        }
      }
    },
    "coreArtifactBindingData": {
      "type": "object",
      "properties": {
        "partition_key": {
          "type": "string"
        },
        "bind_to_time_partition": {
          "type": "boolean"
        },
        "time_transform": {
          "$ref": "#/definitions/coreTimeTransform",
          "title": "This is only relevant in the time partition case"
        }
      },
      "title": "Only valid for triggers"
    },
    "coreArtifactID": {
      "type": "object",
      "properties": {
        "artifact_key": {
          "$ref": "#/definitions/coreArtifactKey"
        },
        "version": {
          "type": "string"
        },
        "partitions": {
          "$ref": "#/definitions/corePartitions",
          "description": "Think of a partition as a tag on an Artifact, except it's a key-value pair.\nDifferent partitions naturally have different versions (execution ids)."
        },
        "time_partition": {
          "$ref": "#/definitions/coreTimePartition",
          "description": "There is no such thing as an empty time partition - if it's not set, then there is no time partition."
        }
      }
    },
    "coreArtifactKey": {
      "type": "object",
      "properties": {
        "project": {
          "type": "string",
          "description": "Project and domain and suffix needs to be unique across a given artifact store."
        },
        "domain": {
          "type": "string"
        },
        "name": {
          "type": "string"
        },
        "org": {
          "type": "string"
        }
      }
    },
    "coreArtifactTag": {
      "type": "object",
      "properties": {
        "artifact_key": {
          "$ref": "#/definitions/coreArtifactKey"
        },
        "value": {
          "$ref": "#/definitions/coreLabelValue"
        }
      }
    },
    "coreBinary": {
      "type": "object",
      "properties": {
        "value": {
          "type": "string",
          "format": "byte"
        },
        "tag": {
          "type": "string"
        }
      },
      "description": "A simple byte array with a tag to help different parts of the system communicate about what is in the byte array.\nIt's strongly advisable that consumers of this type define a unique tag and validate the tag before parsing the data."
    },
    "coreBlob": {
      "type": "object",
      "properties": {
        "metadata": {
          "$ref": "#/definitions/coreBlobMetadata"
        },
        "uri": {
          "type": "string"
        }
      },
      "description": "Refers to an offloaded set of files. It encapsulates the type of the store and a unique uri for where the data is.\nThere are no restrictions on how the uri is formatted since it will depend on how to interact with the store."
    },
    "coreBlobMetadata": {
      "type": "object",
      "properties": {
        "type": {
          "$ref": "#/definitions/coreBlobType"
        }
      }
    },
    "coreBlobType": {
      "type": "object",
      "properties": {
        "format": {
          "type": "string",
          "title": "Format can be a free form string understood by SDK/UI etc like\ncsv, parquet etc"
        },
        "dimensionality": {
          "$ref": "#/definitions/BlobTypeBlobDimensionality"
        }
      },
      "title": "Defines type behavior for blob objects"
    },
    "coreContainer": {
      "type": "object",
      "properties": {
        "image": {
          "type": "string",
          "title": "Container image url. Eg: docker/redis:latest"
        },
        "command": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Command to be executed, if not provided, the default entrypoint in the container image will be used."
        },
        "args": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "These will default to Flyte given paths. If provided, the system will not append known paths. If the task still\nneeds flyte's inputs and outputs path, add $(FLYTE_INPUT_FILE), $(FLYTE_OUTPUT_FILE) wherever makes sense and the\nsystem will populate these before executing the container."
        },
        "resources": {
          "$ref": "#/definitions/coreResources",
          "description": "Container resources requirement as specified by the container engine."
        },
        "env": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/flyteidlcoreKeyValuePair"
          },
          "description": "Environment variables will be set as the container is starting up."
        },
        "config": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/flyteidlcoreKeyValuePair"
          },
          "description": "Allows extra configs to be available for the container.\nTODO: elaborate on how configs will become available.\nDeprecated, please use TaskTemplate.config instead."
        },
        "ports": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/coreContainerPort"
          },
          "title": "Ports to open in the container. This feature is not supported by all execution engines. (e.g. supported on K8s but\nnot supported on AWS Batch)\nOnly K8s"
        },
        "data_config": {
          "$ref": "#/definitions/coreDataLoadingConfig",
          "title": "BETA: Optional configuration for DataLoading. If not specified, then default values are used.\nThis makes it possible to to run a completely portable container, that uses inputs and outputs\nonly from the local file-system and without having any reference to flyteidl. This is supported only on K8s at the moment.\nIf data loading is enabled, then data will be mounted in accompanying directories specified in the DataLoadingConfig. If the directories\nare not specified, inputs will be mounted onto and outputs will be uploaded from a pre-determined file-system path. Refer to the documentation\nto understand the default paths.\nOnly K8s"
        },
        "architecture": {
          "$ref": "#/definitions/ContainerArchitecture"
        }
      }
    },
    "coreContainerPort": {
      "type": "object",
      "properties": {
        "container_port": {
          "type": "integer",
          "format": "int64",
          "description": "Number of port to expose on the pod's IP address.\nThis must be a valid port number, 0 \u003c x \u003c 65536."
        }
      },
      "description": "Defines port properties for a container."
    },
    "coreDataLoadingConfig": {
      "type": "object",
      "properties": {
        "enabled": {
          "type": "boolean",
          "title": "Flag enables DataLoading Config. If this is not set, data loading will not be used!"
        },
        "input_path": {
          "type": "string",
          "title": "File system path (start at root). This folder will contain all the inputs exploded to a separate file.\nExample, if the input interface needs (x: int, y: blob, z: multipart_blob) and the input path is '/var/flyte/inputs', then the file system will look like\n/var/flyte/inputs/inputs.\u003cmetadata format dependent -\u003e .pb .json .yaml\u003e -\u003e Format as defined previously. The Blob and Multipart blob will reference local filesystem instead of remote locations\n/var/flyte/inputs/x -\u003e X is a file that contains the value of x (integer) in string format\n/var/flyte/inputs/y -\u003e Y is a file in Binary format\n/var/flyte/inputs/z/... -\u003e Note Z itself is a directory\nMore information about the protocol - refer to docs #TODO reference docs here"
        },
        "output_path": {
          "type": "string",
          "title": "File system path (start at root). This folder should contain all the outputs for the task as individual files and/or an error text file"
        },
        "format": {
          "$ref": "#/definitions/DataLoadingConfigLiteralMapFormat",
          "title": "In the inputs folder, there will be an additional summary/metadata file that contains references to all files or inlined primitive values.\nThis format decides the actual encoding for the data. Refer to the encoding to understand the specifics of the contents and the encoding"
        },
        "io_strategy": {
          "$ref": "#/definitions/coreIOStrategy"
        }
      },
      "description": "This configuration allows executing raw containers in Flyte using the Flyte CoPilot system.\nFlyte CoPilot, eliminates the needs of flytekit or sdk inside the container. Any inputs required by the users container are side-loaded in the input_path\nAny outputs generated by the user container - within output_path are automatically uploaded."
    },
    "coreError": {
      "type": "object",
      "properties": {
        "failed_node_id": {
          "type": "string",
          "description": "The node id that threw the error."
        },
        "message": {
          "type": "string",
          "description": "Error message thrown."
        }
      },
      "description": "Represents an error thrown from a node."
    },
    "coreExecutionMetricResult": {
      "type": "object",
      "properties": {
        "metric": {
          "type": "string",
          "description": "The metric this data represents. e.g. EXECUTION_METRIC_USED_CPU_AVG or EXECUTION_METRIC_USED_MEMORY_BYTES_AVG."
        },
        "data": {
          "type": "object",
          "title": "The result data in prometheus range query result format\nhttps://prometheus.io/docs/prometheus/latest/querying/api/#expression-query-result-formats.\nThis may include multiple time series, differentiated by their metric labels.\nStart time is greater of (execution attempt start, 48h ago)\nEnd time is lesser of (execution attempt end, now)"
        }
      },
      "description": "ExecutionMetrics is a collection of metrics that are collected during the execution of a Flyte task."
    },
    "coreExtendedResources": {
      "type": "object",
      "properties": {
        "gpu_accelerator": {
          "$ref": "#/definitions/coreGPUAccelerator",
          "description": "GPU accelerator to select for task. Contains information about device type, and\nfor multi-instance GPUs, the partition size to use."
        }
      },
      "description": "Encapsulates all non-standard resources, not captured by v1.ResourceRequirements, to\nallocate to a task."
    },
    "coreGPUAccelerator": {
      "type": "object",
      "properties": {
        "device": {
          "type": "string",
          "description": "This can be any arbitrary string, and should be informed by the labels or taints\nassociated with the nodes in question. Default cloud provider labels typically\nuse the following values: `nvidia-tesla-t4`, `nvidia-tesla-a100`, etc."
        },
        "unpartitioned": {
          "type": "boolean"
        },
        "partition_size": {
          "type": "string",
          "description": "Like `device`, this can be any arbitrary string, and should be informed by\nthe labels or taints associated with the nodes in question. Default cloud\nprovider labels typically use the following values: `1g.5gb`, `2g.10gb`, etc."
        }
      },
      "description": "Metadata associated with the GPU accelerator to allocate to a task. Contains\ninformation about device type, and for multi-instance GPUs, the partition size to\nuse."
    },
    "coreGranularity": {
      "type": "string",
      "enum": [
        "UNSET",
        "MINUTE",
        "HOUR",
        "DAY",
        "MONTH"
      ],
      "default": "UNSET",
      "title": "- DAY: default"
    },
    "coreIOStrategy": {
      "type": "object",
      "properties": {
        "download_mode": {
          "$ref": "#/definitions/IOStrategyDownloadMode",
          "title": "Mode to use to manage downloads"
        },
        "upload_mode": {
          "$ref": "#/definitions/IOStrategyUploadMode",
          "title": "Mode to use to manage uploads"
        }
      },
      "title": "Strategy to use when dealing with Blob, Schema, or multipart blob data (large datasets)"
    },
    "coreIdentifier": {
      "type": "object",
      "properties": {
        "resource_type": {
          "$ref": "#/definitions/coreResourceType",
          "description": "Identifies the specific type of resource that this identifier corresponds to."
        },
        "project": {
          "type": "string",
          "description": "Name of the project the resource belongs to."
        },
        "domain": {
          "type": "string",
          "description": "Name of the domain the resource belongs to.\nA domain can be considered as a subset within a specific project."
        },
        "name": {
          "type": "string",
          "description": "User provided value for the resource."
        },
        "version": {
          "type": "string",
          "description": "Specific version of the resource."
        },
        "org": {
          "type": "string",
          "description": "Optional, org key applied to the resource."
        }
      },
      "description": "Encapsulation of fields that uniquely identifies a Flyte resource."
    },
    "coreIdentity": {
      "type": "object",
      "properties": {
        "iam_role": {
          "type": "string",
          "description": "iam_role references the fully qualified name of Identity \u0026 Access Management role to impersonate."
        },
        "k8s_service_account": {
          "type": "string",
          "description": "k8s_service_account references a kubernetes service account to impersonate."
        },
        "oauth2_client": {
          "$ref": "#/definitions/coreOAuth2Client",
          "description": "oauth2_client references an oauth2 client. Backend plugins can use this information to impersonate the client when\nmaking external calls."
        },
        "execution_identity": {
          "type": "string",
          "title": "execution_identity references the subject who makes the execution"
        }
      },
      "description": "Identity encapsulates the various security identities a task can run as. It's up to the underlying plugin to pick the\nright identity for the execution environment."
    },
    "coreInputBindingData": {
      "type": "object",
      "properties": {
        "var": {
          "type": "string"
        }
      }
    },
    "coreK8sObjectMetadata": {
      "type": "object",
      "properties": {
        "labels": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Optional labels to add to the pod definition."
        },
        "annotations": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Optional annotations to add to the pod definition."
        }
      },
      "description": "Metadata for building a kubernetes object when a task is executed."
    },
    "coreK8sPod": {
      "type": "object",
      "properties": {
        "metadata": {
          "$ref": "#/definitions/coreK8sObjectMetadata",
          "description": "Contains additional metadata for building a kubernetes pod."
        },
        "pod_spec": {
          "type": "object",
          "title": "Defines the primary pod spec created when a task is executed.\nThis should be a JSON-marshalled pod spec, which can be defined in\n- go, using: https://github.com/kubernetes/api/blob/release-1.21/core/v1/types.go#L2936\n- python: using https://github.com/kubernetes-client/python/blob/release-19.0/kubernetes/client/models/v1_pod_spec.py"
        },
        "data_config": {
          "$ref": "#/definitions/coreDataLoadingConfig",
          "title": "BETA: Optional configuration for DataLoading. If not specified, then default values are used.\nThis makes it possible to to run a completely portable container, that uses inputs and outputs\nonly from the local file-system and without having any reference to flytekit. This is supported only on K8s at the moment.\nIf data loading is enabled, then data will be mounted in accompanying directories specified in the DataLoadingConfig. If the directories\nare not specified, inputs will be mounted onto and outputs will be uploaded from a pre-determined file-system path. Refer to the documentation\nto understand the default paths.\nOnly K8s"
        }
      },
      "description": "Defines a pod spec and additional pod metadata that is created when a task is executed."
    },
    "coreLabelValue": {
      "type": "object",
      "properties": {
        "static_value": {
          "type": "string",
          "title": "The string static value is for use in the Partitions object"
        },
        "time_value": {
          "type": "string",
          "format": "date-time",
          "title": "The time value is for use in the TimePartition case"
        },
        "triggered_binding": {
          "$ref": "#/definitions/coreArtifactBindingData"
        },
        "input_binding": {
          "$ref": "#/definitions/coreInputBindingData"
        },
        "runtime_binding": {
          "$ref": "#/definitions/coreRuntimeBinding"
        }
      }
    },
    "coreLiteral": {
      "type": "object",
      "properties": {
        "scalar": {
          "$ref": "#/definitions/coreScalar",
          "description": "A simple value."
        },
        "collection": {
          "$ref": "#/definitions/coreLiteralCollection",
          "description": "A collection of literals to allow nesting."
        },
        "map": {
          "$ref": "#/definitions/coreLiteralMap",
          "description": "A map of strings to literals."
        },
        "hash": {
          "type": "string",
          "title": "A hash representing this literal.\nThis is used for caching purposes. For more details refer to RFC 1893\n(https://github.com/flyteorg/flyte/blob/master/rfc/system/1893-caching-of-offloaded-objects.md)"
        },
        "metadata": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Additional metadata for literals."
        },
        "uri": {
          "type": "string",
          "description": "If this literal is offloaded, this field will contain metadata including the offload location."
        },
        "size_bytes": {
          "type": "string",
          "format": "uint64",
          "description": "Includes information about the size of the literal."
        }
      },
      "description": "A simple value. This supports any level of nesting (e.g. array of array of array of Blobs) as well as simple primitives."
    },
    "coreLiteralCollection": {
      "type": "object",
      "properties": {
        "literals": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/coreLiteral"
          }
        }
      },
      "description": "A collection of literals. This is a workaround since oneofs in proto messages cannot contain a repeated field."
    },
    "coreLiteralMap": {
      "type": "object",
      "properties": {
        "literals": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/coreLiteral"
          }
        }
      },
      "description": "A map of literals. This is a workaround since oneofs in proto messages cannot contain a repeated field."
    },
    "coreLiteralType": {
      "type": "object",
      "properties": {
        "simple": {
          "$ref": "#/definitions/coreSimpleType",
          "description": "A simple type that can be compared one-to-one with another."
        },
        "schema": {
          "$ref": "#/definitions/coreSchemaType",
          "description": "A complex type that requires matching of inner fields."
        },
        "collection_type": {
          "$ref": "#/definitions/coreLiteralType",
          "description": "Defines the type of the value of a collection. Only homogeneous collections are allowed."
        },
        "map_value_type": {
          "$ref": "#/definitions/coreLiteralType",
          "description": "Defines the type of the value of a map type. The type of the key is always a string."
        },
        "blob": {
          "$ref": "#/definitions/coreBlobType",
          "description": "A blob might have specialized implementation details depending on associated metadata."
        },
        "enum_type": {
          "$ref": "#/definitions/flyteidlcoreEnumType",
          "description": "Defines an enum with pre-defined string values."
        },
        "structured_dataset_type": {
          "$ref": "#/definitions/coreStructuredDatasetType",
          "title": "Generalized schema support"
        },
        "union_type": {
          "$ref": "#/definitions/coreUnionType",
          "description": "Defines an union type with pre-defined LiteralTypes."
        },
        "metadata": {
          "type": "object",
          "description": "This field contains type metadata that is descriptive of the type, but is NOT considered in type-checking.  This might be used by\nconsumers to identify special behavior or display extended information for the type."
        },
        "annotation": {
          "$ref": "#/definitions/coreTypeAnnotation",
          "description": "This field contains arbitrary data that might have special semantic\nmeaning for the client but does not effect internal flyte behavior."
        },
        "structure": {
          "$ref": "#/definitions/coreTypeStructure",
          "description": "Hints to improve type matching."
        }
      },
      "description": "Defines a strong type to allow type checking between interfaces."
    },
    "coreNodeExecutionIdentifier": {
      "type": "object",
      "properties": {
        "node_id": {
          "type": "string"
        },
        "execution_id": {
          "$ref": "#/definitions/coreWorkflowExecutionIdentifier"
        }
      },
      "description": "Encapsulation of fields that identify a Flyte node execution entity."
    },
    "coreOAuth2Client": {
      "type": "object",
      "properties": {
        "client_id": {
          "type": "string",
          "title": "client_id is the public id for the client to use. The system will not perform any pre-auth validation that the\nsecret requested matches the client_id indicated here.\n+required"
        },
        "client_secret": {
          "$ref": "#/definitions/coreSecret",
          "title": "client_secret is a reference to the secret used to authenticate the OAuth2 client.\n+required"
        }
      },
      "description": "OAuth2Client encapsulates OAuth2 Client Credentials to be used when making calls on behalf of that task."
    },
    "coreOAuth2TokenRequest": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "title": "name indicates a unique id for the token request within this task token requests. It'll be used as a suffix for\nenvironment variables and as a filename for mounting tokens as files.\n+required"
        },
        "type": {
          "$ref": "#/definitions/coreOAuth2TokenRequestType",
          "title": "type indicates the type of the request to make. Defaults to CLIENT_CREDENTIALS.\n+required"
        },
        "client": {
          "$ref": "#/definitions/coreOAuth2Client",
          "title": "client references the client_id/secret to use to request the OAuth2 token.\n+required"
        },
        "idp_discovery_endpoint": {
          "type": "string",
          "title": "idp_discovery_endpoint references the discovery endpoint used to retrieve token endpoint and other related\ninformation.\n+optional"
        },
        "token_endpoint": {
          "type": "string",
          "title": "token_endpoint references the token issuance endpoint. If idp_discovery_endpoint is not provided, this parameter is\nmandatory.\n+optional"
        }
      },
      "description": "OAuth2TokenRequest encapsulates information needed to request an OAuth2 token.\nFLYTE_TOKENS_ENV_PREFIX will be passed to indicate the prefix of the environment variables that will be present if\ntokens are passed through environment variables.\nFLYTE_TOKENS_PATH_PREFIX will be passed to indicate the prefix of the path where secrets will be mounted if tokens\nare passed through file mounts."
    },
    "coreOAuth2TokenRequestType": {
      "type": "string",
      "enum": [
        "CLIENT_CREDENTIALS"
      ],
      "default": "CLIENT_CREDENTIALS",
      "description": "Type of the token requested.\n\n - CLIENT_CREDENTIALS: CLIENT_CREDENTIALS indicates a 2-legged OAuth token requested using client credentials."
    },
    "corePartitions": {
      "type": "object",
      "properties": {
        "value": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/coreLabelValue"
          }
        }
      }
    },
    "corePrimitive": {
      "type": "object",
      "properties": {
        "integer": {
          "type": "string",
          "format": "int64"
        },
        "float_value": {
          "type": "number",
          "format": "double"
        },
        "string_value": {
          "type": "string"
        },
        "boolean": {
          "type": "boolean"
        },
        "datetime": {
          "type": "string",
          "format": "date-time"
        },
        "duration": {
          "type": "string"
        }
      },
      "title": "Primitive Types"
    },
    "coreResourceType": {
      "type": "string",
      "enum": [
        "UNSPECIFIED",
        "TASK",
        "WORKFLOW",
        "LAUNCH_PLAN",
        "DATASET"
      ],
      "default": "UNSPECIFIED",
      "description": "Indicates a resource type within Flyte.\n\n - DATASET: A dataset represents an entity modeled in Flyte DataCatalog. A Dataset is also a versioned entity and can be a compilation of multiple individual objects.\nEventually all Catalog objects should be modeled similar to Flyte Objects. The Dataset entities makes it possible for the UI  and CLI to act on the objects \nin a similar manner to other Flyte objects"
    },
    "coreResources": {
      "type": "object",
      "properties": {
        "requests": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/ResourcesResourceEntry"
          },
          "description": "The desired set of resources requested. ResourceNames must be unique within the list."
        },
        "limits": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/ResourcesResourceEntry"
          },
          "description": "Defines a set of bounds (e.g. min/max) within which the task can reliably run. ResourceNames must be unique\nwithin the list."
        }
      },
      "description": "A customizable interface to convey resources requested for a container. This can be interpreted differently for different\ncontainer engines."
    },
    "coreRetryStrategy": {
      "type": "object",
      "properties": {
        "retries": {
          "type": "integer",
          "format": "int64",
          "description": "Number of retries. Retries will be consumed when the job fails with a recoverable error.\nThe number of retries must be less than or equals to 10."
        }
      },
      "description": "Retry strategy associated with an executable unit."
    },
    "coreRuntimeBinding": {
      "type": "object"
    },
    "coreRuntimeMetadata": {
      "type": "object",
      "properties": {
        "type": {
          "$ref": "#/definitions/RuntimeMetadataRuntimeType",
          "description": "Type of runtime."
        },
        "version": {
          "type": "string",
          "description": "Version of the runtime. All versions should be backward compatible. However, certain cases call for version\nchecks to ensure tighter validation or setting expectations."
        },
        "flavor": {
          "type": "string",
          "description": "+optional It can be used to provide extra information about the runtime (e.g. python, golang... etc.)."
        }
      },
      "description": "Runtime information. This is loosely defined to allow for extensibility."
    },
    "coreScalar": {
      "type": "object",
      "properties": {
        "primitive": {
          "$ref": "#/definitions/corePrimitive"
        },
        "blob": {
          "$ref": "#/definitions/coreBlob"
        },
        "binary": {
          "$ref": "#/definitions/coreBinary"
        },
        "schema": {
          "$ref": "#/definitions/flyteidlcoreSchema"
        },
        "none_type": {
          "$ref": "#/definitions/coreVoid"
        },
        "error": {
          "$ref": "#/definitions/coreError"
        },
        "generic": {
          "type": "object"
        },
        "structured_dataset": {
          "$ref": "#/definitions/coreStructuredDataset"
        },
        "union": {
          "$ref": "#/definitions/coreUnion"
        }
      }
    },
    "coreSchemaType": {
      "type": "object",
      "properties": {
        "columns": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/SchemaTypeSchemaColumn"
          },
          "description": "A list of ordered columns this schema comprises of."
        }
      },
      "description": "Defines schema columns and types to strongly type-validate schemas interoperability."
    },
    "coreSecret": {
      "type": "object",
      "properties": {
        "group": {
          "type": "string",
          "title": "The name of the secret group where to find the key referenced below. For K8s secrets, this should be the name of\nthe v1/secret object. For Confidant, this should be the Credential name. For Vault, this should be the secret name.\nFor AWS Secret Manager, this should be the name of the secret.\n+required"
        },
        "group_version": {
          "type": "string",
          "title": "The group version to fetch. This is not supported in all secret management systems. It'll be ignored for the ones\nthat do not support it.\n+optional"
        },
        "key": {
          "type": "string",
          "title": "The name of the secret to mount. This has to match an existing secret in the system. It's up to the implementation\nof the secret management system to require case sensitivity. For K8s secrets, Confidant and Vault, this should\nmatch one of the keys inside the secret. For AWS Secret Manager, it's ignored.\n+optional"
        },
        "mount_requirement": {
          "$ref": "#/definitions/SecretMountType",
          "title": "mount_requirement is optional. Indicates where the secret has to be mounted. If provided, the execution will fail\nif the underlying key management system cannot satisfy that requirement. If not provided, the default location\nwill depend on the key management system.\n+optional"
        }
      },
      "description": "Secret encapsulates information about the secret a task needs to proceed. An environment variable\nFLYTE_SECRETS_ENV_PREFIX will be passed to indicate the prefix of the environment variables that will be present if\nsecrets are passed through environment variables.\nFLYTE_SECRETS_DEFAULT_DIR will be passed to indicate the prefix of the path where secrets will be mounted if secrets\nare passed through file mounts."
    },
    "coreSecurityContext": {
      "type": "object",
      "properties": {
        "run_as": {
          "$ref": "#/definitions/coreIdentity",
          "description": "run_as encapsulates the identity a pod should run as. If the task fills in multiple fields here, it'll be up to the\nbackend plugin to choose the appropriate identity for the execution engine the task will run on."
        },
        "secrets": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/coreSecret"
          },
          "description": "secrets indicate the list of secrets the task needs in order to proceed. Secrets will be mounted/passed to the\npod as it starts. If the plugin responsible for kicking of the task will not run it on a flyte cluster (e.g. AWS\nBatch), it's the responsibility of the plugin to fetch the secret (which means propeller identity will need access\nto the secret) and to pass it to the remote execution engine."
        },
        "tokens": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/coreOAuth2TokenRequest"
          },
          "description": "tokens indicate the list of token requests the task needs in order to proceed. Tokens will be mounted/passed to the\npod as it starts. If the plugin responsible for kicking of the task will not run it on a flyte cluster (e.g. AWS\nBatch), it's the responsibility of the plugin to fetch the secret (which means propeller identity will need access\nto the secret) and to pass it to the remote execution engine."
        }
      },
      "description": "SecurityContext holds security attributes that apply to tasks."
    },
    "coreSimpleType": {
      "type": "string",
      "enum": [
        "NONE",
        "INTEGER",
        "FLOAT",
        "STRING",
        "BOOLEAN",
        "DATETIME",
        "DURATION",
        "BINARY",
        "ERROR",
        "STRUCT"
      ],
      "default": "NONE",
      "description": "Define a set of simple types."
    },
    "coreSql": {
      "type": "object",
      "properties": {
        "statement": {
          "type": "string",
          "title": "The actual query to run, the query can have templated parameters.\nWe use Flyte's Golang templating format for Query templating.\nFor example,\ninsert overwrite directory '{{ .rawOutputDataPrefix }}' stored as parquet\nselect *\nfrom my_table\nwhere ds = '{{ .Inputs.ds }}'"
        },
        "dialect": {
          "$ref": "#/definitions/SqlDialect"
        }
      },
      "description": "Sql represents a generic sql workload with a statement and dialect."
    },
    "coreStructuredDataset": {
      "type": "object",
      "properties": {
        "uri": {
          "type": "string",
          "title": "String location uniquely identifying where the data is.\nShould start with the storage location (e.g. s3://, gs://, bq://, etc.)"
        },
        "metadata": {
          "$ref": "#/definitions/coreStructuredDatasetMetadata"
        }
      }
    },
    "coreStructuredDatasetMetadata": {
      "type": "object",
      "properties": {
        "structured_dataset_type": {
          "$ref": "#/definitions/coreStructuredDatasetType",
          "description": "Bundle the type information along with the literal.\nThis is here because StructuredDatasets can often be more defined at run time than at compile time.\nThat is, at compile time you might only declare a task to return a pandas dataframe or a StructuredDataset,\nwithout any column information, but at run time, you might have that column information.\nflytekit python will copy this type information into the literal, from the type information, if not provided by\nthe various plugins (encoders).\nSince this field is run time generated, it's not used for any type checking."
        }
      }
    },
    "coreStructuredDatasetType": {
      "type": "object",
      "properties": {
        "columns": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/StructuredDatasetTypeDatasetColumn"
          },
          "description": "A list of ordered columns this schema comprises of."
        },
        "format": {
          "type": "string",
          "description": "This is the storage format, the format of the bits at rest\nparquet, feather, csv, etc.\nFor two types to be compatible, the format will need to be an exact match."
        },
        "external_schema_type": {
          "type": "string",
          "description": "This is a string representing the type that the bytes in external_schema_bytes are formatted in.\nThis is an optional field that will not be used for type checking."
        },
        "external_schema_bytes": {
          "type": "string",
          "format": "byte",
          "description": "The serialized bytes of a third-party schema library like Arrow.\nThis is an optional field that will not be used for type checking."
        }
      }
    },
    "coreTaskExecutionIdentifier": {
      "type": "object",
      "properties": {
        "task_id": {
          "$ref": "#/definitions/coreIdentifier"
        },
        "node_execution_id": {
          "$ref": "#/definitions/coreNodeExecutionIdentifier"
        },
        "retry_attempt": {
          "type": "integer",
          "format": "int64"
        }
      },
      "description": "Encapsulation of fields that identify a Flyte task execution entity."
    },
    "coreTaskExecutionPhase": {
      "type": "string",
      "enum": [
        "UNDEFINED",
        "QUEUED",
        "RUNNING",
        "SUCCEEDED",
        "ABORTED",
        "FAILED",
        "INITIALIZING",
        "WAITING_FOR_RESOURCES"
      ],
      "default": "UNDEFINED",
      "title": "- INITIALIZING: To indicate cases where task is initializing, like: ErrImagePull, ContainerCreating, PodInitializing\n - WAITING_FOR_RESOURCES: To address cases, where underlying resource is not available: Backoff error, Resource quota exceeded"
    },
    "coreTaskLog": {
      "type": "object",
      "properties": {
        "uri": {
          "type": "string"
        },
        "name": {
          "type": "string"
        },
        "message_format": {
          "$ref": "#/definitions/TaskLogMessageFormat"
        },
        "ttl": {
          "type": "string"
        },
        "ShowWhilePending": {
          "type": "boolean"
        },
        "HideOnceFinished": {
          "type": "boolean"
        }
      },
      "title": "Log information for the task that is specific to a log sink\nWhen our log story is flushed out, we may have more metadata here like log link expiry"
    },
    "coreTaskMetadata": {
      "type": "object",
      "properties": {
        "discoverable": {
          "type": "boolean",
          "description": "Indicates whether the system should attempt to lookup this task's output to avoid duplication of work."
        },
        "runtime": {
          "$ref": "#/definitions/coreRuntimeMetadata",
          "description": "Runtime information about the task."
        },
        "timeout": {
          "type": "string",
          "description": "The overall timeout of a task including user-triggered retries."
        },
        "retries": {
          "$ref": "#/definitions/coreRetryStrategy",
          "description": "Number of retries per task."
        },
        "discovery_version": {
          "type": "string",
          "description": "Indicates a logical version to apply to this task for the purpose of discovery."
        },
        "deprecated_error_message": {
          "type": "string",
          "description": "If set, this indicates that this task is deprecated.  This will enable owners of tasks to notify consumers\nof the ending of support for a given task."
        },
        "interruptible": {
          "type": "boolean"
        },
        "cache_serializable": {
          "type": "boolean",
          "title": "Indicates whether the system should attempt to execute discoverable instances in serial to avoid duplicate work"
        },
        "generates_deck": {
          "type": "boolean",
          "description": "Indicates whether the task will generate a Deck URI when it finishes executing."
        },
        "tags": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "title": "Arbitrary tags that allow users and the platform to store small but arbitrary labels"
        },
        "pod_template_name": {
          "type": "string",
          "description": "pod_template_name is the unique name of a PodTemplate k8s resource to be used as the base configuration if this\ntask creates a k8s Pod. If this value is set, the specified PodTemplate will be used instead of, but applied\nidentically as, the default PodTemplate configured in FlytePropeller."
        },
        "cache_ignore_input_vars": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "cache_ignore_input_vars is the input variables that should not be included when calculating hash for cache."
        }
      },
      "title": "Task Metadata"
    },
    "coreTaskNodeOverrides": {
      "type": "object",
      "properties": {
        "resources": {
          "$ref": "#/definitions/coreResources",
          "description": "A customizable interface to convey resources requested for a task container."
        },
        "extended_resources": {
          "$ref": "#/definitions/coreExtendedResources",
          "description": "Overrides for all non-standard resources, not captured by\nv1.ResourceRequirements, to allocate to a task."
        },
        "container_image": {
          "type": "string",
          "description": "Override for the image used by task pods."
        }
      },
      "description": "Optional task node overrides that will be applied at task execution time."
    },
    "coreTaskTemplate": {
      "type": "object",
      "properties": {
        "id": {
          "$ref": "#/definitions/coreIdentifier",
          "description": "Auto generated taskId by the system. Task Id uniquely identifies this task globally."
        },
        "type": {
          "type": "string",
          "description": "A predefined yet extensible Task type identifier. This can be used to customize any of the components. If no\nextensions are provided in the system, Flyte will resolve the this task to its TaskCategory and default the\nimplementation registered for the TaskCategory."
        },
        "metadata": {
          "$ref": "#/definitions/coreTaskMetadata",
          "description": "Extra metadata about the task."
        },
        "interface": {
          "$ref": "#/definitions/coreTypedInterface",
          "description": "A strongly typed interface for the task. This enables others to use this task within a workflow and guarantees\ncompile-time validation of the workflow to avoid costly runtime failures."
        },
        "custom": {
          "type": "object",
          "description": "Custom data about the task. This is extensible to allow various plugins in the system."
        },
        "container": {
          "$ref": "#/definitions/coreContainer"
        },
        "k8s_pod": {
          "$ref": "#/definitions/coreK8sPod"
        },
        "sql": {
          "$ref": "#/definitions/coreSql"
        },
        "task_type_version": {
          "type": "integer",
          "format": "int32",
          "description": "This can be used to customize task handling at execution time for the same task type."
        },
        "security_context": {
          "$ref": "#/definitions/coreSecurityContext",
          "description": "security_context encapsulates security attributes requested to run this task."
        },
        "extended_resources": {
          "$ref": "#/definitions/coreExtendedResources",
          "description": "Encapsulates all non-standard resources, not captured by\nv1.ResourceRequirements, to allocate to a task."
        },
        "config": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "title": "Metadata about the custom defined for this task. This is extensible to allow various plugins in the system\nto use as required.\nreserve the field numbers 1 through 15 for very frequently occurring message elements"
        }
      },
      "description": "A Task structure that uniquely identifies a task in the system\nTasks are registered as a first step in the system."
    },
    "coreTimePartition": {
      "type": "object",
      "properties": {
        "value": {
          "$ref": "#/definitions/coreLabelValue"
        },
        "granularity": {
          "$ref": "#/definitions/coreGranularity"
        }
      }
    },
    "coreTimeTransform": {
      "type": "object",
      "properties": {
        "transform": {
          "type": "string"
        },
        "op": {
          "$ref": "#/definitions/flyteidlcoreOperator"
        }
      }
    },
    "coreTypeAnnotation": {
      "type": "object",
      "properties": {
        "annotations": {
          "type": "object",
          "description": "A arbitrary JSON payload to describe a type."
        }
      },
      "description": "TypeAnnotation encapsulates registration time information about a type. This can be used for various control-plane operations. TypeAnnotation will not be available at runtime when a task runs."
    },
    "coreTypeStructure": {
      "type": "object",
      "properties": {
        "tag": {
          "type": "string",
          "title": "Must exactly match for types to be castable"
        },
        "dataclass_type": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/coreLiteralType"
          },
          "title": "dataclass_type only exists for dataclasses.\nThis is used to resolve the type of the fields of dataclass\nThe key is the field name, and the value is the literal type of the field\ne.g. For dataclass Foo, with fields a, and a is a string\nFoo.a will be resolved as a literal type of string from dataclass_type"
        }
      },
      "description": "Hints to improve type matching\ne.g. allows distinguishing output from custom type transformers\neven if the underlying IDL serialization matches."
    },
    "coreTypedInterface": {
      "type": "object",
      "properties": {
        "inputs": {
          "$ref": "#/definitions/coreVariableMap"
        },
        "outputs": {
          "$ref": "#/definitions/coreVariableMap"
        }
      },
      "description": "Defines strongly typed inputs and outputs."
    },
    "coreUnion": {
      "type": "object",
      "properties": {
        "value": {
          "$ref": "#/definitions/coreLiteral"
        },
        "type": {
          "$ref": "#/definitions/coreLiteralType"
        }
      },
      "description": "The runtime representation of a tagged union value. See `UnionType` for more details."
    },
    "coreUnionType": {
      "type": "object",
      "properties": {
        "variants": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/coreLiteralType"
          },
          "description": "Predefined set of variants in union."
        }
      },
      "description": "Defines a tagged union type, also known as a variant (and formally as the sum type).\n\nA sum type S is defined by a sequence of types (A, B, C, ...), each tagged by a string tag\nA value of type S is constructed from a value of any of the variant types. The specific choice of type is recorded by\nstoring the varaint's tag with the literal value and can be examined in runtime.\n\nType S is typically written as\nS := Apple A | Banana B | Cantaloupe C | ...\n\nNotably, a nullable (optional) type is a sum type between some type X and the singleton type representing a null-value:\nOptional X := X | Null\n\nSee also: https://en.wikipedia.org/wiki/Tagged_union"
    },
    "coreVariable": {
      "type": "object",
      "properties": {
        "type": {
          "$ref": "#/definitions/coreLiteralType",
          "description": "Variable literal type."
        },
        "description": {
          "type": "string",
          "title": "+optional string describing input variable"
        },
        "artifact_partial_id": {
          "$ref": "#/definitions/coreArtifactID",
          "description": "+optional This object allows the user to specify how Artifacts are created.\nname, tag, partitions can be specified. The other fields (version and project/domain) are ignored."
        },
        "artifact_tag": {
          "$ref": "#/definitions/coreArtifactTag"
        }
      },
      "description": "Defines a strongly typed variable."
    },
    "coreVariableMap": {
      "type": "object",
      "properties": {
        "variables": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/coreVariable"
          },
          "description": "Defines a map of variable names to variables."
        }
      },
      "title": "A map of Variables"
    },
    "coreVoid": {
      "type": "object",
      "description": "Used to denote a nil/null/None assignment to a scalar value. The underlying LiteralType for Void is intentionally\nundefined since it can be assigned to a scalar of any LiteralType."
    },
    "coreWorkflowExecutionIdentifier": {
      "type": "object",
      "properties": {
        "project": {
          "type": "string",
          "description": "Name of the project the resource belongs to."
        },
        "domain": {
          "type": "string",
          "description": "Name of the domain the resource belongs to.\nA domain can be considered as a subset within a specific project."
        },
        "name": {
          "type": "string",
          "description": "User or system provided value for the resource."
        },
        "org": {
          "type": "string",
          "description": "Optional, org key applied to the resource."
        }
      },
      "title": "Encapsulation of fields that uniquely identifies a Flyte workflow execution"
    },
    "flyteidladminState": {
      "type": "string",
      "enum": [
        "RETRYABLE_FAILURE",
        "PERMANENT_FAILURE",
        "PENDING",
        "RUNNING",
        "SUCCEEDED"
      ],
      "default": "RETRYABLE_FAILURE",
      "description": "The state of the execution is used to control its visibility in the UI/CLI."
    },
    "flyteidladminTaskExecutionMetadata": {
      "type": "object",
      "properties": {
        "task_execution_id": {
          "$ref": "#/definitions/coreTaskExecutionIdentifier"
        },
        "namespace": {
          "type": "string",
          "title": "k8s namespace where the task is executed in"
        },
        "labels": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "title": "Labels attached to the task execution"
        },
        "annotations": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "title": "Annotations attached to the task execution"
        },
        "k8s_service_account": {
          "type": "string",
          "title": "k8s service account associated with the task execution"
        },
        "environment_variables": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "title": "Environment variables attached to the task execution"
        },
        "max_attempts": {
          "type": "integer",
          "format": "int32",
          "description": "Represents the maximum number of attempts allowed for a task.\nIf a task fails, it can be retried up to this maximum number of attempts."
        },
        "interruptible": {
          "type": "boolean",
          "description": "Indicates whether the task execution can be interrupted.\nIf set to true, the task can be stopped before completion."
        },
        "interruptible_failure_threshold": {
          "type": "integer",
          "format": "int32",
          "description": "Specifies the threshold for failure count at which the interruptible property\nwill take effect. If the number of consecutive task failures exceeds this threshold,\ninterruptible behavior will be activated."
        },
        "overrides": {
          "$ref": "#/definitions/coreTaskNodeOverrides",
          "description": "Overrides for specific properties of the task node.\nThese overrides can be used to customize the behavior of the task node."
        },
        "identity": {
          "$ref": "#/definitions/coreIdentity",
          "title": "Identity of user running this task execution"
        }
      },
      "description": "Represents a subset of runtime task execution metadata that are relevant to external plugins.\n\nID of the task execution"
    },
    "flyteidlcoreEnumType": {
      "type": "object",
      "properties": {
        "values": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Predefined set of enum values."
        }
      },
      "description": "Enables declaring enum types, with predefined string values\nFor len(values) \u003e 0, the first value in the ordered list is regarded as the default value. If you wish\nTo provide no defaults, make the first value as undefined."
    },
    "flyteidlcoreKeyValuePair": {
      "type": "object",
      "properties": {
        "key": {
          "type": "string",
          "description": "required."
        },
        "value": {
          "type": "string",
          "description": "+optional."
        }
      },
      "description": "A generic key value pair."
    },
    "flyteidlcoreOperator": {
      "type": "string",
      "enum": [
        "MINUS",
        "PLUS"
      ],
      "default": "MINUS"
    },
    "flyteidlcoreSchema": {
      "type": "object",
      "properties": {
        "uri": {
          "type": "string"
        },
        "type": {
          "$ref": "#/definitions/coreSchemaType"
        }
      },
      "description": "A strongly typed schema that defines the interface of data retrieved from the underlying storage medium."
    },
    "googlerpcStatus": {
      "type": "object",
      "properties": {
        "code": {
          "type": "integer",
          "format": "int32"
        },
        "message": {
          "type": "string"
        },
        "details": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/protobufAny"
          }
        }
      }
    },
    "protobufAny": {
      "type": "object",
      "properties": {
        "@type": {
          "type": "string",
          "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com. As of May 2023, there are no widely used type server\nimplementations and no plans to implement one.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
        }
      },
      "additionalProperties": {},
      "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(\u0026foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n    // or ...\n    if (any.isSameTypeAs(Foo.getDefaultInstance())) {\n      foo = any.unpack(Foo.getDefaultInstance());\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := \u0026pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := \u0026pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": \u003cstring\u003e,\n      \"lastName\": \u003cstring\u003e\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
    },
    "protobufNullValue": {
      "type": "string",
      "enum": [
        "NULL_VALUE"
      ],
      "default": "NULL_VALUE",
      "description": "`NullValue` is a singleton enumeration to represent the null value for the\n`Value` type union.\n\nThe JSON representation for `NullValue` is JSON `null`.\n\n - NULL_VALUE: Null value."
    }
  }
}
