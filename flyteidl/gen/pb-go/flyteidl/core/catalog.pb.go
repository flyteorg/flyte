// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.30.0
// 	protoc        (unknown)
// source: flyteidl/core/catalog.proto

package core

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Indicates the status of CatalogCaching. The reason why this is not embedded in TaskNodeMetadata is, that we may use for other types of nodes as well in the future
type CatalogCacheStatus int32

const (
	// Used to indicate that caching was disabled
	CatalogCacheStatus_CACHE_DISABLED CatalogCacheStatus = 0
	// Used to indicate that the cache lookup resulted in no matches
	CatalogCacheStatus_CACHE_MISS CatalogCacheStatus = 1
	// used to indicate that the associated artifact was a result of a previous execution
	CatalogCacheStatus_CACHE_HIT CatalogCacheStatus = 2
	// used to indicate that the resultant artifact was added to the cache
	CatalogCacheStatus_CACHE_POPULATED CatalogCacheStatus = 3
	// Used to indicate that cache lookup failed because of an error
	CatalogCacheStatus_CACHE_LOOKUP_FAILURE CatalogCacheStatus = 4
	// Used to indicate that cache lookup failed because of an error
	CatalogCacheStatus_CACHE_PUT_FAILURE CatalogCacheStatus = 5
	// Used to indicate the cache lookup was skipped
	CatalogCacheStatus_CACHE_SKIPPED CatalogCacheStatus = 6
	// Used to indicate that the cache was evicted
	CatalogCacheStatus_CACHE_EVICTED CatalogCacheStatus = 7
)

// Enum value maps for CatalogCacheStatus.
var (
	CatalogCacheStatus_name = map[int32]string{
		0: "CACHE_DISABLED",
		1: "CACHE_MISS",
		2: "CACHE_HIT",
		3: "CACHE_POPULATED",
		4: "CACHE_LOOKUP_FAILURE",
		5: "CACHE_PUT_FAILURE",
		6: "CACHE_SKIPPED",
		7: "CACHE_EVICTED",
	}
	CatalogCacheStatus_value = map[string]int32{
		"CACHE_DISABLED":       0,
		"CACHE_MISS":           1,
		"CACHE_HIT":            2,
		"CACHE_POPULATED":      3,
		"CACHE_LOOKUP_FAILURE": 4,
		"CACHE_PUT_FAILURE":    5,
		"CACHE_SKIPPED":        6,
		"CACHE_EVICTED":        7,
	}
)

func (x CatalogCacheStatus) Enum() *CatalogCacheStatus {
	p := new(CatalogCacheStatus)
	*p = x
	return p
}

func (x CatalogCacheStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (CatalogCacheStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_flyteidl_core_catalog_proto_enumTypes[0].Descriptor()
}

func (CatalogCacheStatus) Type() protoreflect.EnumType {
	return &file_flyteidl_core_catalog_proto_enumTypes[0]
}

func (x CatalogCacheStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use CatalogCacheStatus.Descriptor instead.
func (CatalogCacheStatus) EnumDescriptor() ([]byte, []int) {
	return file_flyteidl_core_catalog_proto_rawDescGZIP(), []int{0}
}

// Indicates the status of a catalog reservation operation.
type CatalogReservation_Status int32

const (
	// Used to indicate that reservations are disabled
	CatalogReservation_RESERVATION_DISABLED CatalogReservation_Status = 0
	// Used to indicate that a reservation was successfully acquired or extended
	CatalogReservation_RESERVATION_ACQUIRED CatalogReservation_Status = 1
	// Used to indicate that an active reservation currently exists
	CatalogReservation_RESERVATION_EXISTS CatalogReservation_Status = 2
	// Used to indicate that the reservation has been successfully released
	CatalogReservation_RESERVATION_RELEASED CatalogReservation_Status = 3
	// Used to indicate that a reservation operation resulted in failure
	CatalogReservation_RESERVATION_FAILURE CatalogReservation_Status = 4
)

// Enum value maps for CatalogReservation_Status.
var (
	CatalogReservation_Status_name = map[int32]string{
		0: "RESERVATION_DISABLED",
		1: "RESERVATION_ACQUIRED",
		2: "RESERVATION_EXISTS",
		3: "RESERVATION_RELEASED",
		4: "RESERVATION_FAILURE",
	}
	CatalogReservation_Status_value = map[string]int32{
		"RESERVATION_DISABLED": 0,
		"RESERVATION_ACQUIRED": 1,
		"RESERVATION_EXISTS":   2,
		"RESERVATION_RELEASED": 3,
		"RESERVATION_FAILURE":  4,
	}
)

func (x CatalogReservation_Status) Enum() *CatalogReservation_Status {
	p := new(CatalogReservation_Status)
	*p = x
	return p
}

func (x CatalogReservation_Status) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (CatalogReservation_Status) Descriptor() protoreflect.EnumDescriptor {
	return file_flyteidl_core_catalog_proto_enumTypes[1].Descriptor()
}

func (CatalogReservation_Status) Type() protoreflect.EnumType {
	return &file_flyteidl_core_catalog_proto_enumTypes[1]
}

func (x CatalogReservation_Status) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use CatalogReservation_Status.Descriptor instead.
func (CatalogReservation_Status) EnumDescriptor() ([]byte, []int) {
	return file_flyteidl_core_catalog_proto_rawDescGZIP(), []int{2, 0}
}

type CatalogArtifactTag struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Artifact ID is generated name
	ArtifactId string `protobuf:"bytes,1,opt,name=artifact_id,json=artifactId,proto3" json:"artifact_id,omitempty"`
	// Flyte computes the tag automatically, as the hash of the values
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
}

func (x *CatalogArtifactTag) Reset() {
	*x = CatalogArtifactTag{}
	if protoimpl.UnsafeEnabled {
		mi := &file_flyteidl_core_catalog_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CatalogArtifactTag) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CatalogArtifactTag) ProtoMessage() {}

func (x *CatalogArtifactTag) ProtoReflect() protoreflect.Message {
	mi := &file_flyteidl_core_catalog_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CatalogArtifactTag.ProtoReflect.Descriptor instead.
func (*CatalogArtifactTag) Descriptor() ([]byte, []int) {
	return file_flyteidl_core_catalog_proto_rawDescGZIP(), []int{0}
}

func (x *CatalogArtifactTag) GetArtifactId() string {
	if x != nil {
		return x.ArtifactId
	}
	return ""
}

func (x *CatalogArtifactTag) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

// Catalog artifact information with specific metadata
type CatalogMetadata struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// Dataset ID in the catalog
	DatasetId *Identifier `protobuf:"bytes,1,opt,name=dataset_id,json=datasetId,proto3" json:"dataset_id,omitempty"`
	// Artifact tag in the catalog
	ArtifactTag *CatalogArtifactTag `protobuf:"bytes,2,opt,name=artifact_tag,json=artifactTag,proto3" json:"artifact_tag,omitempty"`
	// Optional: Source Execution identifier, if this dataset was generated by another execution in Flyte. This is a one-of field and will depend on the caching context
	//
	// Types that are assignable to SourceExecution:
	//
	//	*CatalogMetadata_SourceTaskExecution
	SourceExecution isCatalogMetadata_SourceExecution `protobuf_oneof:"source_execution"`
	CreatedAt       *timestamppb.Timestamp            `protobuf:"bytes,4,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
}

func (x *CatalogMetadata) Reset() {
	*x = CatalogMetadata{}
	if protoimpl.UnsafeEnabled {
		mi := &file_flyteidl_core_catalog_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CatalogMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CatalogMetadata) ProtoMessage() {}

func (x *CatalogMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_flyteidl_core_catalog_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CatalogMetadata.ProtoReflect.Descriptor instead.
func (*CatalogMetadata) Descriptor() ([]byte, []int) {
	return file_flyteidl_core_catalog_proto_rawDescGZIP(), []int{1}
}

func (x *CatalogMetadata) GetDatasetId() *Identifier {
	if x != nil {
		return x.DatasetId
	}
	return nil
}

func (x *CatalogMetadata) GetArtifactTag() *CatalogArtifactTag {
	if x != nil {
		return x.ArtifactTag
	}
	return nil
}

func (m *CatalogMetadata) GetSourceExecution() isCatalogMetadata_SourceExecution {
	if m != nil {
		return m.SourceExecution
	}
	return nil
}

func (x *CatalogMetadata) GetSourceTaskExecution() *TaskExecutionIdentifier {
	if x, ok := x.GetSourceExecution().(*CatalogMetadata_SourceTaskExecution); ok {
		return x.SourceTaskExecution
	}
	return nil
}

func (x *CatalogMetadata) GetCreatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.CreatedAt
	}
	return nil
}

type isCatalogMetadata_SourceExecution interface {
	isCatalogMetadata_SourceExecution()
}

type CatalogMetadata_SourceTaskExecution struct {
	// Today we only support TaskExecutionIdentifier as a source, as catalog caching only works for task executions
	SourceTaskExecution *TaskExecutionIdentifier `protobuf:"bytes,3,opt,name=source_task_execution,json=sourceTaskExecution,proto3,oneof"`
}

func (*CatalogMetadata_SourceTaskExecution) isCatalogMetadata_SourceExecution() {}

type CatalogReservation struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
}

func (x *CatalogReservation) Reset() {
	*x = CatalogReservation{}
	if protoimpl.UnsafeEnabled {
		mi := &file_flyteidl_core_catalog_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *CatalogReservation) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CatalogReservation) ProtoMessage() {}

func (x *CatalogReservation) ProtoReflect() protoreflect.Message {
	mi := &file_flyteidl_core_catalog_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CatalogReservation.ProtoReflect.Descriptor instead.
func (*CatalogReservation) Descriptor() ([]byte, []int) {
	return file_flyteidl_core_catalog_proto_rawDescGZIP(), []int{2}
}

var File_flyteidl_core_catalog_proto protoreflect.FileDescriptor

var file_flyteidl_core_catalog_proto_rawDesc = []byte{
	0x0a, 0x1b, 0x66, 0x6c, 0x79, 0x74, 0x65, 0x69, 0x64, 0x6c, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f,
	0x63, 0x61, 0x74, 0x61, 0x6c, 0x6f, 0x67, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x0d, 0x66,
	0x6c, 0x79, 0x74, 0x65, 0x69, 0x64, 0x6c, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x1a, 0x1e, 0x66, 0x6c,
	0x79, 0x74, 0x65, 0x69, 0x64, 0x6c, 0x2f, 0x63, 0x6f, 0x72, 0x65, 0x2f, 0x69, 0x64, 0x65, 0x6e,
	0x74, 0x69, 0x66, 0x69, 0x65, 0x72, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1f, 0x67, 0x6f,
	0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x74, 0x69,
	0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0x49, 0x0a,
	0x12, 0x43, 0x61, 0x74, 0x61, 0x6c, 0x6f, 0x67, 0x41, 0x72, 0x74, 0x69, 0x66, 0x61, 0x63, 0x74,
	0x54, 0x61, 0x67, 0x12, 0x1f, 0x0a, 0x0b, 0x61, 0x72, 0x74, 0x69, 0x66, 0x61, 0x63, 0x74, 0x5f,
	0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0a, 0x61, 0x72, 0x74, 0x69, 0x66, 0x61,
	0x63, 0x74, 0x49, 0x64, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x22, 0xbe, 0x02, 0x0a, 0x0f, 0x43, 0x61, 0x74,
	0x61, 0x6c, 0x6f, 0x67, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x12, 0x38, 0x0a, 0x0a,
	0x64, 0x61, 0x74, 0x61, 0x73, 0x65, 0x74, 0x5f, 0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x19, 0x2e, 0x66, 0x6c, 0x79, 0x74, 0x65, 0x69, 0x64, 0x6c, 0x2e, 0x63, 0x6f, 0x72, 0x65,
	0x2e, 0x49, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x66, 0x69, 0x65, 0x72, 0x52, 0x09, 0x64, 0x61, 0x74,
	0x61, 0x73, 0x65, 0x74, 0x49, 0x64, 0x12, 0x44, 0x0a, 0x0c, 0x61, 0x72, 0x74, 0x69, 0x66, 0x61,
	0x63, 0x74, 0x5f, 0x74, 0x61, 0x67, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x21, 0x2e, 0x66,
	0x6c, 0x79, 0x74, 0x65, 0x69, 0x64, 0x6c, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x43, 0x61, 0x74,
	0x61, 0x6c, 0x6f, 0x67, 0x41, 0x72, 0x74, 0x69, 0x66, 0x61, 0x63, 0x74, 0x54, 0x61, 0x67, 0x52,
	0x0b, 0x61, 0x72, 0x74, 0x69, 0x66, 0x61, 0x63, 0x74, 0x54, 0x61, 0x67, 0x12, 0x5c, 0x0a, 0x15,
	0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x5f, 0x74, 0x61, 0x73, 0x6b, 0x5f, 0x65, 0x78, 0x65, 0x63,
	0x75, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x26, 0x2e, 0x66, 0x6c,
	0x79, 0x74, 0x65, 0x69, 0x64, 0x6c, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x2e, 0x54, 0x61, 0x73, 0x6b,
	0x45, 0x78, 0x65, 0x63, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x66,
	0x69, 0x65, 0x72, 0x48, 0x00, 0x52, 0x13, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x54, 0x61, 0x73,
	0x6b, 0x45, 0x78, 0x65, 0x63, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x12, 0x39, 0x0a, 0x0a, 0x63, 0x72,
	0x65, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x61, 0x74, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1a,
	0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66,
	0x2e, 0x54, 0x69, 0x6d, 0x65, 0x73, 0x74, 0x61, 0x6d, 0x70, 0x52, 0x09, 0x63, 0x72, 0x65, 0x61,
	0x74, 0x65, 0x64, 0x41, 0x74, 0x42, 0x12, 0x0a, 0x10, 0x73, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x5f,
	0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x9e, 0x01, 0x0a, 0x12, 0x43, 0x61,
	0x74, 0x61, 0x6c, 0x6f, 0x67, 0x52, 0x65, 0x73, 0x65, 0x72, 0x76, 0x61, 0x74, 0x69, 0x6f, 0x6e,
	0x22, 0x87, 0x01, 0x0a, 0x06, 0x53, 0x74, 0x61, 0x74, 0x75, 0x73, 0x12, 0x18, 0x0a, 0x14, 0x52,
	0x45, 0x53, 0x45, 0x52, 0x56, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x44, 0x49, 0x53, 0x41, 0x42,
	0x4c, 0x45, 0x44, 0x10, 0x00, 0x12, 0x18, 0x0a, 0x14, 0x52, 0x45, 0x53, 0x45, 0x52, 0x56, 0x41,
	0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x41, 0x43, 0x51, 0x55, 0x49, 0x52, 0x45, 0x44, 0x10, 0x01, 0x12,
	0x16, 0x0a, 0x12, 0x52, 0x45, 0x53, 0x45, 0x52, 0x56, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x45,
	0x58, 0x49, 0x53, 0x54, 0x53, 0x10, 0x02, 0x12, 0x18, 0x0a, 0x14, 0x52, 0x45, 0x53, 0x45, 0x52,
	0x56, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x5f, 0x52, 0x45, 0x4c, 0x45, 0x41, 0x53, 0x45, 0x44, 0x10,
	0x03, 0x12, 0x17, 0x0a, 0x13, 0x52, 0x45, 0x53, 0x45, 0x52, 0x56, 0x41, 0x54, 0x49, 0x4f, 0x4e,
	0x5f, 0x46, 0x41, 0x49, 0x4c, 0x55, 0x52, 0x45, 0x10, 0x04, 0x2a, 0xb3, 0x01, 0x0a, 0x12, 0x43,
	0x61, 0x74, 0x61, 0x6c, 0x6f, 0x67, 0x43, 0x61, 0x63, 0x68, 0x65, 0x53, 0x74, 0x61, 0x74, 0x75,
	0x73, 0x12, 0x12, 0x0a, 0x0e, 0x43, 0x41, 0x43, 0x48, 0x45, 0x5f, 0x44, 0x49, 0x53, 0x41, 0x42,
	0x4c, 0x45, 0x44, 0x10, 0x00, 0x12, 0x0e, 0x0a, 0x0a, 0x43, 0x41, 0x43, 0x48, 0x45, 0x5f, 0x4d,
	0x49, 0x53, 0x53, 0x10, 0x01, 0x12, 0x0d, 0x0a, 0x09, 0x43, 0x41, 0x43, 0x48, 0x45, 0x5f, 0x48,
	0x49, 0x54, 0x10, 0x02, 0x12, 0x13, 0x0a, 0x0f, 0x43, 0x41, 0x43, 0x48, 0x45, 0x5f, 0x50, 0x4f,
	0x50, 0x55, 0x4c, 0x41, 0x54, 0x45, 0x44, 0x10, 0x03, 0x12, 0x18, 0x0a, 0x14, 0x43, 0x41, 0x43,
	0x48, 0x45, 0x5f, 0x4c, 0x4f, 0x4f, 0x4b, 0x55, 0x50, 0x5f, 0x46, 0x41, 0x49, 0x4c, 0x55, 0x52,
	0x45, 0x10, 0x04, 0x12, 0x15, 0x0a, 0x11, 0x43, 0x41, 0x43, 0x48, 0x45, 0x5f, 0x50, 0x55, 0x54,
	0x5f, 0x46, 0x41, 0x49, 0x4c, 0x55, 0x52, 0x45, 0x10, 0x05, 0x12, 0x11, 0x0a, 0x0d, 0x43, 0x41,
	0x43, 0x48, 0x45, 0x5f, 0x53, 0x4b, 0x49, 0x50, 0x50, 0x45, 0x44, 0x10, 0x06, 0x12, 0x11, 0x0a,
	0x0d, 0x43, 0x41, 0x43, 0x48, 0x45, 0x5f, 0x45, 0x56, 0x49, 0x43, 0x54, 0x45, 0x44, 0x10, 0x07,
	0x42, 0xb2, 0x01, 0x0a, 0x11, 0x63, 0x6f, 0x6d, 0x2e, 0x66, 0x6c, 0x79, 0x74, 0x65, 0x69, 0x64,
	0x6c, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x42, 0x0c, 0x43, 0x61, 0x74, 0x61, 0x6c, 0x6f, 0x67, 0x50,
	0x72, 0x6f, 0x74, 0x6f, 0x50, 0x01, 0x5a, 0x3a, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63,
	0x6f, 0x6d, 0x2f, 0x66, 0x6c, 0x79, 0x74, 0x65, 0x6f, 0x72, 0x67, 0x2f, 0x66, 0x6c, 0x79, 0x74,
	0x65, 0x2f, 0x66, 0x6c, 0x79, 0x74, 0x65, 0x69, 0x64, 0x6c, 0x2f, 0x67, 0x65, 0x6e, 0x2f, 0x70,
	0x62, 0x2d, 0x67, 0x6f, 0x2f, 0x66, 0x6c, 0x79, 0x74, 0x65, 0x69, 0x64, 0x6c, 0x2f, 0x63, 0x6f,
	0x72, 0x65, 0xa2, 0x02, 0x03, 0x46, 0x43, 0x58, 0xaa, 0x02, 0x0d, 0x46, 0x6c, 0x79, 0x74, 0x65,
	0x69, 0x64, 0x6c, 0x2e, 0x43, 0x6f, 0x72, 0x65, 0xca, 0x02, 0x0d, 0x46, 0x6c, 0x79, 0x74, 0x65,
	0x69, 0x64, 0x6c, 0x5c, 0x43, 0x6f, 0x72, 0x65, 0xe2, 0x02, 0x19, 0x46, 0x6c, 0x79, 0x74, 0x65,
	0x69, 0x64, 0x6c, 0x5c, 0x43, 0x6f, 0x72, 0x65, 0x5c, 0x47, 0x50, 0x42, 0x4d, 0x65, 0x74, 0x61,
	0x64, 0x61, 0x74, 0x61, 0xea, 0x02, 0x0e, 0x46, 0x6c, 0x79, 0x74, 0x65, 0x69, 0x64, 0x6c, 0x3a,
	0x3a, 0x43, 0x6f, 0x72, 0x65, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_flyteidl_core_catalog_proto_rawDescOnce sync.Once
	file_flyteidl_core_catalog_proto_rawDescData = file_flyteidl_core_catalog_proto_rawDesc
)

func file_flyteidl_core_catalog_proto_rawDescGZIP() []byte {
	file_flyteidl_core_catalog_proto_rawDescOnce.Do(func() {
		file_flyteidl_core_catalog_proto_rawDescData = protoimpl.X.CompressGZIP(file_flyteidl_core_catalog_proto_rawDescData)
	})
	return file_flyteidl_core_catalog_proto_rawDescData
}

var file_flyteidl_core_catalog_proto_enumTypes = make([]protoimpl.EnumInfo, 2)
var file_flyteidl_core_catalog_proto_msgTypes = make([]protoimpl.MessageInfo, 3)
var file_flyteidl_core_catalog_proto_goTypes = []interface{}{
	(CatalogCacheStatus)(0),         // 0: flyteidl.core.CatalogCacheStatus
	(CatalogReservation_Status)(0),  // 1: flyteidl.core.CatalogReservation.Status
	(*CatalogArtifactTag)(nil),      // 2: flyteidl.core.CatalogArtifactTag
	(*CatalogMetadata)(nil),         // 3: flyteidl.core.CatalogMetadata
	(*CatalogReservation)(nil),      // 4: flyteidl.core.CatalogReservation
	(*Identifier)(nil),              // 5: flyteidl.core.Identifier
	(*TaskExecutionIdentifier)(nil), // 6: flyteidl.core.TaskExecutionIdentifier
	(*timestamppb.Timestamp)(nil),   // 7: google.protobuf.Timestamp
}
var file_flyteidl_core_catalog_proto_depIdxs = []int32{
	5, // 0: flyteidl.core.CatalogMetadata.dataset_id:type_name -> flyteidl.core.Identifier
	2, // 1: flyteidl.core.CatalogMetadata.artifact_tag:type_name -> flyteidl.core.CatalogArtifactTag
	6, // 2: flyteidl.core.CatalogMetadata.source_task_execution:type_name -> flyteidl.core.TaskExecutionIdentifier
	7, // 3: flyteidl.core.CatalogMetadata.created_at:type_name -> google.protobuf.Timestamp
	4, // [4:4] is the sub-list for method output_type
	4, // [4:4] is the sub-list for method input_type
	4, // [4:4] is the sub-list for extension type_name
	4, // [4:4] is the sub-list for extension extendee
	0, // [0:4] is the sub-list for field type_name
}

func init() { file_flyteidl_core_catalog_proto_init() }
func file_flyteidl_core_catalog_proto_init() {
	if File_flyteidl_core_catalog_proto != nil {
		return
	}
	file_flyteidl_core_identifier_proto_init()
	if !protoimpl.UnsafeEnabled {
		file_flyteidl_core_catalog_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CatalogArtifactTag); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_flyteidl_core_catalog_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CatalogMetadata); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_flyteidl_core_catalog_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*CatalogReservation); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	file_flyteidl_core_catalog_proto_msgTypes[1].OneofWrappers = []interface{}{
		(*CatalogMetadata_SourceTaskExecution)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_flyteidl_core_catalog_proto_rawDesc,
			NumEnums:      2,
			NumMessages:   3,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_flyteidl_core_catalog_proto_goTypes,
		DependencyIndexes: file_flyteidl_core_catalog_proto_depIdxs,
		EnumInfos:         file_flyteidl_core_catalog_proto_enumTypes,
		MessageInfos:      file_flyteidl_core_catalog_proto_msgTypes,
	}.Build()
	File_flyteidl_core_catalog_proto = out.File
	file_flyteidl_core_catalog_proto_rawDesc = nil
	file_flyteidl_core_catalog_proto_goTypes = nil
	file_flyteidl_core_catalog_proto_depIdxs = nil
}
