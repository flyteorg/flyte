package docgen

import (
	"bytes"
	"context"
	"fmt"
	"regexp"
	"strings"

	cmdCore "github.com/flyteorg/flyte/flytectl/cmd/core"
	"github.com/spf13/cobra"
	"github.com/spf13/cobra/doc"
)

func GetDocgenCmd(root *cobra.Command) map[string]cmdCore.CommandEntry {
	return map[string]cmdCore.CommandEntry{
		"docgen": {
			CmdFunc:                  startDocgen(root),
			Aliases:                  []string{"docgen"},
			ProjectDomainNotRequired: true,
			Short:                    "[internal] generates documentation schema",
		},
	}
}

func startDocgen(root *cobra.Command) cmdCore.CommandFunc {
	return func(ctx context.Context, args []string, cmdCtx cmdCore.CommandContext) error {
		root.DisableAutoGenTag = true

		output := GenerateMarkdownDoc(root)
		fmt.Println(string(output))

		return nil
	}
}

func GenerateMarkdownDoc(cmd *cobra.Command) []byte {
	var buf bytes.Buffer

	// Simple link handler (for anchor links)
	linkHandler := func(name string) string {
		return "#" + strings.ToLower(strings.ReplaceAll(name, " ", "-"))
	}

	var walk func(c *cobra.Command)
	walk = func(c *cobra.Command) {
		mdBuf := new(bytes.Buffer)
		_ = doc.GenMarkdownCustom(c, mdBuf, linkHandler)

		// Convert code block flag sections to table format
		stripped := removeAllGeneratedHeadings(mdBuf.String())
		cleaned := removeSeeAlsoSection(stripped)
		escaped := escapeHtml(cleaned)
		converted := convertFlagBlockToTable(escaped)

		buf.WriteString("\n---\n\n")

		title := strings.TrimSpace(c.CommandPath())
		buf.WriteString(fmt.Sprintf("## `%s`\n\n", title))
		buf.WriteString(converted)

		for _, sub := range c.Commands() {
			if !sub.IsAvailableCommand() {
				continue
			}
			walk(sub)
		}
	}

	walk(cmd)
	return buf.Bytes()
}

func convertFlagBlockToTable(md string) string {
	return convertFlagBlockToTableSection("Options",
		convertFlagBlockToTableSection("Options inherited from parent commands", md),
	)
}

func convertFlagBlockToTableSection(section string, md string) string {
	re := regexp.MustCompile(fmt.Sprintf("(?s)### %s\\s*\n```.*?\n(.*?)```", section))

	return re.ReplaceAllStringFunc(md, func(match string) string {
		flagsBlock := re.FindStringSubmatch(match)

		lines := strings.Split(flagsBlock[1], "\n")
		var rows []string

		for _, line := range lines {
			line = strings.TrimSpace(line)
			if line == "" {
				continue
			}
			parts := strings.Fields(line)

			// Merge the rest as the description
			flag := parts[0]
			desc := strings.Join(parts[1:], " ")
			rows = append(rows, fmt.Sprintf("| `%s` | %s |", flag, desc))
		}

		var table strings.Builder
		table.WriteString(fmt.Sprintf("\n### %s\n\n", section))
		table.WriteString("| Flag | Description |\n")
		table.WriteString("|------|-------------|\n")
		for _, row := range rows {
			table.WriteString(row + "\n")
		}

		return table.String()
	})
}

func removeSeeAlsoSection(md string) string {
	lines := strings.Split(md, "\n")
	var out []string
	skip := false

	for i := 0; i < len(lines); i++ {
		line := lines[i]
		if strings.HasPrefix(line, "### SEE ALSO") {
			skip = true
			continue
		}
		// Stop skipping once we hit another level-3 heading
		if skip && strings.HasPrefix(line, "### ") {
			skip = false
		}
		if !skip {
			out = append(out, line)
		}
	}
	return strings.Join(out, "\n")
}

func removeAllGeneratedHeadings(md string) string {
	lines := strings.Split(md, "\n")
	var out []string

	for _, line := range lines {
		// Keep the line only if it's NOT a heading like "## something something"
		// UNLESS it is already in backticks (your manually added heading)
		if strings.HasPrefix(line, "## ") && !strings.Contains(line, "`") {
			continue // skip autogenerated Cobra headings
		}
		out = append(out, line)
	}
	return strings.Join(out, "\n")
}

func escapeHtml(s string) string {
	return strings.ReplaceAll(strings.ReplaceAll(s, "<", "&lt;"), ">", "&gt;")
}
