syntax = "proto3";

package flyteidl2.workflow;

import "idl2/common/identifier.proto";
import "idl2/core/types.proto";
import "google/protobuf/timestamp.proto";
import "google/protobuf/wrappers.proto";
import "validate/validate.proto";
import "idl2/workflow/run_definition.proto";
import "idl2/workflow/task_definition.proto";

option go_package = "github.com/flyteorg/flyte/v2/gen/go/idl2/workflow";

// provides an interface for managing execution of runs over a collection of workers.
service QueueService {
  // queue a new action for execution.
  rpc EnqueueAction(EnqueueActionRequest) returns (EnqueueActionResponse) {}

  // abort a queued run.
  rpc AbortQueuedRun(AbortQueuedRunRequest) returns (AbortQueuedRunResponse) {}

  // AbortAction aborts a single action that was previously queued or is currently being processed by a worker.
  rpc AbortQueuedAction(AbortQueuedActionRequest) returns (AbortQueuedActionResponse) {}
}

// request message for queuing an action.
message EnqueueActionRequest {
  // the unique identifier for the action.
  flyteidl2.common.ActionIdentifier action_id = 1 [(validate.rules).message.required = true];

  // an optional name for the parent action, if it exists. the remaining run metadata (ex. org,
  // project, domain) will be the same as the action_id defined above.
  optional string parent_action_name = 2;

  // Optional run spec passed in by the root action to be utilized by all downstream actions in the run.
  RunSpec run_spec = 3;

  // the path to the input data for this action.
  string input_uri = 6 [(validate.rules).string.min_len = 1];

  // the run base path this action should write its output to.
  string run_output_base = 7 [(validate.rules).string.min_len = 1];

  // group this action belongs to, if applicable.
  string group = 8;

  // subject that created the run, if known.
  string subject = 9;

  oneof spec {
    // TODO(haytham): Uncomment when we update all code paths to use this.
    // option (validate.required) = true;
    TaskAction task = 10 [(validate.rules).message.required = true];
    TraceAction trace = 11 [(validate.rules).message.required = true];
    ConditionAction condition = 12 [(validate.rules).message.required = true];
  }
}

message TaskAction {
  // a unique identifier for the task this action is associated with, if applicable.
  TaskIdentifier id = 1;

  // the definition of the task to be executed.
  TaskSpec spec = 2 [(validate.rules).message.required = true];

  // Enables caching when set and specifies the cache version to use.
  google.protobuf.StringValue cache_key = 3;

  // the specific cluster that this action should be executed on. if not set, the cluster from the
  // `RunSpec` will be used.
  string cluster = 4;
}

// TraceAction is used to define a trace action that can be used to track the execution of an action that's managed
// by the local worker. This can be used to bring determinism to code that's otherwise not deterministic (e.g. current
// time).
message TraceAction {
  string name = 1 [(validate.rules).string.min_len = 1];

  // Last known phase.
  Phase phase = 2;

  // Time the attempt started.
  google.protobuf.Timestamp start_time = 3;

  // Time the attempt ended, if applicable.
  optional google.protobuf.Timestamp end_time = 4;

  // Output references.
  OutputReferences outputs = 5;

  // Task spec for the trace, useful for the typed interface inside.
  TraceSpec spec = 6 [(validate.rules).message.required = true];
}

// ConditionAction is used to define a condition that can be evaluated at runtime. It can be used to
// await a signal from an external system and can carry a value.
message ConditionAction {
  // Name is the unique identifier for the action. It must be unique within the defined scope below.
  string name = 1 [(validate.rules).string.min_len = 1];

  oneof scope {
    option (validate.required) = true;
    // RunId is the unique identifier for the run this action is associated with.
    string run_id = 2 [(validate.rules).string.min_len = 1];

    // ActionId is the unique identifier for the action this action is associated with.
    string action_id = 3 [(validate.rules).string.min_len = 1];

    // Global indicates the condition is global and can be used across all runs and actions.
    bool global = 4;
  }

  // Type is the type of the value the condition is expected. This can be used to properly render
  // a UI element for the condition or validate when a value is received that it is of the expected
  // type.
  flyteidl2.core.LiteralType type = 6;

  // Prompt is the prompt that will be shown to the user when the condition is awaited.
  string prompt = 7;

  // Description is a description of the condition. This can be used to provide additional
  // information to the user about the condition.
  string description = 8;
}

// response message for queuing an action.
message EnqueueActionResponse {}

// request message for aborting a run.
message AbortQueuedRunRequest {
  // the unique identifier for the run to be aborted.
  common.RunIdentifier run_id = 1 [(validate.rules).message.required = true];

  // Reason for aborting the run, if applicable.
  optional string reason = 2;
}

// response message for aborting a run.
message AbortQueuedRunResponse {}

message AbortQueuedActionRequest {
  // ActionId is the unique identifier for the action to be aborted
  common.ActionIdentifier action_id = 1 [(validate.rules).message.required = true];

  // Reason for aborting the action, if applicable.
  optional string reason = 2;
}

message AbortQueuedActionResponse {}
