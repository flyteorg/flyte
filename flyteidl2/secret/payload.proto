syntax = "proto3";

package flyteidl2.secret;

import "buf/validate/validate.proto";
import "flyteidl2/secret/definition.proto";

option go_package = "github.com/flyteorg/flyte/v2/gen/go/flyteidl2/secret";

// CreateSecretProxyRequest contains the spec and identifier used for secret creation
message CreateSecretRequest {
  SecretIdentifier id = 1 [(buf.validate.field).required = true];
  SecretSpec secret_spec = 2;
}

// CreateSecretResponse
message CreateSecretResponse {}

// UpdateSecretProxyRequest contains the spec and identifier used for secret updation
message UpdateSecretRequest {
  SecretIdentifier id = 1 [(buf.validate.field).required = true];
  SecretSpec secret_spec = 2;
}

// UpdateSecretResponse returns an empty response if the secret is successfully updated
message UpdateSecretResponse {}

// GetSecretRequest contains the identifier used for looking up the secret
message GetSecretRequest {
  SecretIdentifier id = 1 [(buf.validate.field).required = true];
}

// GetSecretProxyResponse returns the looked up secret from the secret service
message GetSecretResponse {
  Secret secret = 1;
}

// DeleteSecretRequest contains the identifier used for looking up the secret for deletion
message DeleteSecretRequest {
  // name to be used for looking up the secret
  SecretIdentifier id = 1 [(buf.validate.field).required = true];
}

// DeleteSecretResponse is an empty response right now on successfully deleting the secret.
message DeleteSecretResponse {}

// ListSecretsRequest is used for listing all the secrets accessible to the user at the passed in scope.
// With org scope, user is given all secrets at org, domain, project-domain level etc
// And returns paginated results
message ListSecretsRequest {
  // Only org scoped resources are supported right now
  string organization = 1;
  // domain scoped secret
  string domain = 2;
  // Project-domain scoped secret
  string project = 3;
  // Max page results
  int32 limit = 4;
  // Leave this empty if you are getting the first set of results. The next_token would be set in the response that can be used to fetch the next set of results.
  string token = 5;
  // Per cluster token. This allows the service to return paginated results per cluster.
  // Service collates the results from all clusters and returns the next token for each cluster.
  // The client can use the next token for each cluster to fetch the next page of results.
  // In multi cluster, inorder to page through next set of results, client needs to send this token in the next request
  map<string, string> per_cluster_tokens = 6;
}

// ListSecretsResponse returns paginated results of the accessible secrets at the scope defined in the request.
message ListSecretsResponse {
  repeated Secret secrets = 1;
  // next token to use for fetching new page results.
  string token = 2;
  // Per cluster token. This allows the service to return paginated results per cluster.
  // Service collates the results from all clusters and returns the next token for each cluster.
  // The client can use the next token for each cluster to fetch the next page of results.
  // In multi cluster, inorder to page through next set of results, client needs to send this token in the next request
  map<string, string> per_cluster_tokens = 3;
}
