// @generated by protoc-gen-es v2.2.5 with parameter "target=ts,import_extension=.ts"
// @generated from file flyteidl2/connector/task.proto (package flyteidl2.connector, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import type { TaskExecution_Phase, TaskLog } from "../core/execution_pb.ts";
import { file_flyteidl2_core_execution } from "../core/execution_pb.ts";
import type { TaskExecutionIdentifier } from "../core/identifier_pb.ts";
import { file_flyteidl2_core_identifier } from "../core/identifier_pb.ts";
import type { ExecutionMetricResult } from "../core/metrics_pb.ts";
import { file_flyteidl2_core_metrics } from "../core/metrics_pb.ts";
import type { Connection, Identity } from "../core/security_pb.ts";
import { file_flyteidl2_core_security } from "../core/security_pb.ts";
import type { TaskTemplate } from "../core/tasks_pb.ts";
import { file_flyteidl2_core_tasks } from "../core/tasks_pb.ts";
import type { Inputs, Outputs } from "../task/common_pb.ts";
import { file_flyteidl2_task_common } from "../task/common_pb.ts";
import type { Duration, Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_duration, file_google_protobuf_struct, file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { JsonObject, Message } from "@bufbuild/protobuf";

/**
 * Describes the file flyteidl2/connector/task.proto.
 */
export const file_flyteidl2_connector_task: GenFile = /*@__PURE__*/
  fileDesc("Ch5mbHl0ZWlkbDIvY29ubmVjdG9yL3Rhc2sucHJvdG8SE2ZseXRlaWRsMi5jb25uZWN0b3IirAUKFVRhc2tFeGVjdXRpb25NZXRhZGF0YRJCChF0YXNrX2V4ZWN1dGlvbl9pZBgBIAEoCzInLmZseXRlaWRsMi5jb3JlLlRhc2tFeGVjdXRpb25JZGVudGlmaWVyEhEKCW5hbWVzcGFjZRgCIAEoCRJGCgZsYWJlbHMYAyADKAsyNi5mbHl0ZWlkbDIuY29ubmVjdG9yLlRhc2tFeGVjdXRpb25NZXRhZGF0YS5MYWJlbHNFbnRyeRJQCgthbm5vdGF0aW9ucxgEIAMoCzI7LmZseXRlaWRsMi5jb25uZWN0b3IuVGFza0V4ZWN1dGlvbk1ldGFkYXRhLkFubm90YXRpb25zRW50cnkSGwoTazhzX3NlcnZpY2VfYWNjb3VudBgFIAEoCRJjChVlbnZpcm9ubWVudF92YXJpYWJsZXMYBiADKAsyRC5mbHl0ZWlkbDIuY29ubmVjdG9yLlRhc2tFeGVjdXRpb25NZXRhZGF0YS5FbnZpcm9ubWVudFZhcmlhYmxlc0VudHJ5EhQKDG1heF9hdHRlbXB0cxgHIAEoBRIVCg1pbnRlcnJ1cHRpYmxlGAggASgIEicKH2ludGVycnVwdGlibGVfZmFpbHVyZV90aHJlc2hvbGQYCSABKAUSKgoIaWRlbnRpdHkYCyABKAsyGC5mbHl0ZWlkbDIuY29yZS5JZGVudGl0eRotCgtMYWJlbHNFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBGjIKEEFubm90YXRpb25zRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4ARo7ChlFbnZpcm9ubWVudFZhcmlhYmxlc0VudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAEi/wEKEUNyZWF0ZVRhc2tSZXF1ZXN0EiYKBmlucHV0cxgBIAEoCzIWLmZseXRlaWRsMi50YXNrLklucHV0cxIuCgh0ZW1wbGF0ZRgCIAEoCzIcLmZseXRlaWRsMi5jb3JlLlRhc2tUZW1wbGF0ZRIVCg1vdXRwdXRfcHJlZml4GAMgASgJEksKF3Rhc2tfZXhlY3V0aW9uX21ldGFkYXRhGAQgASgLMiouZmx5dGVpZGwyLmNvbm5lY3Rvci5UYXNrRXhlY3V0aW9uTWV0YWRhdGESLgoKY29ubmVjdGlvbhgFIAEoCzIaLmZseXRlaWRsMi5jb3JlLkNvbm5lY3Rpb24iKwoSQ3JlYXRlVGFza1Jlc3BvbnNlEhUKDXJlc291cmNlX21ldGEYASABKAwi+QEKE0NyZWF0ZVJlcXVlc3RIZWFkZXISLgoIdGVtcGxhdGUYASABKAsyHC5mbHl0ZWlkbDIuY29yZS5UYXNrVGVtcGxhdGUSFQoNb3V0cHV0X3ByZWZpeBgCIAEoCRJLChd0YXNrX2V4ZWN1dGlvbl9tZXRhZGF0YRgDIAEoCzIqLmZseXRlaWRsMi5jb25uZWN0b3IuVGFza0V4ZWN1dGlvbk1ldGFkYXRhEh4KFm1heF9kYXRhc2V0X3NpemVfYnl0ZXMYBCABKAMSLgoKY29ubmVjdGlvbhgFIAEoCzIaLmZseXRlaWRsMi5jb3JlLkNvbm5lY3Rpb24iqAEKDkdldFRhc2tSZXF1ZXN0EhUKDXJlc291cmNlX21ldGEYAiABKAwSOAoNdGFza19jYXRlZ29yeRgDIAEoCzIhLmZseXRlaWRsMi5jb25uZWN0b3IuVGFza0NhdGVnb3J5EhUKDW91dHB1dF9wcmVmaXgYBCABKAkSLgoKY29ubmVjdGlvbhgFIAEoCzIaLmZseXRlaWRsMi5jb3JlLkNvbm5lY3Rpb24iQgoPR2V0VGFza1Jlc3BvbnNlEi8KCHJlc291cmNlGAEgASgLMh0uZmx5dGVpZGwyLmNvbm5lY3Rvci5SZXNvdXJjZSLTAQoIUmVzb3VyY2USKAoHb3V0cHV0cxgCIAEoCzIXLmZseXRlaWRsMi50YXNrLk91dHB1dHMSDwoHbWVzc2FnZRgDIAEoCRIqCglsb2dfbGlua3MYBCADKAsyFy5mbHl0ZWlkbDIuY29yZS5UYXNrTG9nEjIKBXBoYXNlGAUgASgOMiMuZmx5dGVpZGwyLmNvcmUuVGFza0V4ZWN1dGlvbi5QaGFzZRIsCgtjdXN0b21faW5mbxgGIAEoCzIXLmdvb2dsZS5wcm90b2J1Zi5TdHJ1Y3QilAEKEURlbGV0ZVRhc2tSZXF1ZXN0EhUKDXJlc291cmNlX21ldGEYAiABKAwSOAoNdGFza19jYXRlZ29yeRgDIAEoCzIhLmZseXRlaWRsMi5jb25uZWN0b3IuVGFza0NhdGVnb3J5Ei4KCmNvbm5lY3Rpb24YBSABKAsyGi5mbHl0ZWlkbDIuY29yZS5Db25uZWN0aW9uIhQKEkRlbGV0ZVRhc2tSZXNwb25zZSJfCglDb25uZWN0b3ISDAoEbmFtZRgBIAEoCRJEChlzdXBwb3J0ZWRfdGFza19jYXRlZ29yaWVzGAQgAygLMiEuZmx5dGVpZGwyLmNvbm5lY3Rvci5UYXNrQ2F0ZWdvcnkiLQoMVGFza0NhdGVnb3J5EgwKBG5hbWUYASABKAkSDwoHdmVyc2lvbhgCIAEoBSIjChNHZXRDb25uZWN0b3JSZXF1ZXN0EgwKBG5hbWUYASABKAkiSQoUR2V0Q29ubmVjdG9yUmVzcG9uc2USMQoJY29ubmVjdG9yGAEgASgLMh4uZmx5dGVpZGwyLmNvbm5lY3Rvci5Db25uZWN0b3IiFwoVTGlzdENvbm5lY3RvcnNSZXF1ZXN0IkwKFkxpc3RDb25uZWN0b3JzUmVzcG9uc2USMgoKY29ubmVjdG9ycxgBIAMoCzIeLmZseXRlaWRsMi5jb25uZWN0b3IuQ29ubmVjdG9yIoACChVHZXRUYXNrTWV0cmljc1JlcXVlc3QSFQoNcmVzb3VyY2VfbWV0YRgCIAEoDBIPCgdxdWVyaWVzGAMgAygJEi4KCnN0YXJ0X3RpbWUYBCABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEiwKCGVuZF90aW1lGAUgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBInCgRzdGVwGAYgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uEjgKDXRhc2tfY2F0ZWdvcnkYByABKAsyIS5mbHl0ZWlkbDIuY29ubmVjdG9yLlRhc2tDYXRlZ29yeSJQChZHZXRUYXNrTWV0cmljc1Jlc3BvbnNlEjYKB3Jlc3VsdHMYASADKAsyJS5mbHl0ZWlkbDIuY29yZS5FeGVjdXRpb25NZXRyaWNSZXN1bHQigwEKEkdldFRhc2tMb2dzUmVxdWVzdBIVCg1yZXNvdXJjZV9tZXRhGAIgASgMEg0KBWxpbmVzGAMgASgEEg0KBXRva2VuGAQgASgJEjgKDXRhc2tfY2F0ZWdvcnkYBSABKAsyIS5mbHl0ZWlkbDIuY29ubmVjdG9yLlRhc2tDYXRlZ29yeSIqChlHZXRUYXNrTG9nc1Jlc3BvbnNlSGVhZGVyEg0KBXRva2VuGAEgASgJIioKF0dldFRhc2tMb2dzUmVzcG9uc2VCb2R5Eg8KB3Jlc3VsdHMYASADKAkinQEKE0dldFRhc2tMb2dzUmVzcG9uc2USQAoGaGVhZGVyGAEgASgLMi4uZmx5dGVpZGwyLmNvbm5lY3Rvci5HZXRUYXNrTG9nc1Jlc3BvbnNlSGVhZGVySAASPAoEYm9keRgCIAEoCzIsLmZseXRlaWRsMi5jb25uZWN0b3IuR2V0VGFza0xvZ3NSZXNwb25zZUJvZHlIAEIGCgRwYXJ0QswBChdjb20uZmx5dGVpZGwyLmNvbm5lY3RvckIJVGFza1Byb3RvSAJQAVo3Z2l0aHViLmNvbS9mbHl0ZW9yZy9mbHl0ZS92Mi9nZW4vZ28vZmx5dGVpZGwyL2Nvbm5lY3RvcqICA0ZDWKoCE0ZseXRlaWRsMi5Db25uZWN0b3LKAhNGbHl0ZWlkbDJcQ29ubmVjdG9y4gIfRmx5dGVpZGwyXENvbm5lY3RvclxHUEJNZXRhZGF0YeoCFEZseXRlaWRsMjo6Q29ubmVjdG9yYgZwcm90bzM", [file_flyteidl2_core_execution, file_flyteidl2_core_identifier, file_flyteidl2_core_metrics, file_flyteidl2_core_security, file_flyteidl2_core_tasks, file_flyteidl2_task_common, file_google_protobuf_duration, file_google_protobuf_struct, file_google_protobuf_timestamp]);

/**
 * Represents a subset of runtime task execution metadata that are relevant to external plugins.
 *
 * ID of the task execution
 *
 * @generated from message flyteidl2.connector.TaskExecutionMetadata
 */
export type TaskExecutionMetadata = Message<"flyteidl2.connector.TaskExecutionMetadata"> & {
  /**
   * @generated from field: flyteidl2.core.TaskExecutionIdentifier task_execution_id = 1;
   */
  taskExecutionId?: TaskExecutionIdentifier;

  /**
   * k8s namespace where the task is executed in
   *
   * @generated from field: string namespace = 2;
   */
  namespace: string;

  /**
   * Labels attached to the task execution
   *
   * @generated from field: map<string, string> labels = 3;
   */
  labels: { [key: string]: string };

  /**
   * Annotations attached to the task execution
   *
   * @generated from field: map<string, string> annotations = 4;
   */
  annotations: { [key: string]: string };

  /**
   * k8s service account associated with the task execution
   *
   * @generated from field: string k8s_service_account = 5;
   */
  k8sServiceAccount: string;

  /**
   * Environment variables attached to the task execution
   *
   * @generated from field: map<string, string> environment_variables = 6;
   */
  environmentVariables: { [key: string]: string };

  /**
   * Represents the maximum number of attempts allowed for a task.
   * If a task fails, it can be retried up to this maximum number of attempts.
   *
   * @generated from field: int32 max_attempts = 7;
   */
  maxAttempts: number;

  /**
   * Indicates whether the task execution can be interrupted.
   * If set to true, the task can be stopped before completion.
   *
   * @generated from field: bool interruptible = 8;
   */
  interruptible: boolean;

  /**
   * Specifies the threshold for failure count at which the interruptible property
   * will take effect. If the number of consecutive task failures exceeds this threshold,
   * interruptible behavior will be activated.
   *
   * @generated from field: int32 interruptible_failure_threshold = 9;
   */
  interruptibleFailureThreshold: number;

  /**
   * Identity of user running this task execution
   *
   * @generated from field: flyteidl2.core.Identity identity = 11;
   */
  identity?: Identity;
};

/**
 * Describes the message flyteidl2.connector.TaskExecutionMetadata.
 * Use `create(TaskExecutionMetadataSchema)` to create a new message.
 */
export const TaskExecutionMetadataSchema: GenMessage<TaskExecutionMetadata> = /*@__PURE__*/
  messageDesc(file_flyteidl2_connector_task, 0);

/**
 * Represents a request structure to create task.
 *
 * @generated from message flyteidl2.connector.CreateTaskRequest
 */
export type CreateTaskRequest = Message<"flyteidl2.connector.CreateTaskRequest"> & {
  /**
   * The inputs required to start the execution. All required inputs must be
   * included in this map. If not required and not provided, defaults apply.
   * +optional
   *
   * @generated from field: flyteidl2.task.Inputs inputs = 1;
   */
  inputs?: Inputs;

  /**
   * Template of the task that encapsulates all the metadata of the task.
   *
   * @generated from field: flyteidl2.core.TaskTemplate template = 2;
   */
  template?: TaskTemplate;

  /**
   * Prefix for where task output data will be written. (e.g. s3://my-bucket/randomstring)
   *
   * @generated from field: string output_prefix = 3;
   */
  outputPrefix: string;

  /**
   * subset of runtime task execution metadata.
   *
   * @generated from field: flyteidl2.connector.TaskExecutionMetadata task_execution_metadata = 4;
   */
  taskExecutionMetadata?: TaskExecutionMetadata;

  /**
   * Connection (secret and config) required by the connector.
   * Connector will use the secret and config in the taskTemplate if it's None.
   * +optional
   *
   * @generated from field: flyteidl2.core.Connection connection = 5;
   */
  connection?: Connection;
};

/**
 * Describes the message flyteidl2.connector.CreateTaskRequest.
 * Use `create(CreateTaskRequestSchema)` to create a new message.
 */
export const CreateTaskRequestSchema: GenMessage<CreateTaskRequest> = /*@__PURE__*/
  messageDesc(file_flyteidl2_connector_task, 1);

/**
 * Represents a create response structure.
 *
 * @generated from message flyteidl2.connector.CreateTaskResponse
 */
export type CreateTaskResponse = Message<"flyteidl2.connector.CreateTaskResponse"> & {
  /**
   * ResourceMeta is created by the connector. It could be a string (jobId) or a dict (more complex metadata).
   *
   * @generated from field: bytes resource_meta = 1;
   */
  resourceMeta: Uint8Array;
};

/**
 * Describes the message flyteidl2.connector.CreateTaskResponse.
 * Use `create(CreateTaskResponseSchema)` to create a new message.
 */
export const CreateTaskResponseSchema: GenMessage<CreateTaskResponse> = /*@__PURE__*/
  messageDesc(file_flyteidl2_connector_task, 2);

/**
 * @generated from message flyteidl2.connector.CreateRequestHeader
 */
export type CreateRequestHeader = Message<"flyteidl2.connector.CreateRequestHeader"> & {
  /**
   * Template of the task that encapsulates all the metadata of the task.
   *
   * @generated from field: flyteidl2.core.TaskTemplate template = 1;
   */
  template?: TaskTemplate;

  /**
   * Prefix for where task output data will be written. (e.g. s3://my-bucket/randomstring)
   *
   * @generated from field: string output_prefix = 2;
   */
  outputPrefix: string;

  /**
   * subset of runtime task execution metadata.
   *
   * @generated from field: flyteidl2.connector.TaskExecutionMetadata task_execution_metadata = 3;
   */
  taskExecutionMetadata?: TaskExecutionMetadata;

  /**
   * MaxDatasetSizeBytes is the maximum size of the dataset that can be generated by the task.
   *
   * @generated from field: int64 max_dataset_size_bytes = 4;
   */
  maxDatasetSizeBytes: bigint;

  /**
   * Connection (secret and config) required by the connector.
   * Connector will use the secret and config in the taskTemplate if it's None.
   * +optional
   *
   * @generated from field: flyteidl2.core.Connection connection = 5;
   */
  connection?: Connection;
};

/**
 * Describes the message flyteidl2.connector.CreateRequestHeader.
 * Use `create(CreateRequestHeaderSchema)` to create a new message.
 */
export const CreateRequestHeaderSchema: GenMessage<CreateRequestHeader> = /*@__PURE__*/
  messageDesc(file_flyteidl2_connector_task, 3);

/**
 * A message used to fetch a job resource from flyte connector server.
 *
 * @generated from message flyteidl2.connector.GetTaskRequest
 */
export type GetTaskRequest = Message<"flyteidl2.connector.GetTaskRequest"> & {
  /**
   * Metadata about the resource to be pass to the connector.
   *
   * @generated from field: bytes resource_meta = 2;
   */
  resourceMeta: Uint8Array;

  /**
   * A predefined yet extensible Task type identifier.
   *
   * @generated from field: flyteidl2.connector.TaskCategory task_category = 3;
   */
  taskCategory?: TaskCategory;

  /**
   * Prefix for where task output data will be written. (e.g. s3://my-bucket/randomstring)
   *
   * @generated from field: string output_prefix = 4;
   */
  outputPrefix: string;

  /**
   * Connection (secret and config) required by the connector.
   * Connector will use the secret and config in the taskTemplate if it's None.
   * +optional
   *
   * @generated from field: flyteidl2.core.Connection connection = 5;
   */
  connection?: Connection;
};

/**
 * Describes the message flyteidl2.connector.GetTaskRequest.
 * Use `create(GetTaskRequestSchema)` to create a new message.
 */
export const GetTaskRequestSchema: GenMessage<GetTaskRequest> = /*@__PURE__*/
  messageDesc(file_flyteidl2_connector_task, 4);

/**
 * Response to get an individual task resource.
 *
 * @generated from message flyteidl2.connector.GetTaskResponse
 */
export type GetTaskResponse = Message<"flyteidl2.connector.GetTaskResponse"> & {
  /**
   * @generated from field: flyteidl2.connector.Resource resource = 1;
   */
  resource?: Resource;
};

/**
 * Describes the message flyteidl2.connector.GetTaskResponse.
 * Use `create(GetTaskResponseSchema)` to create a new message.
 */
export const GetTaskResponseSchema: GenMessage<GetTaskResponse> = /*@__PURE__*/
  messageDesc(file_flyteidl2_connector_task, 5);

/**
 * @generated from message flyteidl2.connector.Resource
 */
export type Resource = Message<"flyteidl2.connector.Resource"> & {
  /**
   * The outputs of the execution. It's typically used by sql task. connector service will create a
   * Structured dataset pointing to the query result table.
   * +optional
   *
   * @generated from field: flyteidl2.task.Outputs outputs = 2;
   */
  outputs?: Outputs;

  /**
   * A descriptive message for the current state. e.g. waiting for cluster.
   *
   * @generated from field: string message = 3;
   */
  message: string;

  /**
   * log information for the task execution.
   *
   * @generated from field: repeated flyteidl2.core.TaskLog log_links = 4;
   */
  logLinks: TaskLog[];

  /**
   * The phase of the execution is used to determine the phase of the plugin's execution.
   *
   * @generated from field: flyteidl2.core.TaskExecution.Phase phase = 5;
   */
  phase: TaskExecution_Phase;

  /**
   * Custom data specific to the connector.
   *
   * @generated from field: google.protobuf.Struct custom_info = 6;
   */
  customInfo?: JsonObject;
};

/**
 * Describes the message flyteidl2.connector.Resource.
 * Use `create(ResourceSchema)` to create a new message.
 */
export const ResourceSchema: GenMessage<Resource> = /*@__PURE__*/
  messageDesc(file_flyteidl2_connector_task, 6);

/**
 * A message used to delete a task.
 *
 * @generated from message flyteidl2.connector.DeleteTaskRequest
 */
export type DeleteTaskRequest = Message<"flyteidl2.connector.DeleteTaskRequest"> & {
  /**
   * Metadata about the resource to be pass to the connector.
   *
   * @generated from field: bytes resource_meta = 2;
   */
  resourceMeta: Uint8Array;

  /**
   * A predefined yet extensible Task type identifier.
   *
   * @generated from field: flyteidl2.connector.TaskCategory task_category = 3;
   */
  taskCategory?: TaskCategory;

  /**
   * Connection (secret and config) required by the connector.
   * Connector will use the secret and config in the taskTemplate if it's None.
   * +optional
   *
   * @generated from field: flyteidl2.core.Connection connection = 5;
   */
  connection?: Connection;
};

/**
 * Describes the message flyteidl2.connector.DeleteTaskRequest.
 * Use `create(DeleteTaskRequestSchema)` to create a new message.
 */
export const DeleteTaskRequestSchema: GenMessage<DeleteTaskRequest> = /*@__PURE__*/
  messageDesc(file_flyteidl2_connector_task, 7);

/**
 * Response to delete a task.
 *
 * @generated from message flyteidl2.connector.DeleteTaskResponse
 */
export type DeleteTaskResponse = Message<"flyteidl2.connector.DeleteTaskResponse"> & {
};

/**
 * Describes the message flyteidl2.connector.DeleteTaskResponse.
 * Use `create(DeleteTaskResponseSchema)` to create a new message.
 */
export const DeleteTaskResponseSchema: GenMessage<DeleteTaskResponse> = /*@__PURE__*/
  messageDesc(file_flyteidl2_connector_task, 8);

/**
 * A message containing the connector metadata.
 *
 * @generated from message flyteidl2.connector.Connector
 */
export type Connector = Message<"flyteidl2.connector.Connector"> & {
  /**
   * Name is the developer-assigned name of the connector.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * Supported_task_categories are the categories of the tasks that the connector can handle.
   *
   * @generated from field: repeated flyteidl2.connector.TaskCategory supported_task_categories = 4;
   */
  supportedTaskCategories: TaskCategory[];
};

/**
 * Describes the message flyteidl2.connector.Connector.
 * Use `create(ConnectorSchema)` to create a new message.
 */
export const ConnectorSchema: GenMessage<Connector> = /*@__PURE__*/
  messageDesc(file_flyteidl2_connector_task, 9);

/**
 * @generated from message flyteidl2.connector.TaskCategory
 */
export type TaskCategory = Message<"flyteidl2.connector.TaskCategory"> & {
  /**
   * The name of the task type.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The version of the task type.
   *
   * @generated from field: int32 version = 2;
   */
  version: number;
};

/**
 * Describes the message flyteidl2.connector.TaskCategory.
 * Use `create(TaskCategorySchema)` to create a new message.
 */
export const TaskCategorySchema: GenMessage<TaskCategory> = /*@__PURE__*/
  messageDesc(file_flyteidl2_connector_task, 10);

/**
 * A request to get an connector.
 *
 * @generated from message flyteidl2.connector.GetConnectorRequest
 */
export type GetConnectorRequest = Message<"flyteidl2.connector.GetConnectorRequest"> & {
  /**
   * The name of the connector.
   *
   * @generated from field: string name = 1;
   */
  name: string;
};

/**
 * Describes the message flyteidl2.connector.GetConnectorRequest.
 * Use `create(GetConnectorRequestSchema)` to create a new message.
 */
export const GetConnectorRequestSchema: GenMessage<GetConnectorRequest> = /*@__PURE__*/
  messageDesc(file_flyteidl2_connector_task, 11);

/**
 * A response containing an connector.
 *
 * @generated from message flyteidl2.connector.GetConnectorResponse
 */
export type GetConnectorResponse = Message<"flyteidl2.connector.GetConnectorResponse"> & {
  /**
   * @generated from field: flyteidl2.connector.Connector connector = 1;
   */
  connector?: Connector;
};

/**
 * Describes the message flyteidl2.connector.GetConnectorResponse.
 * Use `create(GetConnectorResponseSchema)` to create a new message.
 */
export const GetConnectorResponseSchema: GenMessage<GetConnectorResponse> = /*@__PURE__*/
  messageDesc(file_flyteidl2_connector_task, 12);

/**
 * A request to list all connectors.
 *
 * @generated from message flyteidl2.connector.ListConnectorsRequest
 */
export type ListConnectorsRequest = Message<"flyteidl2.connector.ListConnectorsRequest"> & {
};

/**
 * Describes the message flyteidl2.connector.ListConnectorsRequest.
 * Use `create(ListConnectorsRequestSchema)` to create a new message.
 */
export const ListConnectorsRequestSchema: GenMessage<ListConnectorsRequest> = /*@__PURE__*/
  messageDesc(file_flyteidl2_connector_task, 13);

/**
 * A response containing a list of connectors.
 *
 * @generated from message flyteidl2.connector.ListConnectorsResponse
 */
export type ListConnectorsResponse = Message<"flyteidl2.connector.ListConnectorsResponse"> & {
  /**
   * @generated from field: repeated flyteidl2.connector.Connector connectors = 1;
   */
  connectors: Connector[];
};

/**
 * Describes the message flyteidl2.connector.ListConnectorsResponse.
 * Use `create(ListConnectorsResponseSchema)` to create a new message.
 */
export const ListConnectorsResponseSchema: GenMessage<ListConnectorsResponse> = /*@__PURE__*/
  messageDesc(file_flyteidl2_connector_task, 14);

/**
 * A request to get the metrics from a task execution.
 *
 * @generated from message flyteidl2.connector.GetTaskMetricsRequest
 */
export type GetTaskMetricsRequest = Message<"flyteidl2.connector.GetTaskMetricsRequest"> & {
  /**
   * Metadata is created by the connector. It could be a string (jobId) or a dict (more complex metadata).
   *
   * @generated from field: bytes resource_meta = 2;
   */
  resourceMeta: Uint8Array;

  /**
   * The metrics to query. If empty, will return a default set of metrics.
   * e.g. EXECUTION_METRIC_USED_CPU_AVG or EXECUTION_METRIC_USED_MEMORY_BYTES_AVG
   *
   * @generated from field: repeated string queries = 3;
   */
  queries: string[];

  /**
   * Start timestamp, inclusive.
   *
   * @generated from field: google.protobuf.Timestamp start_time = 4;
   */
  startTime?: Timestamp;

  /**
   * End timestamp, inclusive..
   *
   * @generated from field: google.protobuf.Timestamp end_time = 5;
   */
  endTime?: Timestamp;

  /**
   * Query resolution step width in duration format or float number of seconds.
   *
   * @generated from field: google.protobuf.Duration step = 6;
   */
  step?: Duration;

  /**
   * A predefined yet extensible Task type identifier.
   *
   * @generated from field: flyteidl2.connector.TaskCategory task_category = 7;
   */
  taskCategory?: TaskCategory;
};

/**
 * Describes the message flyteidl2.connector.GetTaskMetricsRequest.
 * Use `create(GetTaskMetricsRequestSchema)` to create a new message.
 */
export const GetTaskMetricsRequestSchema: GenMessage<GetTaskMetricsRequest> = /*@__PURE__*/
  messageDesc(file_flyteidl2_connector_task, 15);

/**
 * A response containing a list of metrics for a task execution.
 *
 * @generated from message flyteidl2.connector.GetTaskMetricsResponse
 */
export type GetTaskMetricsResponse = Message<"flyteidl2.connector.GetTaskMetricsResponse"> & {
  /**
   * The execution metric results.
   *
   * @generated from field: repeated flyteidl2.core.ExecutionMetricResult results = 1;
   */
  results: ExecutionMetricResult[];
};

/**
 * Describes the message flyteidl2.connector.GetTaskMetricsResponse.
 * Use `create(GetTaskMetricsResponseSchema)` to create a new message.
 */
export const GetTaskMetricsResponseSchema: GenMessage<GetTaskMetricsResponse> = /*@__PURE__*/
  messageDesc(file_flyteidl2_connector_task, 16);

/**
 * A request to get the log from a task execution.
 *
 * @generated from message flyteidl2.connector.GetTaskLogsRequest
 */
export type GetTaskLogsRequest = Message<"flyteidl2.connector.GetTaskLogsRequest"> & {
  /**
   * Metadata is created by the connector. It could be a string (jobId) or a dict (more complex metadata).
   *
   * @generated from field: bytes resource_meta = 2;
   */
  resourceMeta: Uint8Array;

  /**
   * Number of lines to return.
   *
   * @generated from field: uint64 lines = 3;
   */
  lines: bigint;

  /**
   * In the case of multiple pages of results, the server-provided token can be used to fetch the next page
   * in a query. If there are no more results, this value will be empty.
   *
   * @generated from field: string token = 4;
   */
  token: string;

  /**
   * A predefined yet extensible Task type identifier.
   *
   * @generated from field: flyteidl2.connector.TaskCategory task_category = 5;
   */
  taskCategory?: TaskCategory;
};

/**
 * Describes the message flyteidl2.connector.GetTaskLogsRequest.
 * Use `create(GetTaskLogsRequestSchema)` to create a new message.
 */
export const GetTaskLogsRequestSchema: GenMessage<GetTaskLogsRequest> = /*@__PURE__*/
  messageDesc(file_flyteidl2_connector_task, 17);

/**
 * @generated from message flyteidl2.connector.GetTaskLogsResponseHeader
 */
export type GetTaskLogsResponseHeader = Message<"flyteidl2.connector.GetTaskLogsResponseHeader"> & {
  /**
   * In the case of multiple pages of results, the server-provided token can be used to fetch the next page
   * in a query. If there are no more results, this value will be empty.
   *
   * @generated from field: string token = 1;
   */
  token: string;
};

/**
 * Describes the message flyteidl2.connector.GetTaskLogsResponseHeader.
 * Use `create(GetTaskLogsResponseHeaderSchema)` to create a new message.
 */
export const GetTaskLogsResponseHeaderSchema: GenMessage<GetTaskLogsResponseHeader> = /*@__PURE__*/
  messageDesc(file_flyteidl2_connector_task, 18);

/**
 * @generated from message flyteidl2.connector.GetTaskLogsResponseBody
 */
export type GetTaskLogsResponseBody = Message<"flyteidl2.connector.GetTaskLogsResponseBody"> & {
  /**
   * The execution log results.
   *
   * @generated from field: repeated string results = 1;
   */
  results: string[];
};

/**
 * Describes the message flyteidl2.connector.GetTaskLogsResponseBody.
 * Use `create(GetTaskLogsResponseBodySchema)` to create a new message.
 */
export const GetTaskLogsResponseBodySchema: GenMessage<GetTaskLogsResponseBody> = /*@__PURE__*/
  messageDesc(file_flyteidl2_connector_task, 19);

/**
 * A response containing the logs for a task execution.
 *
 * @generated from message flyteidl2.connector.GetTaskLogsResponse
 */
export type GetTaskLogsResponse = Message<"flyteidl2.connector.GetTaskLogsResponse"> & {
  /**
   * @generated from oneof flyteidl2.connector.GetTaskLogsResponse.part
   */
  part: {
    /**
     * @generated from field: flyteidl2.connector.GetTaskLogsResponseHeader header = 1;
     */
    value: GetTaskLogsResponseHeader;
    case: "header";
  } | {
    /**
     * @generated from field: flyteidl2.connector.GetTaskLogsResponseBody body = 2;
     */
    value: GetTaskLogsResponseBody;
    case: "body";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message flyteidl2.connector.GetTaskLogsResponse.
 * Use `create(GetTaskLogsResponseSchema)` to create a new message.
 */
export const GetTaskLogsResponseSchema: GenMessage<GetTaskLogsResponse> = /*@__PURE__*/
  messageDesc(file_flyteidl2_connector_task, 20);

