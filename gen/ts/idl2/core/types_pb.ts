// @generated by protoc-gen-es v2.2.5 with parameter "target=ts,import_extension=.ts"
// @generated from file idl2/core/types.proto (package flyteidl2.core, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import { file_google_protobuf_struct } from "@bufbuild/protobuf/wkt";
import type { JsonObject, Message } from "@bufbuild/protobuf";

/**
 * Describes the file idl2/core/types.proto.
 */
export const file_idl2_core_types: GenFile = /*@__PURE__*/
  fileDesc("ChVpZGwyL2NvcmUvdHlwZXMucHJvdG8SDmZseXRlaWRsMi5jb3JlIo4CCgpTY2hlbWFUeXBlEjgKB2NvbHVtbnMYAyADKAsyJy5mbHl0ZWlkbDIuY29yZS5TY2hlbWFUeXBlLlNjaGVtYUNvbHVtbhrFAQoMU2NoZW1hQ29sdW1uEgwKBG5hbWUYASABKAkSRgoEdHlwZRgCIAEoDjI4LmZseXRlaWRsMi5jb3JlLlNjaGVtYVR5cGUuU2NoZW1hQ29sdW1uLlNjaGVtYUNvbHVtblR5cGUiXwoQU2NoZW1hQ29sdW1uVHlwZRILCgdJTlRFR0VSEAASCQoFRkxPQVQQARIKCgZTVFJJTkcQAhILCgdCT09MRUFOEAMSDAoIREFURVRJTUUQBBIMCghEVVJBVElPThAFIvwBChVTdHJ1Y3R1cmVkRGF0YXNldFR5cGUSRAoHY29sdW1ucxgBIAMoCzIzLmZseXRlaWRsMi5jb3JlLlN0cnVjdHVyZWREYXRhc2V0VHlwZS5EYXRhc2V0Q29sdW1uEg4KBmZvcm1hdBgCIAEoCRIcChRleHRlcm5hbF9zY2hlbWFfdHlwZRgDIAEoCRIdChVleHRlcm5hbF9zY2hlbWFfYnl0ZXMYBCABKAwaUAoNRGF0YXNldENvbHVtbhIMCgRuYW1lGAEgASgJEjEKDGxpdGVyYWxfdHlwZRgCIAEoCzIbLmZseXRlaWRsMi5jb3JlLkxpdGVyYWxUeXBlIpABCghCbG9iVHlwZRIOCgZmb3JtYXQYASABKAkSQwoOZGltZW5zaW9uYWxpdHkYAiABKA4yKy5mbHl0ZWlkbDIuY29yZS5CbG9iVHlwZS5CbG9iRGltZW5zaW9uYWxpdHkiLwoSQmxvYkRpbWVuc2lvbmFsaXR5EgoKBlNJTkdMRRAAEg0KCU1VTFRJUEFSVBABIhoKCEVudW1UeXBlEg4KBnZhbHVlcxgBIAMoCSI6CglVbmlvblR5cGUSLQoIdmFyaWFudHMYASADKAsyGy5mbHl0ZWlkbDIuY29yZS5MaXRlcmFsVHlwZSK5AQoNVHlwZVN0cnVjdHVyZRILCgN0YWcYASABKAkSSAoOZGF0YWNsYXNzX3R5cGUYAiADKAsyMC5mbHl0ZWlkbDIuY29yZS5UeXBlU3RydWN0dXJlLkRhdGFjbGFzc1R5cGVFbnRyeRpRChJEYXRhY2xhc3NUeXBlRW50cnkSCwoDa2V5GAEgASgJEioKBXZhbHVlGAIgASgLMhsuZmx5dGVpZGwyLmNvcmUuTGl0ZXJhbFR5cGU6AjgBIj4KDlR5cGVBbm5vdGF0aW9uEiwKC2Fubm90YXRpb25zGAEgASgLMhcuZ29vZ2xlLnByb3RvYnVmLlN0cnVjdCLFBAoLTGl0ZXJhbFR5cGUSLAoGc2ltcGxlGAEgASgOMhouZmx5dGVpZGwyLmNvcmUuU2ltcGxlVHlwZUgAEiwKBnNjaGVtYRgCIAEoCzIaLmZseXRlaWRsMi5jb3JlLlNjaGVtYVR5cGVIABI2Cg9jb2xsZWN0aW9uX3R5cGUYAyABKAsyGy5mbHl0ZWlkbDIuY29yZS5MaXRlcmFsVHlwZUgAEjUKDm1hcF92YWx1ZV90eXBlGAQgASgLMhsuZmx5dGVpZGwyLmNvcmUuTGl0ZXJhbFR5cGVIABIoCgRibG9iGAUgASgLMhguZmx5dGVpZGwyLmNvcmUuQmxvYlR5cGVIABItCgllbnVtX3R5cGUYByABKAsyGC5mbHl0ZWlkbDIuY29yZS5FbnVtVHlwZUgAEkgKF3N0cnVjdHVyZWRfZGF0YXNldF90eXBlGAggASgLMiUuZmx5dGVpZGwyLmNvcmUuU3RydWN0dXJlZERhdGFzZXRUeXBlSAASLwoKdW5pb25fdHlwZRgKIAEoCzIZLmZseXRlaWRsMi5jb3JlLlVuaW9uVHlwZUgAEikKCG1ldGFkYXRhGAYgASgLMhcuZ29vZ2xlLnByb3RvYnVmLlN0cnVjdBIyCgphbm5vdGF0aW9uGAkgASgLMh4uZmx5dGVpZGwyLmNvcmUuVHlwZUFubm90YXRpb24SMAoJc3RydWN0dXJlGAsgASgLMh0uZmx5dGVpZGwyLmNvcmUuVHlwZVN0cnVjdHVyZUIGCgR0eXBlImQKD091dHB1dFJlZmVyZW5jZRIPCgdub2RlX2lkGAEgASgJEgsKA3ZhchgCIAEoCRIzCglhdHRyX3BhdGgYAyADKAsyIC5mbHl0ZWlkbDIuY29yZS5Qcm9taXNlQXR0cmlidXRlIkgKEFByb21pc2VBdHRyaWJ1dGUSFgoMc3RyaW5nX3ZhbHVlGAEgASgJSAASEwoJaW50X3ZhbHVlGAIgASgFSABCBwoFdmFsdWUiMAoFRXJyb3ISFgoOZmFpbGVkX25vZGVfaWQYASABKAkSDwoHbWVzc2FnZRgCIAEoCSqGAQoKU2ltcGxlVHlwZRIICgROT05FEAASCwoHSU5URUdFUhABEgkKBUZMT0FUEAISCgoGU1RSSU5HEAMSCwoHQk9PTEVBThAEEgwKCERBVEVUSU1FEAUSDAoIRFVSQVRJT04QBhIKCgZCSU5BUlkQBxIJCgVFUlJPUhAIEgoKBlNUUlVDVBAJQqoBChJjb20uZmx5dGVpZGwyLmNvcmVCClR5cGVzUHJvdG9IAlABWi1naXRodWIuY29tL2ZseXRlb3JnL2ZseXRlL3YyL2dlbi9nby9pZGwyL2NvcmWiAgNGQ1iqAg5GbHl0ZWlkbDIuQ29yZcoCDkZseXRlaWRsMlxDb3Jl4gIaRmx5dGVpZGwyXENvcmVcR1BCTWV0YWRhdGHqAg9GbHl0ZWlkbDI6OkNvcmViBnByb3RvMw", [file_google_protobuf_struct]);

/**
 * Defines schema columns and types to strongly type-validate schemas interoperability.
 *
 * @generated from message flyteidl2.core.SchemaType
 */
export type SchemaType = Message<"flyteidl2.core.SchemaType"> & {
  /**
   * A list of ordered columns this schema comprises of.
   *
   * @generated from field: repeated flyteidl2.core.SchemaType.SchemaColumn columns = 3;
   */
  columns: SchemaType_SchemaColumn[];
};

/**
 * Describes the message flyteidl2.core.SchemaType.
 * Use `create(SchemaTypeSchema)` to create a new message.
 */
export const SchemaTypeSchema: GenMessage<SchemaType> = /*@__PURE__*/
  messageDesc(file_idl2_core_types, 0);

/**
 * @generated from message flyteidl2.core.SchemaType.SchemaColumn
 */
export type SchemaType_SchemaColumn = Message<"flyteidl2.core.SchemaType.SchemaColumn"> & {
  /**
   * A unique name -within the schema type- for the column
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The column type. This allows a limited set of types currently.
   *
   * @generated from field: flyteidl2.core.SchemaType.SchemaColumn.SchemaColumnType type = 2;
   */
  type: SchemaType_SchemaColumn_SchemaColumnType;
};

/**
 * Describes the message flyteidl2.core.SchemaType.SchemaColumn.
 * Use `create(SchemaType_SchemaColumnSchema)` to create a new message.
 */
export const SchemaType_SchemaColumnSchema: GenMessage<SchemaType_SchemaColumn> = /*@__PURE__*/
  messageDesc(file_idl2_core_types, 0, 0);

/**
 * @generated from enum flyteidl2.core.SchemaType.SchemaColumn.SchemaColumnType
 */
export enum SchemaType_SchemaColumn_SchemaColumnType {
  /**
   * @generated from enum value: INTEGER = 0;
   */
  INTEGER = 0,

  /**
   * @generated from enum value: FLOAT = 1;
   */
  FLOAT = 1,

  /**
   * @generated from enum value: STRING = 2;
   */
  STRING = 2,

  /**
   * @generated from enum value: BOOLEAN = 3;
   */
  BOOLEAN = 3,

  /**
   * @generated from enum value: DATETIME = 4;
   */
  DATETIME = 4,

  /**
   * @generated from enum value: DURATION = 5;
   */
  DURATION = 5,
}

/**
 * Describes the enum flyteidl2.core.SchemaType.SchemaColumn.SchemaColumnType.
 */
export const SchemaType_SchemaColumn_SchemaColumnTypeSchema: GenEnum<SchemaType_SchemaColumn_SchemaColumnType> = /*@__PURE__*/
  enumDesc(file_idl2_core_types, 0, 0, 0);

/**
 * @generated from message flyteidl2.core.StructuredDatasetType
 */
export type StructuredDatasetType = Message<"flyteidl2.core.StructuredDatasetType"> & {
  /**
   * A list of ordered columns this schema comprises of.
   *
   * @generated from field: repeated flyteidl2.core.StructuredDatasetType.DatasetColumn columns = 1;
   */
  columns: StructuredDatasetType_DatasetColumn[];

  /**
   * This is the storage format, the format of the bits at rest
   * parquet, feather, csv, etc.
   * For two types to be compatible, the format will need to be an exact match.
   *
   * @generated from field: string format = 2;
   */
  format: string;

  /**
   * This is a string representing the type that the bytes in external_schema_bytes are formatted in.
   * This is an optional field that will not be used for type checking.
   *
   * @generated from field: string external_schema_type = 3;
   */
  externalSchemaType: string;

  /**
   * The serialized bytes of a third-party schema library like Arrow.
   * This is an optional field that will not be used for type checking.
   *
   * @generated from field: bytes external_schema_bytes = 4;
   */
  externalSchemaBytes: Uint8Array;
};

/**
 * Describes the message flyteidl2.core.StructuredDatasetType.
 * Use `create(StructuredDatasetTypeSchema)` to create a new message.
 */
export const StructuredDatasetTypeSchema: GenMessage<StructuredDatasetType> = /*@__PURE__*/
  messageDesc(file_idl2_core_types, 1);

/**
 * @generated from message flyteidl2.core.StructuredDatasetType.DatasetColumn
 */
export type StructuredDatasetType_DatasetColumn = Message<"flyteidl2.core.StructuredDatasetType.DatasetColumn"> & {
  /**
   * A unique name within the schema type for the column.
   *
   * @generated from field: string name = 1;
   */
  name: string;

  /**
   * The column type.
   *
   * @generated from field: flyteidl2.core.LiteralType literal_type = 2;
   */
  literalType?: LiteralType;
};

/**
 * Describes the message flyteidl2.core.StructuredDatasetType.DatasetColumn.
 * Use `create(StructuredDatasetType_DatasetColumnSchema)` to create a new message.
 */
export const StructuredDatasetType_DatasetColumnSchema: GenMessage<StructuredDatasetType_DatasetColumn> = /*@__PURE__*/
  messageDesc(file_idl2_core_types, 1, 0);

/**
 * Defines type behavior for blob objects
 *
 * @generated from message flyteidl2.core.BlobType
 */
export type BlobType = Message<"flyteidl2.core.BlobType"> & {
  /**
   * Format can be a free form string understood by SDK/UI etc like
   * csv, parquet etc
   *
   * @generated from field: string format = 1;
   */
  format: string;

  /**
   * @generated from field: flyteidl2.core.BlobType.BlobDimensionality dimensionality = 2;
   */
  dimensionality: BlobType_BlobDimensionality;
};

/**
 * Describes the message flyteidl2.core.BlobType.
 * Use `create(BlobTypeSchema)` to create a new message.
 */
export const BlobTypeSchema: GenMessage<BlobType> = /*@__PURE__*/
  messageDesc(file_idl2_core_types, 2);

/**
 * @generated from enum flyteidl2.core.BlobType.BlobDimensionality
 */
export enum BlobType_BlobDimensionality {
  /**
   * @generated from enum value: SINGLE = 0;
   */
  SINGLE = 0,

  /**
   * @generated from enum value: MULTIPART = 1;
   */
  MULTIPART = 1,
}

/**
 * Describes the enum flyteidl2.core.BlobType.BlobDimensionality.
 */
export const BlobType_BlobDimensionalitySchema: GenEnum<BlobType_BlobDimensionality> = /*@__PURE__*/
  enumDesc(file_idl2_core_types, 2, 0);

/**
 * Enables declaring enum types, with predefined string values
 * For len(values) > 0, the first value in the ordered list is regarded as the default value. If you wish
 * To provide no defaults, make the first value as undefined.
 *
 * @generated from message flyteidl2.core.EnumType
 */
export type EnumType = Message<"flyteidl2.core.EnumType"> & {
  /**
   * Predefined set of enum values.
   *
   * @generated from field: repeated string values = 1;
   */
  values: string[];
};

/**
 * Describes the message flyteidl2.core.EnumType.
 * Use `create(EnumTypeSchema)` to create a new message.
 */
export const EnumTypeSchema: GenMessage<EnumType> = /*@__PURE__*/
  messageDesc(file_idl2_core_types, 3);

/**
 * Defines a tagged union type, also known as a variant (and formally as the sum type).
 *
 * A sum type S is defined by a sequence of types (A, B, C, ...), each tagged by a string tag
 * A value of type S is constructed from a value of any of the variant types. The specific choice of type is recorded by
 * storing the varaint's tag with the literal value and can be examined in runtime.
 *
 * Type S is typically written as
 * S := Apple A | Banana B | Cantaloupe C | ...
 *
 * Notably, a nullable (optional) type is a sum type between some type X and the singleton type representing a null-value:
 * Optional X := X | Null
 *
 * See also: https://en.wikipedia.org/wiki/Tagged_union
 *
 * @generated from message flyteidl2.core.UnionType
 */
export type UnionType = Message<"flyteidl2.core.UnionType"> & {
  /**
   * Predefined set of variants in union.
   *
   * @generated from field: repeated flyteidl2.core.LiteralType variants = 1;
   */
  variants: LiteralType[];
};

/**
 * Describes the message flyteidl2.core.UnionType.
 * Use `create(UnionTypeSchema)` to create a new message.
 */
export const UnionTypeSchema: GenMessage<UnionType> = /*@__PURE__*/
  messageDesc(file_idl2_core_types, 4);

/**
 * Hints to improve type matching
 * e.g. allows distinguishing output from custom type transformers
 * even if the underlying IDL serialization matches.
 *
 * @generated from message flyteidl2.core.TypeStructure
 */
export type TypeStructure = Message<"flyteidl2.core.TypeStructure"> & {
  /**
   * Must exactly match for types to be castable
   *
   * @generated from field: string tag = 1;
   */
  tag: string;

  /**
   * dataclass_type only exists for dataclasses.
   * This is used to resolve the type of the fields of dataclass
   * The key is the field name, and the value is the literal type of the field
   * e.g. For dataclass Foo, with fields a, and a is a string
   * Foo.a will be resolved as a literal type of string from dataclass_type
   *
   * @generated from field: map<string, flyteidl2.core.LiteralType> dataclass_type = 2;
   */
  dataclassType: { [key: string]: LiteralType };
};

/**
 * Describes the message flyteidl2.core.TypeStructure.
 * Use `create(TypeStructureSchema)` to create a new message.
 */
export const TypeStructureSchema: GenMessage<TypeStructure> = /*@__PURE__*/
  messageDesc(file_idl2_core_types, 5);

/**
 * TypeAnnotation encapsulates registration time information about a type. This can be used for various control-plane operations. TypeAnnotation will not be available at runtime when a task runs.
 *
 * @generated from message flyteidl2.core.TypeAnnotation
 */
export type TypeAnnotation = Message<"flyteidl2.core.TypeAnnotation"> & {
  /**
   * A arbitrary JSON payload to describe a type.
   *
   * @generated from field: google.protobuf.Struct annotations = 1;
   */
  annotations?: JsonObject;
};

/**
 * Describes the message flyteidl2.core.TypeAnnotation.
 * Use `create(TypeAnnotationSchema)` to create a new message.
 */
export const TypeAnnotationSchema: GenMessage<TypeAnnotation> = /*@__PURE__*/
  messageDesc(file_idl2_core_types, 6);

/**
 * Defines a strong type to allow type checking between interfaces.
 *
 * @generated from message flyteidl2.core.LiteralType
 */
export type LiteralType = Message<"flyteidl2.core.LiteralType"> & {
  /**
   * @generated from oneof flyteidl2.core.LiteralType.type
   */
  type: {
    /**
     * A simple type that can be compared one-to-one with another.
     *
     * @generated from field: flyteidl2.core.SimpleType simple = 1;
     */
    value: SimpleType;
    case: "simple";
  } | {
    /**
     * A complex type that requires matching of inner fields.
     *
     * @generated from field: flyteidl2.core.SchemaType schema = 2;
     */
    value: SchemaType;
    case: "schema";
  } | {
    /**
     * Defines the type of the value of a collection. Only homogeneous collections are allowed.
     *
     * @generated from field: flyteidl2.core.LiteralType collection_type = 3;
     */
    value: LiteralType;
    case: "collectionType";
  } | {
    /**
     * Defines the type of the value of a map type. The type of the key is always a string.
     *
     * @generated from field: flyteidl2.core.LiteralType map_value_type = 4;
     */
    value: LiteralType;
    case: "mapValueType";
  } | {
    /**
     * A blob might have specialized implementation details depending on associated metadata.
     *
     * @generated from field: flyteidl2.core.BlobType blob = 5;
     */
    value: BlobType;
    case: "blob";
  } | {
    /**
     * Defines an enum with pre-defined string values.
     *
     * @generated from field: flyteidl2.core.EnumType enum_type = 7;
     */
    value: EnumType;
    case: "enumType";
  } | {
    /**
     * Generalized schema support
     *
     * @generated from field: flyteidl2.core.StructuredDatasetType structured_dataset_type = 8;
     */
    value: StructuredDatasetType;
    case: "structuredDatasetType";
  } | {
    /**
     * Defines an union type with pre-defined LiteralTypes.
     *
     * @generated from field: flyteidl2.core.UnionType union_type = 10;
     */
    value: UnionType;
    case: "unionType";
  } | { case: undefined; value?: undefined };

  /**
   * This field contains type metadata that is descriptive of the type, but is NOT considered in type-checking.  This might be used by
   * consumers to identify special behavior or display extended information for the type.
   *
   * @generated from field: google.protobuf.Struct metadata = 6;
   */
  metadata?: JsonObject;

  /**
   * This field contains arbitrary data that might have special semantic
   * meaning for the client but does not effect internal flyte behavior.
   *
   * @generated from field: flyteidl2.core.TypeAnnotation annotation = 9;
   */
  annotation?: TypeAnnotation;

  /**
   * Hints to improve type matching.
   *
   * @generated from field: flyteidl2.core.TypeStructure structure = 11;
   */
  structure?: TypeStructure;
};

/**
 * Describes the message flyteidl2.core.LiteralType.
 * Use `create(LiteralTypeSchema)` to create a new message.
 */
export const LiteralTypeSchema: GenMessage<LiteralType> = /*@__PURE__*/
  messageDesc(file_idl2_core_types, 7);

/**
 * A reference to an output produced by a node. The type can be retrieved -and validated- from
 * the underlying interface of the node.
 *
 * @generated from message flyteidl2.core.OutputReference
 */
export type OutputReference = Message<"flyteidl2.core.OutputReference"> & {
  /**
   * Node id must exist at the graph layer.
   *
   * @generated from field: string node_id = 1;
   */
  nodeId: string;

  /**
   * Variable name must refer to an output variable for the node.
   *
   * @generated from field: string var = 2;
   */
  var: string;

  /**
   * @generated from field: repeated flyteidl2.core.PromiseAttribute attr_path = 3;
   */
  attrPath: PromiseAttribute[];
};

/**
 * Describes the message flyteidl2.core.OutputReference.
 * Use `create(OutputReferenceSchema)` to create a new message.
 */
export const OutputReferenceSchema: GenMessage<OutputReference> = /*@__PURE__*/
  messageDesc(file_idl2_core_types, 8);

/**
 * @generated from message flyteidl2.core.PromiseAttribute
 */
export type PromiseAttribute = Message<"flyteidl2.core.PromiseAttribute"> & {
  /**
   * @generated from oneof flyteidl2.core.PromiseAttribute.value
   */
  value: {
    /**
     * @generated from field: string string_value = 1;
     */
    value: string;
    case: "stringValue";
  } | {
    /**
     * @generated from field: int32 int_value = 2;
     */
    value: number;
    case: "intValue";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message flyteidl2.core.PromiseAttribute.
 * Use `create(PromiseAttributeSchema)` to create a new message.
 */
export const PromiseAttributeSchema: GenMessage<PromiseAttribute> = /*@__PURE__*/
  messageDesc(file_idl2_core_types, 9);

/**
 * Represents an error thrown from a node.
 *
 * @generated from message flyteidl2.core.Error
 */
export type Error = Message<"flyteidl2.core.Error"> & {
  /**
   * The node id that threw the error.
   *
   * @generated from field: string failed_node_id = 1;
   */
  failedNodeId: string;

  /**
   * Error message thrown.
   *
   * @generated from field: string message = 2;
   */
  message: string;
};

/**
 * Describes the message flyteidl2.core.Error.
 * Use `create(ErrorSchema)` to create a new message.
 */
export const ErrorSchema: GenMessage<Error> = /*@__PURE__*/
  messageDesc(file_idl2_core_types, 10);

/**
 * Define a set of simple types.
 *
 * @generated from enum flyteidl2.core.SimpleType
 */
export enum SimpleType {
  /**
   * @generated from enum value: NONE = 0;
   */
  NONE = 0,

  /**
   * @generated from enum value: INTEGER = 1;
   */
  INTEGER = 1,

  /**
   * @generated from enum value: FLOAT = 2;
   */
  FLOAT = 2,

  /**
   * @generated from enum value: STRING = 3;
   */
  STRING = 3,

  /**
   * @generated from enum value: BOOLEAN = 4;
   */
  BOOLEAN = 4,

  /**
   * @generated from enum value: DATETIME = 5;
   */
  DATETIME = 5,

  /**
   * @generated from enum value: DURATION = 6;
   */
  DURATION = 6,

  /**
   * @generated from enum value: BINARY = 7;
   */
  BINARY = 7,

  /**
   * @generated from enum value: ERROR = 8;
   */
  ERROR = 8,

  /**
   * @generated from enum value: STRUCT = 9;
   */
  STRUCT = 9,
}

/**
 * Describes the enum flyteidl2.core.SimpleType.
 */
export const SimpleTypeSchema: GenEnum<SimpleType> = /*@__PURE__*/
  enumDesc(file_idl2_core_types, 0);

