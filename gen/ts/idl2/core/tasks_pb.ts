// @generated by protoc-gen-es v2.2.5 with parameter "target=ts,import_extension=.ts"
// @generated from file idl2/core/tasks.proto (package flyteidl2.core, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import type { Identifier } from "./identifier_pb.ts";
import { file_idl2_core_identifier } from "./identifier_pb.ts";
import type { TypedInterface } from "./interface_pb.ts";
import { file_idl2_core_interface } from "./interface_pb.ts";
import type { KeyValuePair, RetryStrategy } from "./literals_pb.ts";
import { file_idl2_core_literals } from "./literals_pb.ts";
import type { SecurityContext } from "./security_pb.ts";
import { file_idl2_core_security } from "./security_pb.ts";
import type { Duration } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_duration, file_google_protobuf_struct, file_google_protobuf_wrappers } from "@bufbuild/protobuf/wkt";
import type { JsonObject, Message } from "@bufbuild/protobuf";

/**
 * Describes the file idl2/core/tasks.proto.
 */
export const file_idl2_core_tasks: GenFile = /*@__PURE__*/
  fileDesc("ChVpZGwyL2NvcmUvdGFza3MucHJvdG8SDmZseXRlaWRsMi5jb3JlIrQCCglSZXNvdXJjZXMSOQoIcmVxdWVzdHMYASADKAsyJy5mbHl0ZWlkbDIuY29yZS5SZXNvdXJjZXMuUmVzb3VyY2VFbnRyeRI3CgZsaW1pdHMYAiADKAsyJy5mbHl0ZWlkbDIuY29yZS5SZXNvdXJjZXMuUmVzb3VyY2VFbnRyeRpUCg1SZXNvdXJjZUVudHJ5EjQKBG5hbWUYASABKA4yJi5mbHl0ZWlkbDIuY29yZS5SZXNvdXJjZXMuUmVzb3VyY2VOYW1lEg0KBXZhbHVlGAIgASgJIl0KDFJlc291cmNlTmFtZRILCgdVTktOT1dOEAASBwoDQ1BVEAESBwoDR1BVEAISCgoGTUVNT1JZEAMSCwoHU1RPUkFHRRAEEhUKEUVQSEVNRVJBTF9TVE9SQUdFEAUiawoOR1BVQWNjZWxlcmF0b3ISDgoGZGV2aWNlGAEgASgJEhcKDXVucGFydGl0aW9uZWQYAiABKAhIABIYCg5wYXJ0aXRpb25fc2l6ZRgDIAEoCUgAQhYKFHBhcnRpdGlvbl9zaXplX3ZhbHVlIkoKDFNoYXJlZE1lbW9yeRISCgptb3VudF9wYXRoGAEgASgJEhIKCm1vdW50X25hbWUYAiABKAkSEgoKc2l6ZV9saW1pdBgDIAEoCSKBAQoRRXh0ZW5kZWRSZXNvdXJjZXMSNwoPZ3B1X2FjY2VsZXJhdG9yGAEgASgLMh4uZmx5dGVpZGwyLmNvcmUuR1BVQWNjZWxlcmF0b3ISMwoNc2hhcmVkX21lbW9yeRgCIAEoCzIcLmZseXRlaWRsMi5jb3JlLlNoYXJlZE1lbW9yeSKWAQoPUnVudGltZU1ldGFkYXRhEjkKBHR5cGUYASABKA4yKy5mbHl0ZWlkbDIuY29yZS5SdW50aW1lTWV0YWRhdGEuUnVudGltZVR5cGUSDwoHdmVyc2lvbhgCIAEoCRIOCgZmbGF2b3IYAyABKAkiJwoLUnVudGltZVR5cGUSCQoFT1RIRVIQABINCglGTFlURV9TREsQASLbBAoMVGFza01ldGFkYXRhEhQKDGRpc2NvdmVyYWJsZRgBIAEoCBIwCgdydW50aW1lGAIgASgLMh8uZmx5dGVpZGwyLmNvcmUuUnVudGltZU1ldGFkYXRhEioKB3RpbWVvdXQYBCABKAsyGS5nb29nbGUucHJvdG9idWYuRHVyYXRpb24SLgoHcmV0cmllcxgFIAEoCzIdLmZseXRlaWRsMi5jb3JlLlJldHJ5U3RyYXRlZ3kSGQoRZGlzY292ZXJ5X3ZlcnNpb24YBiABKAkSIAoYZGVwcmVjYXRlZF9lcnJvcl9tZXNzYWdlGAcgASgJEhcKDWludGVycnVwdGlibGUYCCABKAhIABIaChJjYWNoZV9zZXJpYWxpemFibGUYCSABKAgSNAoEdGFncxgLIAMoCzImLmZseXRlaWRsMi5jb3JlLlRhc2tNZXRhZGF0YS5UYWdzRW50cnkSGQoRcG9kX3RlbXBsYXRlX25hbWUYDCABKAkSHwoXY2FjaGVfaWdub3JlX2lucHV0X3ZhcnMYDSADKAkSEAoIaXNfZWFnZXIYDiABKAgSMgoOZ2VuZXJhdGVzX2RlY2sYDyABKAsyGi5nb29nbGUucHJvdG9idWYuQm9vbFZhbHVlEjMKCG1ldGFkYXRhGBAgASgLMiEuZmx5dGVpZGwyLmNvcmUuSzhzT2JqZWN0TWV0YWRhdGEaKwoJVGFnc0VudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAFCFQoTaW50ZXJydXB0aWJsZV92YWx1ZUoECAoQCyLXBAoMVGFza1RlbXBsYXRlEiYKAmlkGAEgASgLMhouZmx5dGVpZGwyLmNvcmUuSWRlbnRpZmllchIMCgR0eXBlGAIgASgJEi4KCG1ldGFkYXRhGAMgASgLMhwuZmx5dGVpZGwyLmNvcmUuVGFza01ldGFkYXRhEjEKCWludGVyZmFjZRgEIAEoCzIeLmZseXRlaWRsMi5jb3JlLlR5cGVkSW50ZXJmYWNlEicKBmN1c3RvbRgFIAEoCzIXLmdvb2dsZS5wcm90b2J1Zi5TdHJ1Y3QSLgoJY29udGFpbmVyGAYgASgLMhkuZmx5dGVpZGwyLmNvcmUuQ29udGFpbmVySAASKQoHazhzX3BvZBgRIAEoCzIWLmZseXRlaWRsMi5jb3JlLks4c1BvZEgAEiIKA3NxbBgSIAEoCzITLmZseXRlaWRsMi5jb3JlLlNxbEgAEhkKEXRhc2tfdHlwZV92ZXJzaW9uGAcgASgFEjkKEHNlY3VyaXR5X2NvbnRleHQYCCABKAsyHy5mbHl0ZWlkbDIuY29yZS5TZWN1cml0eUNvbnRleHQSPQoSZXh0ZW5kZWRfcmVzb3VyY2VzGAkgASgLMiEuZmx5dGVpZGwyLmNvcmUuRXh0ZW5kZWRSZXNvdXJjZXMSOAoGY29uZmlnGBAgAygLMiguZmx5dGVpZGwyLmNvcmUuVGFza1RlbXBsYXRlLkNvbmZpZ0VudHJ5Gi0KC0NvbmZpZ0VudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAFCCAoGdGFyZ2V0IjUKDUNvbnRhaW5lclBvcnQSFgoOY29udGFpbmVyX3BvcnQYASABKA0SDAoEbmFtZRgCIAEoCSKzAwoJQ29udGFpbmVyEg0KBWltYWdlGAEgASgJEg8KB2NvbW1hbmQYAiADKAkSDAoEYXJncxgDIAMoCRIsCglyZXNvdXJjZXMYBCABKAsyGS5mbHl0ZWlkbDIuY29yZS5SZXNvdXJjZXMSKQoDZW52GAUgAygLMhwuZmx5dGVpZGwyLmNvcmUuS2V5VmFsdWVQYWlyEjAKBmNvbmZpZxgGIAMoCzIcLmZseXRlaWRsMi5jb3JlLktleVZhbHVlUGFpckICGAESLAoFcG9ydHMYByADKAsyHS5mbHl0ZWlkbDIuY29yZS5Db250YWluZXJQb3J0EjYKC2RhdGFfY29uZmlnGAkgASgLMiEuZmx5dGVpZGwyLmNvcmUuRGF0YUxvYWRpbmdDb25maWcSPAoMYXJjaGl0ZWN0dXJlGAogASgOMiYuZmx5dGVpZGwyLmNvcmUuQ29udGFpbmVyLkFyY2hpdGVjdHVyZSJJCgxBcmNoaXRlY3R1cmUSCwoHVU5LTk9XThAAEgkKBUFNRDY0EAESCQoFQVJNNjQQAhIKCgZBUk1fVjYQAxIKCgZBUk1fVjcQBCKdAgoKSU9TdHJhdGVneRI+Cg1kb3dubG9hZF9tb2RlGAEgASgOMicuZmx5dGVpZGwyLmNvcmUuSU9TdHJhdGVneS5Eb3dubG9hZE1vZGUSOgoLdXBsb2FkX21vZGUYAiABKA4yJS5mbHl0ZWlkbDIuY29yZS5JT1N0cmF0ZWd5LlVwbG9hZE1vZGUiTAoMRG93bmxvYWRNb2RlEhIKDkRPV05MT0FEX0VBR0VSEAASEwoPRE9XTkxPQURfU1RSRUFNEAESEwoPRE9fTk9UX0RPV05MT0FEEAIiRQoKVXBsb2FkTW9kZRISCg5VUExPQURfT05fRVhJVBAAEhAKDFVQTE9BRF9FQUdFUhABEhEKDURPX05PVF9VUExPQUQQAiL1AQoRRGF0YUxvYWRpbmdDb25maWcSDwoHZW5hYmxlZBgBIAEoCBISCgppbnB1dF9wYXRoGAIgASgJEhMKC291dHB1dF9wYXRoGAMgASgJEkIKBmZvcm1hdBgEIAEoDjIyLmZseXRlaWRsMi5jb3JlLkRhdGFMb2FkaW5nQ29uZmlnLkxpdGVyYWxNYXBGb3JtYXQSLwoLaW9fc3RyYXRlZ3kYBSABKAsyGi5mbHl0ZWlkbDIuY29yZS5JT1N0cmF0ZWd5IjEKEExpdGVyYWxNYXBGb3JtYXQSCAoESlNPThAAEggKBFlBTUwQARIJCgVQUk9UTxACIsABCgZLOHNQb2QSMwoIbWV0YWRhdGEYASABKAsyIS5mbHl0ZWlkbDIuY29yZS5LOHNPYmplY3RNZXRhZGF0YRIpCghwb2Rfc3BlYxgCIAEoCzIXLmdvb2dsZS5wcm90b2J1Zi5TdHJ1Y3QSNgoLZGF0YV9jb25maWcYAyABKAsyIS5mbHl0ZWlkbDIuY29yZS5EYXRhTG9hZGluZ0NvbmZpZxIeChZwcmltYXJ5X2NvbnRhaW5lcl9uYW1lGAQgASgJIv4BChFLOHNPYmplY3RNZXRhZGF0YRI9CgZsYWJlbHMYASADKAsyLS5mbHl0ZWlkbDIuY29yZS5LOHNPYmplY3RNZXRhZGF0YS5MYWJlbHNFbnRyeRJHCgthbm5vdGF0aW9ucxgCIAMoCzIyLmZseXRlaWRsMi5jb3JlLks4c09iamVjdE1ldGFkYXRhLkFubm90YXRpb25zRW50cnkaLQoLTGFiZWxzRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgJOgI4ARoyChBBbm5vdGF0aW9uc0VudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAEifwoDU3FsEhEKCXN0YXRlbWVudBgBIAEoCRIsCgdkaWFsZWN0GAIgASgOMhsuZmx5dGVpZGwyLmNvcmUuU3FsLkRpYWxlY3QiNwoHRGlhbGVjdBINCglVTkRFRklORUQQABIICgRBTlNJEAESCAoESElWRRACEgkKBU9USEVSEANCqgEKEmNvbS5mbHl0ZWlkbDIuY29yZUIKVGFza3NQcm90b0gCUAFaLWdpdGh1Yi5jb20vZmx5dGVvcmcvZmx5dGUvdjIvZ2VuL2dvL2lkbDIvY29yZaICA0ZDWKoCDkZseXRlaWRsMi5Db3JlygIORmx5dGVpZGwyXENvcmXiAhpGbHl0ZWlkbDJcQ29yZVxHUEJNZXRhZGF0YeoCD0ZseXRlaWRsMjo6Q29yZWIGcHJvdG8z", [file_idl2_core_identifier, file_idl2_core_interface, file_idl2_core_literals, file_idl2_core_security, file_google_protobuf_duration, file_google_protobuf_struct, file_google_protobuf_wrappers]);

/**
 * A customizable interface to convey resources requested for a container. This can be interpreted differently for different
 * container engines.
 *
 * @generated from message flyteidl2.core.Resources
 */
export type Resources = Message<"flyteidl2.core.Resources"> & {
  /**
   * The desired set of resources requested. ResourceNames must be unique within the list.
   *
   * @generated from field: repeated flyteidl2.core.Resources.ResourceEntry requests = 1;
   */
  requests: Resources_ResourceEntry[];

  /**
   * Defines a set of bounds (e.g. min/max) within which the task can reliably run. ResourceNames must be unique
   * within the list.
   *
   * @generated from field: repeated flyteidl2.core.Resources.ResourceEntry limits = 2;
   */
  limits: Resources_ResourceEntry[];
};

/**
 * Describes the message flyteidl2.core.Resources.
 * Use `create(ResourcesSchema)` to create a new message.
 */
export const ResourcesSchema: GenMessage<Resources> = /*@__PURE__*/
  messageDesc(file_idl2_core_tasks, 0);

/**
 * Encapsulates a resource name and value.
 *
 * @generated from message flyteidl2.core.Resources.ResourceEntry
 */
export type Resources_ResourceEntry = Message<"flyteidl2.core.Resources.ResourceEntry"> & {
  /**
   * Resource name.
   *
   * @generated from field: flyteidl2.core.Resources.ResourceName name = 1;
   */
  name: Resources_ResourceName;

  /**
   * Value must be a valid k8s quantity. See
   * https://github.com/kubernetes/apimachinery/blob/master/pkg/api/resource/quantity.go#L30-L80
   *
   * @generated from field: string value = 2;
   */
  value: string;
};

/**
 * Describes the message flyteidl2.core.Resources.ResourceEntry.
 * Use `create(Resources_ResourceEntrySchema)` to create a new message.
 */
export const Resources_ResourceEntrySchema: GenMessage<Resources_ResourceEntry> = /*@__PURE__*/
  messageDesc(file_idl2_core_tasks, 0, 0);

/**
 * Known resource names.
 *
 * @generated from enum flyteidl2.core.Resources.ResourceName
 */
export enum Resources_ResourceName {
  /**
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * @generated from enum value: CPU = 1;
   */
  CPU = 1,

  /**
   * @generated from enum value: GPU = 2;
   */
  GPU = 2,

  /**
   * @generated from enum value: MEMORY = 3;
   */
  MEMORY = 3,

  /**
   * @generated from enum value: STORAGE = 4;
   */
  STORAGE = 4,

  /**
   * For Kubernetes-based deployments, pods use ephemeral local storage for scratch space, caching, and for logs.
   *
   * @generated from enum value: EPHEMERAL_STORAGE = 5;
   */
  EPHEMERAL_STORAGE = 5,
}

/**
 * Describes the enum flyteidl2.core.Resources.ResourceName.
 */
export const Resources_ResourceNameSchema: GenEnum<Resources_ResourceName> = /*@__PURE__*/
  enumDesc(file_idl2_core_tasks, 0, 0);

/**
 * Metadata associated with the GPU accelerator to allocate to a task. Contains
 * information about device type, and for multi-instance GPUs, the partition size to
 * use.
 *
 * @generated from message flyteidl2.core.GPUAccelerator
 */
export type GPUAccelerator = Message<"flyteidl2.core.GPUAccelerator"> & {
  /**
   * This can be any arbitrary string, and should be informed by the labels or taints
   * associated with the nodes in question. Default cloud provider labels typically
   * use the following values: `nvidia-tesla-t4`, `nvidia-tesla-a100`, etc.
   *
   * @generated from field: string device = 1;
   */
  device: string;

  /**
   * @generated from oneof flyteidl2.core.GPUAccelerator.partition_size_value
   */
  partitionSizeValue: {
    /**
     * @generated from field: bool unpartitioned = 2;
     */
    value: boolean;
    case: "unpartitioned";
  } | {
    /**
     * Like `device`, this can be any arbitrary string, and should be informed by
     * the labels or taints associated with the nodes in question. Default cloud
     * provider labels typically use the following values: `1g.5gb`, `2g.10gb`, etc.
     *
     * @generated from field: string partition_size = 3;
     */
    value: string;
    case: "partitionSize";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message flyteidl2.core.GPUAccelerator.
 * Use `create(GPUAcceleratorSchema)` to create a new message.
 */
export const GPUAcceleratorSchema: GenMessage<GPUAccelerator> = /*@__PURE__*/
  messageDesc(file_idl2_core_tasks, 1);

/**
 * Metadata associated with configuring a shared memory volume for a task.
 *
 * @generated from message flyteidl2.core.SharedMemory
 */
export type SharedMemory = Message<"flyteidl2.core.SharedMemory"> & {
  /**
   * Mount path to place in container
   *
   * @generated from field: string mount_path = 1;
   */
  mountPath: string;

  /**
   * Name for volume
   *
   * @generated from field: string mount_name = 2;
   */
  mountName: string;

  /**
   * Size limit for shared memory. If not set, then the shared memory is equal
   * to the allocated memory.
   * +optional
   *
   * @generated from field: string size_limit = 3;
   */
  sizeLimit: string;
};

/**
 * Describes the message flyteidl2.core.SharedMemory.
 * Use `create(SharedMemorySchema)` to create a new message.
 */
export const SharedMemorySchema: GenMessage<SharedMemory> = /*@__PURE__*/
  messageDesc(file_idl2_core_tasks, 2);

/**
 * Encapsulates all non-standard resources, not captured by v1.ResourceRequirements, to
 * allocate to a task.
 *
 * @generated from message flyteidl2.core.ExtendedResources
 */
export type ExtendedResources = Message<"flyteidl2.core.ExtendedResources"> & {
  /**
   * GPU accelerator to select for task. Contains information about device type, and
   * for multi-instance GPUs, the partition size to use.
   *
   * @generated from field: flyteidl2.core.GPUAccelerator gpu_accelerator = 1;
   */
  gpuAccelerator?: GPUAccelerator;

  /**
   * @generated from field: flyteidl2.core.SharedMemory shared_memory = 2;
   */
  sharedMemory?: SharedMemory;
};

/**
 * Describes the message flyteidl2.core.ExtendedResources.
 * Use `create(ExtendedResourcesSchema)` to create a new message.
 */
export const ExtendedResourcesSchema: GenMessage<ExtendedResources> = /*@__PURE__*/
  messageDesc(file_idl2_core_tasks, 3);

/**
 * Runtime information. This is loosely defined to allow for extensibility.
 *
 * @generated from message flyteidl2.core.RuntimeMetadata
 */
export type RuntimeMetadata = Message<"flyteidl2.core.RuntimeMetadata"> & {
  /**
   * Type of runtime.
   *
   * @generated from field: flyteidl2.core.RuntimeMetadata.RuntimeType type = 1;
   */
  type: RuntimeMetadata_RuntimeType;

  /**
   * Version of the runtime. All versions should be backward compatible. However, certain cases call for version
   * checks to ensure tighter validation or setting expectations.
   *
   * @generated from field: string version = 2;
   */
  version: string;

  /**
   * +optional It can be used to provide extra information about the runtime (e.g. python, golang... etc.).
   *
   * @generated from field: string flavor = 3;
   */
  flavor: string;
};

/**
 * Describes the message flyteidl2.core.RuntimeMetadata.
 * Use `create(RuntimeMetadataSchema)` to create a new message.
 */
export const RuntimeMetadataSchema: GenMessage<RuntimeMetadata> = /*@__PURE__*/
  messageDesc(file_idl2_core_tasks, 4);

/**
 * @generated from enum flyteidl2.core.RuntimeMetadata.RuntimeType
 */
export enum RuntimeMetadata_RuntimeType {
  /**
   * @generated from enum value: OTHER = 0;
   */
  OTHER = 0,

  /**
   * @generated from enum value: FLYTE_SDK = 1;
   */
  FLYTE_SDK = 1,
}

/**
 * Describes the enum flyteidl2.core.RuntimeMetadata.RuntimeType.
 */
export const RuntimeMetadata_RuntimeTypeSchema: GenEnum<RuntimeMetadata_RuntimeType> = /*@__PURE__*/
  enumDesc(file_idl2_core_tasks, 4, 0);

/**
 * Task Metadata
 *
 * @generated from message flyteidl2.core.TaskMetadata
 */
export type TaskMetadata = Message<"flyteidl2.core.TaskMetadata"> & {
  /**
   * Indicates whether the system should attempt to lookup this task's output to avoid duplication of work.
   *
   * @generated from field: bool discoverable = 1;
   */
  discoverable: boolean;

  /**
   * Runtime information about the task.
   *
   * @generated from field: flyteidl2.core.RuntimeMetadata runtime = 2;
   */
  runtime?: RuntimeMetadata;

  /**
   * The overall timeout of a task including user-triggered retries.
   *
   * @generated from field: google.protobuf.Duration timeout = 4;
   */
  timeout?: Duration;

  /**
   * Number of retries per task.
   *
   * @generated from field: flyteidl2.core.RetryStrategy retries = 5;
   */
  retries?: RetryStrategy;

  /**
   * Indicates a logical version to apply to this task for the purpose of discovery.
   *
   * @generated from field: string discovery_version = 6;
   */
  discoveryVersion: string;

  /**
   * If set, this indicates that this task is deprecated.  This will enable owners of tasks to notify consumers
   * of the ending of support for a given task.
   *
   * @generated from field: string deprecated_error_message = 7;
   */
  deprecatedErrorMessage: string;

  /**
   * Identify whether task is interruptible
   *
   * @generated from oneof flyteidl2.core.TaskMetadata.interruptible_value
   */
  interruptibleValue: {
    /**
     * @generated from field: bool interruptible = 8;
     */
    value: boolean;
    case: "interruptible";
  } | { case: undefined; value?: undefined };

  /**
   * Indicates whether the system should attempt to execute discoverable instances in serial to avoid duplicate work
   *
   * @generated from field: bool cache_serializable = 9;
   */
  cacheSerializable: boolean;

  /**
   * Arbitrary tags that allow users and the platform to store small but arbitrary labels
   *
   * @generated from field: map<string, string> tags = 11;
   */
  tags: { [key: string]: string };

  /**
   * pod_template_name is the unique name of a PodTemplate k8s resource to be used as the base configuration if this
   * task creates a k8s Pod. If this value is set, the specified PodTemplate will be used instead of, but applied
   * identically as, the default PodTemplate configured in FlytePropeller.
   *
   * @generated from field: string pod_template_name = 12;
   */
  podTemplateName: string;

  /**
   * cache_ignore_input_vars is the input variables that should not be included when calculating hash for cache.
   *
   * @generated from field: repeated string cache_ignore_input_vars = 13;
   */
  cacheIgnoreInputVars: string[];

  /**
   * is_eager indicates whether the task is eager or not.
   * This would be used by CreateTask endpoint.
   *
   * @generated from field: bool is_eager = 14;
   */
  isEager: boolean;

  /**
   * Indicates whether the task will generate a deck when it finishes executing.
   * The BoolValue can have three states:
   * - nil: The value is not set.
   * - true: The task will generate a deck.
   * - false: The task will not generate a deck.
   *
   * @generated from field: google.protobuf.BoolValue generates_deck = 15;
   */
  generatesDeck?: boolean;

  /**
   * Metadata applied to task pods or task CR objects.
   * In flytekit, labels and annotations resulting in this metadata field
   * are provided via `@task(labels=..., annotations=...)`.
   * For tasks backed by pods like PythonFunctionTask, these take precedence
   * over the metadata provided via `@task(pod_template=PodTemplate(labels=...))` which are transported
   * in the K8sPod message. For tasks backed by CRDs, this metadata is applied to
   * the CR object itself while the metadata in the pod template/K8sPod is applied
   * to the pod template spec of the CR object.
   *
   * @generated from field: flyteidl2.core.K8sObjectMetadata metadata = 16;
   */
  metadata?: K8sObjectMetadata;
};

/**
 * Describes the message flyteidl2.core.TaskMetadata.
 * Use `create(TaskMetadataSchema)` to create a new message.
 */
export const TaskMetadataSchema: GenMessage<TaskMetadata> = /*@__PURE__*/
  messageDesc(file_idl2_core_tasks, 5);

/**
 * A Task structure that uniquely identifies a task in the system
 * Tasks are registered as a first step in the system.
 *
 * @generated from message flyteidl2.core.TaskTemplate
 */
export type TaskTemplate = Message<"flyteidl2.core.TaskTemplate"> & {
  /**
   * Auto generated taskId by the system. Task Id uniquely identifies this task globally.
   *
   * @generated from field: flyteidl2.core.Identifier id = 1;
   */
  id?: Identifier;

  /**
   * A predefined yet extensible Task type identifier. This can be used to customize any of the components. If no
   * extensions are provided in the system, Flyte will resolve the this task to its TaskCategory and default the
   * implementation registered for the TaskCategory.
   *
   * @generated from field: string type = 2;
   */
  type: string;

  /**
   * Extra metadata about the task.
   *
   * @generated from field: flyteidl2.core.TaskMetadata metadata = 3;
   */
  metadata?: TaskMetadata;

  /**
   * A strongly typed interface for the task. This enables others to use this task within a workflow and guarantees
   * compile-time validation of the workflow to avoid costly runtime failures.
   *
   * @generated from field: flyteidl2.core.TypedInterface interface = 4;
   */
  interface?: TypedInterface;

  /**
   * Custom data about the task. This is extensible to allow various plugins in the system.
   *
   * @generated from field: google.protobuf.Struct custom = 5;
   */
  custom?: JsonObject;

  /**
   * Known target types that the system will guarantee plugins for. Custom SDK plugins are allowed to set these if needed.
   * If no corresponding execution-layer plugins are found, the system will default to handling these using built-in
   * handlers.
   *
   * @generated from oneof flyteidl2.core.TaskTemplate.target
   */
  target: {
    /**
     * @generated from field: flyteidl2.core.Container container = 6;
     */
    value: Container;
    case: "container";
  } | {
    /**
     * @generated from field: flyteidl2.core.K8sPod k8s_pod = 17;
     */
    value: K8sPod;
    case: "k8sPod";
  } | {
    /**
     * @generated from field: flyteidl2.core.Sql sql = 18;
     */
    value: Sql;
    case: "sql";
  } | { case: undefined; value?: undefined };

  /**
   * This can be used to customize task handling at execution time for the same task type.
   *
   * @generated from field: int32 task_type_version = 7;
   */
  taskTypeVersion: number;

  /**
   * security_context encapsulates security attributes requested to run this task.
   *
   * @generated from field: flyteidl2.core.SecurityContext security_context = 8;
   */
  securityContext?: SecurityContext;

  /**
   * Encapsulates all non-standard resources, not captured by
   * v1.ResourceRequirements, to allocate to a task.
   *
   * @generated from field: flyteidl2.core.ExtendedResources extended_resources = 9;
   */
  extendedResources?: ExtendedResources;

  /**
   * Metadata about the custom defined for this task. This is extensible to allow various plugins in the system
   * to use as required.
   * reserve the field numbers 1 through 15 for very frequently occurring message elements
   *
   * @generated from field: map<string, string> config = 16;
   */
  config: { [key: string]: string };
};

/**
 * Describes the message flyteidl2.core.TaskTemplate.
 * Use `create(TaskTemplateSchema)` to create a new message.
 */
export const TaskTemplateSchema: GenMessage<TaskTemplate> = /*@__PURE__*/
  messageDesc(file_idl2_core_tasks, 6);

/**
 * Defines port properties for a container.
 *
 * @generated from message flyteidl2.core.ContainerPort
 */
export type ContainerPort = Message<"flyteidl2.core.ContainerPort"> & {
  /**
   * Number of port to expose on the pod's IP address.
   * This must be a valid port number, 0 < x < 65536.
   *
   * @generated from field: uint32 container_port = 1;
   */
  containerPort: number;

  /**
   * Name of the port to expose on the pod's IP address.
   *
   * @generated from field: string name = 2;
   */
  name: string;
};

/**
 * Describes the message flyteidl2.core.ContainerPort.
 * Use `create(ContainerPortSchema)` to create a new message.
 */
export const ContainerPortSchema: GenMessage<ContainerPort> = /*@__PURE__*/
  messageDesc(file_idl2_core_tasks, 7);

/**
 * @generated from message flyteidl2.core.Container
 */
export type Container = Message<"flyteidl2.core.Container"> & {
  /**
   * Container image url. Eg: docker/redis:latest
   *
   * @generated from field: string image = 1;
   */
  image: string;

  /**
   * Command to be executed, if not provided, the default entrypoint in the container image will be used.
   *
   * @generated from field: repeated string command = 2;
   */
  command: string[];

  /**
   * These will default to Flyte given paths. If provided, the system will not append known paths. If the task still
   * needs flyte's inputs and outputs path, add $(FLYTE_INPUT_FILE), $(FLYTE_OUTPUT_FILE) wherever makes sense and the
   * system will populate these before executing the container.
   *
   * @generated from field: repeated string args = 3;
   */
  args: string[];

  /**
   * Container resources requirement as specified by the container engine.
   *
   * @generated from field: flyteidl2.core.Resources resources = 4;
   */
  resources?: Resources;

  /**
   * Environment variables will be set as the container is starting up.
   *
   * @generated from field: repeated flyteidl2.core.KeyValuePair env = 5;
   */
  env: KeyValuePair[];

  /**
   * Allows extra configs to be available for the container.
   * TODO: elaborate on how configs will become available.
   * Deprecated, please use TaskTemplate.config instead.
   *
   * @generated from field: repeated flyteidl2.core.KeyValuePair config = 6 [deprecated = true];
   * @deprecated
   */
  config: KeyValuePair[];

  /**
   * Ports to open in the container. This feature is not supported by all execution engines. (e.g. supported on K8s but
   * not supported on AWS Batch)
   * Only K8s
   *
   * @generated from field: repeated flyteidl2.core.ContainerPort ports = 7;
   */
  ports: ContainerPort[];

  /**
   * BETA: Optional configuration for DataLoading. If not specified, then default values are used.
   * This makes it possible to to run a completely portable container, that uses inputs and outputs
   * only from the local file-system and without having any reference to flyteidl. This is supported only on K8s at the moment.
   * If data loading is enabled, then data will be mounted in accompanying directories specified in the DataLoadingConfig. If the directories
   * are not specified, inputs will be mounted onto and outputs will be uploaded from a pre-determined file-system path. Refer to the documentation
   * to understand the default paths.
   * Only K8s
   *
   * @generated from field: flyteidl2.core.DataLoadingConfig data_config = 9;
   */
  dataConfig?: DataLoadingConfig;

  /**
   * @generated from field: flyteidl2.core.Container.Architecture architecture = 10;
   */
  architecture: Container_Architecture;
};

/**
 * Describes the message flyteidl2.core.Container.
 * Use `create(ContainerSchema)` to create a new message.
 */
export const ContainerSchema: GenMessage<Container> = /*@__PURE__*/
  messageDesc(file_idl2_core_tasks, 8);

/**
 * Architecture-type the container image supports.
 *
 * @generated from enum flyteidl2.core.Container.Architecture
 */
export enum Container_Architecture {
  /**
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * @generated from enum value: AMD64 = 1;
   */
  AMD64 = 1,

  /**
   * @generated from enum value: ARM64 = 2;
   */
  ARM64 = 2,

  /**
   * @generated from enum value: ARM_V6 = 3;
   */
  ARM_V6 = 3,

  /**
   * @generated from enum value: ARM_V7 = 4;
   */
  ARM_V7 = 4,
}

/**
 * Describes the enum flyteidl2.core.Container.Architecture.
 */
export const Container_ArchitectureSchema: GenEnum<Container_Architecture> = /*@__PURE__*/
  enumDesc(file_idl2_core_tasks, 8, 0);

/**
 * Strategy to use when dealing with Blob, Schema, or multipart blob data (large datasets)
 *
 * @generated from message flyteidl2.core.IOStrategy
 */
export type IOStrategy = Message<"flyteidl2.core.IOStrategy"> & {
  /**
   * Mode to use to manage downloads
   *
   * @generated from field: flyteidl2.core.IOStrategy.DownloadMode download_mode = 1;
   */
  downloadMode: IOStrategy_DownloadMode;

  /**
   * Mode to use to manage uploads
   *
   * @generated from field: flyteidl2.core.IOStrategy.UploadMode upload_mode = 2;
   */
  uploadMode: IOStrategy_UploadMode;
};

/**
 * Describes the message flyteidl2.core.IOStrategy.
 * Use `create(IOStrategySchema)` to create a new message.
 */
export const IOStrategySchema: GenMessage<IOStrategy> = /*@__PURE__*/
  messageDesc(file_idl2_core_tasks, 9);

/**
 * Mode to use for downloading
 *
 * @generated from enum flyteidl2.core.IOStrategy.DownloadMode
 */
export enum IOStrategy_DownloadMode {
  /**
   * All data will be downloaded before the main container is executed
   *
   * @generated from enum value: DOWNLOAD_EAGER = 0;
   */
  DOWNLOAD_EAGER = 0,

  /**
   * Data will be downloaded as a stream and an End-Of-Stream marker will be written to indicate all data has been downloaded. Refer to protocol for details
   *
   * @generated from enum value: DOWNLOAD_STREAM = 1;
   */
  DOWNLOAD_STREAM = 1,

  /**
   * Large objects (offloaded) will not be downloaded
   *
   * @generated from enum value: DO_NOT_DOWNLOAD = 2;
   */
  DO_NOT_DOWNLOAD = 2,
}

/**
 * Describes the enum flyteidl2.core.IOStrategy.DownloadMode.
 */
export const IOStrategy_DownloadModeSchema: GenEnum<IOStrategy_DownloadMode> = /*@__PURE__*/
  enumDesc(file_idl2_core_tasks, 9, 0);

/**
 * Mode to use for uploading
 *
 * @generated from enum flyteidl2.core.IOStrategy.UploadMode
 */
export enum IOStrategy_UploadMode {
  /**
   * All data will be uploaded after the main container exits
   *
   * @generated from enum value: UPLOAD_ON_EXIT = 0;
   */
  UPLOAD_ON_EXIT = 0,

  /**
   * Data will be uploaded as it appears. Refer to protocol specification for details
   *
   * @generated from enum value: UPLOAD_EAGER = 1;
   */
  UPLOAD_EAGER = 1,

  /**
   * Data will not be uploaded, only references will be written
   *
   * @generated from enum value: DO_NOT_UPLOAD = 2;
   */
  DO_NOT_UPLOAD = 2,
}

/**
 * Describes the enum flyteidl2.core.IOStrategy.UploadMode.
 */
export const IOStrategy_UploadModeSchema: GenEnum<IOStrategy_UploadMode> = /*@__PURE__*/
  enumDesc(file_idl2_core_tasks, 9, 1);

/**
 * This configuration allows executing raw containers in Flyte using the Flyte CoPilot system.
 * Flyte CoPilot, eliminates the needs of flytekit or sdk inside the container. Any inputs required by the users container are side-loaded in the input_path
 * Any outputs generated by the user container - within output_path are automatically uploaded.
 *
 * @generated from message flyteidl2.core.DataLoadingConfig
 */
export type DataLoadingConfig = Message<"flyteidl2.core.DataLoadingConfig"> & {
  /**
   * Flag enables DataLoading Config. If this is not set, data loading will not be used!
   *
   * @generated from field: bool enabled = 1;
   */
  enabled: boolean;

  /**
   * File system path (start at root). This folder will contain all the inputs exploded to a separate file.
   * Example, if the input interface needs (x: int, y: blob, z: multipart_blob) and the input path is '/var/flyte/inputs', then the file system will look like
   * /var/flyte/inputs/inputs.<metadata format dependent -> .pb .json .yaml> -> Format as defined previously. The Blob and Multipart blob will reference local filesystem instead of remote locations
   * /var/flyte/inputs/x -> X is a file that contains the value of x (integer) in string format
   * /var/flyte/inputs/y -> Y is a file in Binary format
   * /var/flyte/inputs/z/... -> Note Z itself is a directory
   * More information about the protocol - refer to docs #TODO reference docs here
   *
   * @generated from field: string input_path = 2;
   */
  inputPath: string;

  /**
   * File system path (start at root). This folder should contain all the outputs for the task as individual files and/or an error text file
   *
   * @generated from field: string output_path = 3;
   */
  outputPath: string;

  /**
   * In the inputs folder, there will be an additional summary/metadata file that contains references to all files or inlined primitive values.
   * This format decides the actual encoding for the data. Refer to the encoding to understand the specifics of the contents and the encoding
   *
   * @generated from field: flyteidl2.core.DataLoadingConfig.LiteralMapFormat format = 4;
   */
  format: DataLoadingConfig_LiteralMapFormat;

  /**
   * @generated from field: flyteidl2.core.IOStrategy io_strategy = 5;
   */
  ioStrategy?: IOStrategy;
};

/**
 * Describes the message flyteidl2.core.DataLoadingConfig.
 * Use `create(DataLoadingConfigSchema)` to create a new message.
 */
export const DataLoadingConfigSchema: GenMessage<DataLoadingConfig> = /*@__PURE__*/
  messageDesc(file_idl2_core_tasks, 10);

/**
 * LiteralMapFormat decides the encoding format in which the input metadata should be made available to the containers.
 * If the user has access to the protocol buffer definitions, it is recommended to use the PROTO format.
 * JSON and YAML do not need any protobuf definitions to read it
 * All remote references in core.LiteralMap are replaced with local filesystem references (the data is downloaded to local filesystem)
 *
 * @generated from enum flyteidl2.core.DataLoadingConfig.LiteralMapFormat
 */
export enum DataLoadingConfig_LiteralMapFormat {
  /**
   * JSON / YAML for the metadata (which contains inlined primitive values). The representation is inline with the standard json specification as specified - https://www.json.org/json-en.html
   *
   * @generated from enum value: JSON = 0;
   */
  JSON = 0,

  /**
   * @generated from enum value: YAML = 1;
   */
  YAML = 1,

  /**
   * Proto is a serialized binary of `core.LiteralMap` defined in flyteidl/core
   *
   * @generated from enum value: PROTO = 2;
   */
  PROTO = 2,
}

/**
 * Describes the enum flyteidl2.core.DataLoadingConfig.LiteralMapFormat.
 */
export const DataLoadingConfig_LiteralMapFormatSchema: GenEnum<DataLoadingConfig_LiteralMapFormat> = /*@__PURE__*/
  enumDesc(file_idl2_core_tasks, 10, 0);

/**
 * Defines a pod spec and additional pod metadata that is created when a task is executed.
 *
 * @generated from message flyteidl2.core.K8sPod
 */
export type K8sPod = Message<"flyteidl2.core.K8sPod"> & {
  /**
   * Contains additional metadata for building a kubernetes pod.
   *
   * @generated from field: flyteidl2.core.K8sObjectMetadata metadata = 1;
   */
  metadata?: K8sObjectMetadata;

  /**
   * Defines the primary pod spec created when a task is executed.
   * This should be a JSON-marshalled pod spec, which can be defined in
   * - go, using: https://github.com/kubernetes/api/blob/release-1.21/core/v1/types.go#L2936
   * - python: using https://github.com/kubernetes-client/python/blob/release-19.0/kubernetes/client/models/v1_pod_spec.py
   *
   * @generated from field: google.protobuf.Struct pod_spec = 2;
   */
  podSpec?: JsonObject;

  /**
   * BETA: Optional configuration for DataLoading. If not specified, then default values are used.
   * This makes it possible to to run a completely portable container, that uses inputs and outputs
   * only from the local file-system and without having any reference to flytekit. This is supported only on K8s at the moment.
   * If data loading is enabled, then data will be mounted in accompanying directories specified in the DataLoadingConfig. If the directories
   * are not specified, inputs will be mounted onto and outputs will be uploaded from a pre-determined file-system path. Refer to the documentation
   * to understand the default paths.
   * Only K8s
   *
   * @generated from field: flyteidl2.core.DataLoadingConfig data_config = 3;
   */
  dataConfig?: DataLoadingConfig;

  /**
   * Defines the primary container name when pod template override is executed.
   *
   * @generated from field: string primary_container_name = 4;
   */
  primaryContainerName: string;
};

/**
 * Describes the message flyteidl2.core.K8sPod.
 * Use `create(K8sPodSchema)` to create a new message.
 */
export const K8sPodSchema: GenMessage<K8sPod> = /*@__PURE__*/
  messageDesc(file_idl2_core_tasks, 11);

/**
 * Metadata for building a kubernetes object when a task is executed.
 *
 * @generated from message flyteidl2.core.K8sObjectMetadata
 */
export type K8sObjectMetadata = Message<"flyteidl2.core.K8sObjectMetadata"> & {
  /**
   * Optional labels to add to the pod definition.
   *
   * @generated from field: map<string, string> labels = 1;
   */
  labels: { [key: string]: string };

  /**
   * Optional annotations to add to the pod definition.
   *
   * @generated from field: map<string, string> annotations = 2;
   */
  annotations: { [key: string]: string };
};

/**
 * Describes the message flyteidl2.core.K8sObjectMetadata.
 * Use `create(K8sObjectMetadataSchema)` to create a new message.
 */
export const K8sObjectMetadataSchema: GenMessage<K8sObjectMetadata> = /*@__PURE__*/
  messageDesc(file_idl2_core_tasks, 12);

/**
 * Sql represents a generic sql workload with a statement and dialect.
 *
 * @generated from message flyteidl2.core.Sql
 */
export type Sql = Message<"flyteidl2.core.Sql"> & {
  /**
   * The actual query to run, the query can have templated parameters.
   * We use Flyte's Golang templating format for Query templating.
   * For example,
   * insert overwrite directory '{{ .rawOutputDataPrefix }}' stored as parquet
   * select *
   * from my_table
   * where ds = '{{ .Inputs.ds }}'
   *
   * @generated from field: string statement = 1;
   */
  statement: string;

  /**
   * @generated from field: flyteidl2.core.Sql.Dialect dialect = 2;
   */
  dialect: Sql_Dialect;
};

/**
 * Describes the message flyteidl2.core.Sql.
 * Use `create(SqlSchema)` to create a new message.
 */
export const SqlSchema: GenMessage<Sql> = /*@__PURE__*/
  messageDesc(file_idl2_core_tasks, 13);

/**
 * The dialect of the SQL statement. This is used to validate and parse SQL statements at compilation time to avoid
 * expensive runtime operations. If set to an unsupported dialect, no validation will be done on the statement.
 * We support the following dialect: ansi, hive.
 *
 * @generated from enum flyteidl2.core.Sql.Dialect
 */
export enum Sql_Dialect {
  /**
   * @generated from enum value: UNDEFINED = 0;
   */
  UNDEFINED = 0,

  /**
   * @generated from enum value: ANSI = 1;
   */
  ANSI = 1,

  /**
   * @generated from enum value: HIVE = 2;
   */
  HIVE = 2,

  /**
   * @generated from enum value: OTHER = 3;
   */
  OTHER = 3,
}

/**
 * Describes the enum flyteidl2.core.Sql.Dialect.
 */
export const Sql_DialectSchema: GenEnum<Sql_Dialect> = /*@__PURE__*/
  enumDesc(file_idl2_core_tasks, 13, 0);

