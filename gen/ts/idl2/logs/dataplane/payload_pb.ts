// @generated by protoc-gen-es v2.2.5 with parameter "target=ts,import_extension=.ts"
// @generated from file idl2/logs/dataplane/payload.proto (package flyteidl2.logs.dataplane, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import type { Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import { file_validate_validate } from "../../../validate/validate_pb.ts";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file idl2/logs/dataplane/payload.proto.
 */
export const file_idl2_logs_dataplane_payload: GenFile = /*@__PURE__*/
  fileDesc("CiFpZGwyL2xvZ3MvZGF0YXBsYW5lL3BheWxvYWQucHJvdG8SGGZseXRlaWRsMi5sb2dzLmRhdGFwbGFuZSJTCgtQb2RSZXNvdXJjZRIaCgluYW1lc3BhY2UYASABKAlCB/pCBHICEAESFQoEbmFtZRgCIAEoCUIH+kIEcgIQARIRCgljb250YWluZXIYAyABKAkiugEKHFRhaWxUYXNrRXhlY3V0aW9uTG9nc1JlcXVlc3QSSwoPbG9nZ2luZ19jb250ZXh0GAEgASgLMiguZmx5dGVpZGwyLmxvZ3MuZGF0YXBsYW5lLkxvZ2dpbmdDb250ZXh0Qgj6QgWKAQIQARI0CgZzb3VyY2UYAyABKA4yJC5mbHl0ZWlkbDIubG9ncy5kYXRhcGxhbmUuTG9nc1NvdXJjZRIRCglub19mb2xsb3cYBCABKAhKBAgCEAMizwEKHVRhaWxUYXNrRXhlY3V0aW9uTG9nc1Jlc3BvbnNlEkwKBGxvZ3MYASABKAsyPC5mbHl0ZWlkbDIubG9ncy5kYXRhcGxhbmUuVGFpbFRhc2tFeGVjdXRpb25Mb2dzUmVzcG9uc2UuTG9nc0gAGlYKBExvZ3MSEQoFbGluZXMYASADKAlCAhgBEjsKEHN0cnVjdHVyZWRfbGluZXMYAiADKAsyIS5mbHl0ZWlkbDIubG9ncy5kYXRhcGxhbmUuTG9nTGluZUIICgZyZXN1bHQi1AMKDkxvZ2dpbmdDb250ZXh0Eh0KDGNsdXN0ZXJfbmFtZRgDIAEoCUIH+kIEcgIQARIlChRrdWJlcm5ldGVzX25hbWVzcGFjZRgEIAEoCUIH+kIEcgIQARIkChNrdWJlcm5ldGVzX3BvZF9uYW1lGAUgASgJQgf6QgRyAhABEioKGWt1YmVybmV0ZXNfY29udGFpbmVyX25hbWUYBiABKAlCB/pCBHICEAESQAocZXhlY3V0aW9uX2F0dGVtcHRfc3RhcnRfdGltZRgHIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASPgoaZXhlY3V0aW9uX2F0dGVtcHRfZW5kX3RpbWUYCCABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEmAKFWt1YmVybmV0ZXNfcG9kX2xhYmVscxgJIAMoCzJBLmZseXRlaWRsMi5sb2dzLmRhdGFwbGFuZS5Mb2dnaW5nQ29udGV4dC5LdWJlcm5ldGVzUG9kTGFiZWxzRW50cnkaOgoYS3ViZXJuZXRlc1BvZExhYmVsc0VudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAFKBAgBEAJKBAgCEAMipAEKE0NvbnRhaW5lcklkZW50aWZpZXISHQoMY2x1c3Rlcl9uYW1lGAEgASgJQgf6QgRyAhABEiUKFGt1YmVybmV0ZXNfbmFtZXNwYWNlGAIgASgJQgf6QgRyAhABEiQKE2t1YmVybmV0ZXNfcG9kX25hbWUYAyABKAlCB/pCBHICEAESIQoZa3ViZXJuZXRlc19jb250YWluZXJfbmFtZRgEIAEoCSLHAQoRQ29udGFpbmVyU2VsZWN0b3ISHQoMY2x1c3Rlcl9uYW1lGAEgASgJQgf6QgRyAhABEiUKFGt1YmVybmV0ZXNfbmFtZXNwYWNlGAIgASgJQgf6QgRyAhABEiIKGmt1YmVybmV0ZXNfcG9kX25hbWVfcHJlZml4GAMgASgJEiEKGWt1YmVybmV0ZXNfY29udGFpbmVyX25hbWUYBCABKAkSJQoda3ViZXJuZXRlc19wb2RfbGFiZWxfc2VsZWN0b3IYBSABKAkiQQoPTGl2ZUxvZ3NPcHRpb25zEhYKDmxvZ19wb2Rfc3RhdHVzGAEgASgIEhYKDmxvZ190aW1lc3RhbXBzGAIgASgIIo4DCg9UYWlsTG9nc1JlcXVlc3QSQgoJY29udGFpbmVyGAEgASgLMi0uZmx5dGVpZGwyLmxvZ3MuZGF0YXBsYW5lLkNvbnRhaW5lcklkZW50aWZpZXJIABJJChJjb250YWluZXJfc2VsZWN0b3IYAiABKAsyKy5mbHl0ZWlkbDIubG9ncy5kYXRhcGxhbmUuQ29udGFpbmVyU2VsZWN0b3JIABI4CgpzdGFydF90aW1lGAMgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcEII+kIFsgECCAESLAoIZW5kX3RpbWUYBCABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEjQKBnNvdXJjZRgFIAEoDjIkLmZseXRlaWRsMi5sb2dzLmRhdGFwbGFuZS5Mb2dzU291cmNlEkQKEWxpdmVfbG9nc19vcHRpb25zGAYgASgLMikuZmx5dGVpZGwyLmxvZ3MuZGF0YXBsYW5lLkxpdmVMb2dzT3B0aW9uc0IICgZ0YXJnZXQiigEKB0xvZ0xpbmUSLQoJdGltZXN0YW1wGAEgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBIPCgdtZXNzYWdlGAIgASgJEj8KCm9yaWdpbmF0b3IYAyABKA4yKy5mbHl0ZWlkbDIubG9ncy5kYXRhcGxhbmUuTG9nTGluZU9yaWdpbmF0b3IivwEKCExvZ0xpbmVzEhEKBWxpbmVzGAEgAygJQgIYARIXCg9jb250YWluZXJfaW5kZXgYAiABKA0SSgoJY29udGFpbmVyGAMgASgLMi0uZmx5dGVpZGwyLmxvZ3MuZGF0YXBsYW5lLkNvbnRhaW5lcklkZW50aWZpZXJCCPpCBYoBAhABEjsKEHN0cnVjdHVyZWRfbGluZXMYBCADKAsyIS5mbHl0ZWlkbDIubG9ncy5kYXRhcGxhbmUuTG9nTGluZSJWChFMb2dDb250YWluZXJzTGlzdBJBCgpjb250YWluZXJzGAEgAygLMi0uZmx5dGVpZGwyLmxvZ3MuZGF0YXBsYW5lLkNvbnRhaW5lcklkZW50aWZpZXIiQQoNTG9nTGluZXNCYXRjaBIwCgRsb2dzGAEgAygLMiIuZmx5dGVpZGwyLmxvZ3MuZGF0YXBsYW5lLkxvZ0xpbmVzIsABChBUYWlsTG9nc1Jlc3BvbnNlEksKCmNvbnRhaW5lcnMYASABKAsyKy5mbHl0ZWlkbDIubG9ncy5kYXRhcGxhbmUuTG9nQ29udGFpbmVyc0xpc3RCCPpCBYoBAhABSAASTAoPbG9nX2xpbmVzX2JhdGNoGAMgASgLMicuZmx5dGVpZGwyLmxvZ3MuZGF0YXBsYW5lLkxvZ0xpbmVzQmF0Y2hCCPpCBYoBAhABSABCCwoEcmVzcBID+EIBSgQIAhADKjYKEUxvZ0xpbmVPcmlnaW5hdG9yEgsKB1VOS05PV04QABIICgRVU0VSEAESCgoGU1lTVEVNEAIqRgoKTG9nc1NvdXJjZRIVChFMSVZFX09SX1BFUlNJU1RFRBAAEg0KCUxJVkVfT05MWRABEhIKDlBFUlNJU1RFRF9PTkxZEAJC6QEKHGNvbS5mbHl0ZWlkbDIubG9ncy5kYXRhcGxhbmVCDFBheWxvYWRQcm90b0gCUAFaN2dpdGh1Yi5jb20vZmx5dGVvcmcvZmx5dGUvdjIvZ2VuL2dvL2lkbDIvbG9ncy9kYXRhcGxhbmWiAgNGTESqAhhGbHl0ZWlkbDIuTG9ncy5EYXRhcGxhbmXKAhhGbHl0ZWlkbDJcTG9nc1xEYXRhcGxhbmXiAiRGbHl0ZWlkbDJcTG9nc1xEYXRhcGxhbmVcR1BCTWV0YWRhdGHqAhpGbHl0ZWlkbDI6OkxvZ3M6OkRhdGFwbGFuZWIGcHJvdG8z", [file_google_protobuf_timestamp, file_validate_validate]);

/**
 * @generated from message flyteidl2.logs.dataplane.PodResource
 */
export type PodResource = Message<"flyteidl2.logs.dataplane.PodResource"> & {
  /**
   * The namespace of the pod.
   *
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * The pod name.
   *
   * @generated from field: string name = 2;
   */
  name: string;

  /**
   * The container name. If not provided, attempt to find the primary container, else assume the first container.
   * +optional
   *
   * @generated from field: string container = 3;
   */
  container: string;
};

/**
 * Describes the message flyteidl2.logs.dataplane.PodResource.
 * Use `create(PodResourceSchema)` to create a new message.
 */
export const PodResourceSchema: GenMessage<PodResource> = /*@__PURE__*/
  messageDesc(file_idl2_logs_dataplane_payload, 0);

/**
 * @generated from message flyteidl2.logs.dataplane.TailTaskExecutionLogsRequest
 */
export type TailTaskExecutionLogsRequest = Message<"flyteidl2.logs.dataplane.TailTaskExecutionLogsRequest"> & {
  /**
   * @generated from field: flyteidl2.logs.dataplane.LoggingContext logging_context = 1;
   */
  loggingContext?: LoggingContext;

  /**
   * +optional, used in api-tests
   *
   * @generated from field: flyteidl2.logs.dataplane.LogsSource source = 3;
   */
  source: LogsSource;

  /**
   * +optional, used in api-tests
   *
   * This will be extended in the future:
   * see https://unionai.atlassian.net/wiki/spaces/ENG/pages/922583046/Persisted+Logs
   *
   * @generated from field: bool no_follow = 4;
   */
  noFollow: boolean;
};

/**
 * Describes the message flyteidl2.logs.dataplane.TailTaskExecutionLogsRequest.
 * Use `create(TailTaskExecutionLogsRequestSchema)` to create a new message.
 */
export const TailTaskExecutionLogsRequestSchema: GenMessage<TailTaskExecutionLogsRequest> = /*@__PURE__*/
  messageDesc(file_idl2_logs_dataplane_payload, 1);

/**
 * @generated from message flyteidl2.logs.dataplane.TailTaskExecutionLogsResponse
 */
export type TailTaskExecutionLogsResponse = Message<"flyteidl2.logs.dataplane.TailTaskExecutionLogsResponse"> & {
  /**
   * @generated from oneof flyteidl2.logs.dataplane.TailTaskExecutionLogsResponse.result
   */
  result: {
    /**
     * @generated from field: flyteidl2.logs.dataplane.TailTaskExecutionLogsResponse.Logs logs = 1;
     */
    value: TailTaskExecutionLogsResponse_Logs;
    case: "logs";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message flyteidl2.logs.dataplane.TailTaskExecutionLogsResponse.
 * Use `create(TailTaskExecutionLogsResponseSchema)` to create a new message.
 */
export const TailTaskExecutionLogsResponseSchema: GenMessage<TailTaskExecutionLogsResponse> = /*@__PURE__*/
  messageDesc(file_idl2_logs_dataplane_payload, 2);

/**
 * @generated from message flyteidl2.logs.dataplane.TailTaskExecutionLogsResponse.Logs
 */
export type TailTaskExecutionLogsResponse_Logs = Message<"flyteidl2.logs.dataplane.TailTaskExecutionLogsResponse.Logs"> & {
  /**
   * Each line is separated by either CRLF, CR or LF, which are included
   * at the ends of the lines. This lets clients know whether log emitter
   * wanted to overwrite the previous line (LF) or append a new line (CRLF).
   *
   * @generated from field: repeated string lines = 1 [deprecated = true];
   * @deprecated
   */
  lines: string[];

  /**
   * Each line is separated by either CRLF, CR or LF, which are included
   * at the ends of the lines. This lets clients know whether log emitter
   * wanted to overwrite the previous line (LF) or append a new line (CRLF).
   *
   * @generated from field: repeated flyteidl2.logs.dataplane.LogLine structured_lines = 2;
   */
  structuredLines: LogLine[];
};

/**
 * Describes the message flyteidl2.logs.dataplane.TailTaskExecutionLogsResponse.Logs.
 * Use `create(TailTaskExecutionLogsResponse_LogsSchema)` to create a new message.
 */
export const TailTaskExecutionLogsResponse_LogsSchema: GenMessage<TailTaskExecutionLogsResponse_Logs> = /*@__PURE__*/
  messageDesc(file_idl2_logs_dataplane_payload, 2, 0);

/**
 * Parameters of environment in which logs were collected. Should contain everything
 * necessary to identify location of task execution logs in cloud providers.
 *
 * @generated from message flyteidl2.logs.dataplane.LoggingContext
 */
export type LoggingContext = Message<"flyteidl2.logs.dataplane.LoggingContext"> & {
  /**
   * @generated from field: string cluster_name = 3;
   */
  clusterName: string;

  /**
   * @generated from field: string kubernetes_namespace = 4;
   */
  kubernetesNamespace: string;

  /**
   * @generated from field: string kubernetes_pod_name = 5;
   */
  kubernetesPodName: string;

  /**
   * @generated from field: string kubernetes_container_name = 6;
   */
  kubernetesContainerName: string;

  /**
   * @generated from field: google.protobuf.Timestamp execution_attempt_start_time = 7;
   */
  executionAttemptStartTime?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp execution_attempt_end_time = 8;
   */
  executionAttemptEndTime?: Timestamp;

  /**
   * @generated from field: map<string, string> kubernetes_pod_labels = 9;
   */
  kubernetesPodLabels: { [key: string]: string };
};

/**
 * Describes the message flyteidl2.logs.dataplane.LoggingContext.
 * Use `create(LoggingContextSchema)` to create a new message.
 */
export const LoggingContextSchema: GenMessage<LoggingContext> = /*@__PURE__*/
  messageDesc(file_idl2_logs_dataplane_payload, 3);

/**
 * Parameters of environment in which logs were collected. Should contain everything
 * necessary to identify location of task execution logs in cloud providers.
 *
 * @generated from message flyteidl2.logs.dataplane.ContainerIdentifier
 */
export type ContainerIdentifier = Message<"flyteidl2.logs.dataplane.ContainerIdentifier"> & {
  /**
   * The name of the cluster.
   *
   * @generated from field: string cluster_name = 1;
   */
  clusterName: string;

  /**
   * The namespace in Kubernetes.
   *
   * @generated from field: string kubernetes_namespace = 2;
   */
  kubernetesNamespace: string;

  /**
   * The name of the pod in Kubernetes.
   *
   * @generated from field: string kubernetes_pod_name = 3;
   */
  kubernetesPodName: string;

  /**
   * The name of the container in Kubernetes.
   *
   * @generated from field: string kubernetes_container_name = 4;
   */
  kubernetesContainerName: string;
};

/**
 * Describes the message flyteidl2.logs.dataplane.ContainerIdentifier.
 * Use `create(ContainerIdentifierSchema)` to create a new message.
 */
export const ContainerIdentifierSchema: GenMessage<ContainerIdentifier> = /*@__PURE__*/
  messageDesc(file_idl2_logs_dataplane_payload, 4);

/**
 * @generated from message flyteidl2.logs.dataplane.ContainerSelector
 */
export type ContainerSelector = Message<"flyteidl2.logs.dataplane.ContainerSelector"> & {
  /**
   * The name of the cluster.
   *
   * @generated from field: string cluster_name = 1;
   */
  clusterName: string;

  /**
   * The namespace in Kubernetes.
   *
   * @generated from field: string kubernetes_namespace = 2;
   */
  kubernetesNamespace: string;

  /**
   * The prefix of the name of the pod in Kubernetes. This will only apply to persisted pods' logs because listing by
   * prefix is the supported way to filter pods.
   *
   * @generated from field: string kubernetes_pod_name_prefix = 3;
   */
  kubernetesPodNamePrefix: string;

  /**
   * The name of the container in Kubernetes. If not specified, logs for all containers
   * will be streamed.
   *
   * @generated from field: string kubernetes_container_name = 4;
   */
  kubernetesContainerName: string;

  /**
   * The label selector to filter pods. This will only apply to live pods' logs because Listing by prefix
   * isn't supported.
   *
   * @generated from field: string kubernetes_pod_label_selector = 5;
   */
  kubernetesPodLabelSelector: string;
};

/**
 * Describes the message flyteidl2.logs.dataplane.ContainerSelector.
 * Use `create(ContainerSelectorSchema)` to create a new message.
 */
export const ContainerSelectorSchema: GenMessage<ContainerSelector> = /*@__PURE__*/
  messageDesc(file_idl2_logs_dataplane_payload, 5);

/**
 * @generated from message flyteidl2.logs.dataplane.LiveLogsOptions
 */
export type LiveLogsOptions = Message<"flyteidl2.logs.dataplane.LiveLogsOptions"> & {
  /**
   * LogPodStatus indicates whether to log the pod status along with the logs.
   *
   * @generated from field: bool log_pod_status = 1;
   */
  logPodStatus: boolean;

  /**
   * LogTimestamps indicates whether to log the timestamps along with the logs. It prepends RFC3339 or RFC3339Nano
   * format in the beginning of each log line.
   *
   * @generated from field: bool log_timestamps = 2;
   */
  logTimestamps: boolean;
};

/**
 * Describes the message flyteidl2.logs.dataplane.LiveLogsOptions.
 * Use `create(LiveLogsOptionsSchema)` to create a new message.
 */
export const LiveLogsOptionsSchema: GenMessage<LiveLogsOptions> = /*@__PURE__*/
  messageDesc(file_idl2_logs_dataplane_payload, 6);

/**
 * @generated from message flyteidl2.logs.dataplane.TailLogsRequest
 */
export type TailLogsRequest = Message<"flyteidl2.logs.dataplane.TailLogsRequest"> & {
  /**
   * @generated from oneof flyteidl2.logs.dataplane.TailLogsRequest.target
   */
  target: {
    /**
     * Container identifier.
     *
     * @generated from field: flyteidl2.logs.dataplane.ContainerIdentifier container = 1;
     */
    value: ContainerIdentifier;
    case: "container";
  } | {
    /**
     * Container selector to collect logs from multiple pods/containers.
     *
     * @generated from field: flyteidl2.logs.dataplane.ContainerSelector container_selector = 2;
     */
    value: ContainerSelector;
    case: "containerSelector";
  } | { case: undefined; value?: undefined };

  /**
   * StartTime defines the earliest time at which logs should be retrieved.
   *
   * @generated from field: google.protobuf.Timestamp start_time = 3;
   */
  startTime?: Timestamp;

  /**
   * EndTime defines the latest time at which logs should be retrieved. If left empty, it'll stream indefinitely for live
   * pods and Now() will be used for persisted logs.
   *
   * @generated from field: google.protobuf.Timestamp end_time = 4;
   */
  endTime?: Timestamp;

  /**
   * +optional
   *
   * @generated from field: flyteidl2.logs.dataplane.LogsSource source = 5;
   */
  source: LogsSource;

  /**
   * +optional
   *
   * @generated from field: flyteidl2.logs.dataplane.LiveLogsOptions live_logs_options = 6;
   */
  liveLogsOptions?: LiveLogsOptions;
};

/**
 * Describes the message flyteidl2.logs.dataplane.TailLogsRequest.
 * Use `create(TailLogsRequestSchema)` to create a new message.
 */
export const TailLogsRequestSchema: GenMessage<TailLogsRequest> = /*@__PURE__*/
  messageDesc(file_idl2_logs_dataplane_payload, 7);

/**
 * @generated from message flyteidl2.logs.dataplane.LogLine
 */
export type LogLine = Message<"flyteidl2.logs.dataplane.LogLine"> & {
  /**
   * @generated from field: google.protobuf.Timestamp timestamp = 1;
   */
  timestamp?: Timestamp;

  /**
   * Each line is separated by either CRLF, CR or LF, which are included
   * at the ends of the lines. This lets clients know whether log emitter
   * wanted to overwrite the previous line (LF) or append a new line (CRLF).
   *
   * @generated from field: string message = 2;
   */
  message: string;

  /**
   * @generated from field: flyteidl2.logs.dataplane.LogLineOriginator originator = 3;
   */
  originator: LogLineOriginator;
};

/**
 * Describes the message flyteidl2.logs.dataplane.LogLine.
 * Use `create(LogLineSchema)` to create a new message.
 */
export const LogLineSchema: GenMessage<LogLine> = /*@__PURE__*/
  messageDesc(file_idl2_logs_dataplane_payload, 8);

/**
 * @generated from message flyteidl2.logs.dataplane.LogLines
 */
export type LogLines = Message<"flyteidl2.logs.dataplane.LogLines"> & {
  /**
   * Each line is separated by either CRLF, CR or LF, which are included
   * at the ends of the lines. This lets clients know whether log emitter
   * wanted to overwrite the previous line (LF) or append a new line (CRLF).
   *
   * @generated from field: repeated string lines = 1 [deprecated = true];
   * @deprecated
   */
  lines: string[];

  /**
   * The index of the container in the list of containers. If the request was made with a single container identifier,
   * this value will always be 0. Otherwise, it'll be an index into the last list of containers sent in the stream.
   *
   * @generated from field: uint32 container_index = 2;
   */
  containerIndex: number;

  /**
   * The container identifier.
   *
   * @generated from field: flyteidl2.logs.dataplane.ContainerIdentifier container = 3;
   */
  container?: ContainerIdentifier;

  /**
   * Each line is separated by either CRLF, CR or LF, which are included
   * at the ends of the lines. This lets clients know whether log emitter
   * wanted to overwrite the previous line (LF) or append a new line (CRLF).
   *
   * @generated from field: repeated flyteidl2.logs.dataplane.LogLine structured_lines = 4;
   */
  structuredLines: LogLine[];
};

/**
 * Describes the message flyteidl2.logs.dataplane.LogLines.
 * Use `create(LogLinesSchema)` to create a new message.
 */
export const LogLinesSchema: GenMessage<LogLines> = /*@__PURE__*/
  messageDesc(file_idl2_logs_dataplane_payload, 9);

/**
 * @generated from message flyteidl2.logs.dataplane.LogContainersList
 */
export type LogContainersList = Message<"flyteidl2.logs.dataplane.LogContainersList"> & {
  /**
   * @generated from field: repeated flyteidl2.logs.dataplane.ContainerIdentifier containers = 1;
   */
  containers: ContainerIdentifier[];
};

/**
 * Describes the message flyteidl2.logs.dataplane.LogContainersList.
 * Use `create(LogContainersListSchema)` to create a new message.
 */
export const LogContainersListSchema: GenMessage<LogContainersList> = /*@__PURE__*/
  messageDesc(file_idl2_logs_dataplane_payload, 10);

/**
 * @generated from message flyteidl2.logs.dataplane.LogLinesBatch
 */
export type LogLinesBatch = Message<"flyteidl2.logs.dataplane.LogLinesBatch"> & {
  /**
   * @generated from field: repeated flyteidl2.logs.dataplane.LogLines logs = 1;
   */
  logs: LogLines[];
};

/**
 * Describes the message flyteidl2.logs.dataplane.LogLinesBatch.
 * Use `create(LogLinesBatchSchema)` to create a new message.
 */
export const LogLinesBatchSchema: GenMessage<LogLinesBatch> = /*@__PURE__*/
  messageDesc(file_idl2_logs_dataplane_payload, 11);

/**
 * @generated from message flyteidl2.logs.dataplane.TailLogsResponse
 */
export type TailLogsResponse = Message<"flyteidl2.logs.dataplane.TailLogsResponse"> & {
  /**
   * @generated from oneof flyteidl2.logs.dataplane.TailLogsResponse.resp
   */
  resp: {
    /**
     * Containers lists the containers that the logs are being tailed for. This is expected to be the first
     * message to be sent in the stream but also can be sent at any later time to update the list of
     * containers being tailed.
     *
     * @generated from field: flyteidl2.logs.dataplane.LogContainersList containers = 1;
     */
    value: LogContainersList;
    case: "containers";
  } | {
    /**
     * The latest log lines for the application.
     *
     * @generated from field: flyteidl2.logs.dataplane.LogLinesBatch log_lines_batch = 3;
     */
    value: LogLinesBatch;
    case: "logLinesBatch";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message flyteidl2.logs.dataplane.TailLogsResponse.
 * Use `create(TailLogsResponseSchema)` to create a new message.
 */
export const TailLogsResponseSchema: GenMessage<TailLogsResponse> = /*@__PURE__*/
  messageDesc(file_idl2_logs_dataplane_payload, 12);

/**
 * @generated from enum flyteidl2.logs.dataplane.LogLineOriginator
 */
export enum LogLineOriginator {
  /**
   * The originator of the log line is unknown.
   *
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * The originator of the log line is the user application.
   *
   * @generated from enum value: USER = 1;
   */
  USER = 1,

  /**
   * The originator of the log line is the system.
   *
   * @generated from enum value: SYSTEM = 2;
   */
  SYSTEM = 2,
}

/**
 * Describes the enum flyteidl2.logs.dataplane.LogLineOriginator.
 */
export const LogLineOriginatorSchema: GenEnum<LogLineOriginator> = /*@__PURE__*/
  enumDesc(file_idl2_logs_dataplane_payload, 0);

/**
 * @generated from enum flyteidl2.logs.dataplane.LogsSource
 */
export enum LogsSource {
  /**
   * Return live logs and fall back to persisted if not available.
   *
   * @generated from enum value: LIVE_OR_PERSISTED = 0;
   */
  LIVE_OR_PERSISTED = 0,

  /**
   * Return live logs only or error if pod is no longer around.
   *
   * @generated from enum value: LIVE_ONLY = 1;
   */
  LIVE_ONLY = 1,

  /**
   * Return persisted logs only.
   *
   * @generated from enum value: PERSISTED_ONLY = 2;
   */
  PERSISTED_ONLY = 2,
}

/**
 * Describes the enum flyteidl2.logs.dataplane.LogsSource.
 */
export const LogsSourceSchema: GenEnum<LogsSource> = /*@__PURE__*/
  enumDesc(file_idl2_logs_dataplane_payload, 1);

