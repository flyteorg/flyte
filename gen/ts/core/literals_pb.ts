// @generated by protoc-gen-es v2.2.5 with parameter "target=ts,import_extension=.ts"
// @generated from file core/literals.proto (package flyteidl.core, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import type { Duration, Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_duration, file_google_protobuf_struct, file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import type { BlobType, Error, LiteralType, OutputReference, SchemaType, StructuredDatasetType } from "./types_pb.ts";
import { file_core_types } from "./types_pb.ts";
import type { JsonObject, Message } from "@bufbuild/protobuf";

/**
 * Describes the file core/literals.proto.
 */
export const file_core_literals: GenFile = /*@__PURE__*/
  fileDesc("ChNjb3JlL2xpdGVyYWxzLnByb3RvEg1mbHl0ZWlkbC5jb3JlIsgBCglQcmltaXRpdmUSEQoHaW50ZWdlchgBIAEoA0gAEhUKC2Zsb2F0X3ZhbHVlGAIgASgBSAASFgoMc3RyaW5nX3ZhbHVlGAMgASgJSAASEQoHYm9vbGVhbhgEIAEoCEgAEi4KCGRhdGV0aW1lGAUgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcEgAEi0KCGR1cmF0aW9uGAYgASgLMhkuZ29vZ2xlLnByb3RvYnVmLkR1cmF0aW9uSABCBwoFdmFsdWUiBgoEVm9pZCJCCgRCbG9iEi0KCG1ldGFkYXRhGAEgASgLMhsuZmx5dGVpZGwuY29yZS5CbG9iTWV0YWRhdGESCwoDdXJpGAMgASgJIjUKDEJsb2JNZXRhZGF0YRIlCgR0eXBlGAEgASgLMhcuZmx5dGVpZGwuY29yZS5CbG9iVHlwZSIkCgZCaW5hcnkSDQoFdmFsdWUYASABKAwSCwoDdGFnGAIgASgJIj4KBlNjaGVtYRILCgN1cmkYASABKAkSJwoEdHlwZRgDIAEoCzIZLmZseXRlaWRsLmNvcmUuU2NoZW1hVHlwZSJYCgVVbmlvbhIlCgV2YWx1ZRgBIAEoCzIWLmZseXRlaWRsLmNvcmUuTGl0ZXJhbBIoCgR0eXBlGAIgASgLMhouZmx5dGVpZGwuY29yZS5MaXRlcmFsVHlwZSJiChlTdHJ1Y3R1cmVkRGF0YXNldE1ldGFkYXRhEkUKF3N0cnVjdHVyZWRfZGF0YXNldF90eXBlGAEgASgLMiQuZmx5dGVpZGwuY29yZS5TdHJ1Y3R1cmVkRGF0YXNldFR5cGUiXAoRU3RydWN0dXJlZERhdGFzZXQSCwoDdXJpGAEgASgJEjoKCG1ldGFkYXRhGAIgASgLMiguZmx5dGVpZGwuY29yZS5TdHJ1Y3R1cmVkRGF0YXNldE1ldGFkYXRhIpsDCgZTY2FsYXISLQoJcHJpbWl0aXZlGAEgASgLMhguZmx5dGVpZGwuY29yZS5QcmltaXRpdmVIABIjCgRibG9iGAIgASgLMhMuZmx5dGVpZGwuY29yZS5CbG9iSAASJwoGYmluYXJ5GAMgASgLMhUuZmx5dGVpZGwuY29yZS5CaW5hcnlIABInCgZzY2hlbWEYBCABKAsyFS5mbHl0ZWlkbC5jb3JlLlNjaGVtYUgAEigKCW5vbmVfdHlwZRgFIAEoCzITLmZseXRlaWRsLmNvcmUuVm9pZEgAEiUKBWVycm9yGAYgASgLMhQuZmx5dGVpZGwuY29yZS5FcnJvckgAEioKB2dlbmVyaWMYByABKAsyFy5nb29nbGUucHJvdG9idWYuU3RydWN0SAASPgoSc3RydWN0dXJlZF9kYXRhc2V0GAggASgLMiAuZmx5dGVpZGwuY29yZS5TdHJ1Y3R1cmVkRGF0YXNldEgAEiUKBXVuaW9uGAkgASgLMhQuZmx5dGVpZGwuY29yZS5VbmlvbkgAQgcKBXZhbHVlIucCCgdMaXRlcmFsEicKBnNjYWxhchgBIAEoCzIVLmZseXRlaWRsLmNvcmUuU2NhbGFySAASNgoKY29sbGVjdGlvbhgCIAEoCzIgLmZseXRlaWRsLmNvcmUuTGl0ZXJhbENvbGxlY3Rpb25IABIoCgNtYXAYAyABKAsyGS5mbHl0ZWlkbC5jb3JlLkxpdGVyYWxNYXBIABJFChJvZmZsb2FkZWRfbWV0YWRhdGEYCCABKAsyJy5mbHl0ZWlkbC5jb3JlLkxpdGVyYWxPZmZsb2FkZWRNZXRhZGF0YUgAEgwKBGhhc2gYBCABKAkSNgoIbWV0YWRhdGEYBSADKAsyJC5mbHl0ZWlkbC5jb3JlLkxpdGVyYWwuTWV0YWRhdGFFbnRyeRovCg1NZXRhZGF0YUVudHJ5EgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCToCOAFCBwoFdmFsdWVKBAgGEAdKBAgHEAgibgoYTGl0ZXJhbE9mZmxvYWRlZE1ldGFkYXRhEgsKA3VyaRgBIAEoCRISCgpzaXplX2J5dGVzGAIgASgEEjEKDWluZmVycmVkX3R5cGUYAyABKAsyGi5mbHl0ZWlkbC5jb3JlLkxpdGVyYWxUeXBlIj0KEUxpdGVyYWxDb2xsZWN0aW9uEigKCGxpdGVyYWxzGAEgAygLMhYuZmx5dGVpZGwuY29yZS5MaXRlcmFsIpABCgpMaXRlcmFsTWFwEjkKCGxpdGVyYWxzGAEgAygLMicuZmx5dGVpZGwuY29yZS5MaXRlcmFsTWFwLkxpdGVyYWxzRW50cnkaRwoNTGl0ZXJhbHNFbnRyeRILCgNrZXkYASABKAkSJQoFdmFsdWUYAiABKAsyFi5mbHl0ZWlkbC5jb3JlLkxpdGVyYWw6AjgBIkUKFUJpbmRpbmdEYXRhQ29sbGVjdGlvbhIsCghiaW5kaW5ncxgBIAMoCzIaLmZseXRlaWRsLmNvcmUuQmluZGluZ0RhdGEinAEKDkJpbmRpbmdEYXRhTWFwEj0KCGJpbmRpbmdzGAEgAygLMisuZmx5dGVpZGwuY29yZS5CaW5kaW5nRGF0YU1hcC5CaW5kaW5nc0VudHJ5GksKDUJpbmRpbmdzRW50cnkSCwoDa2V5GAEgASgJEikKBXZhbHVlGAIgASgLMhouZmx5dGVpZGwuY29yZS5CaW5kaW5nRGF0YToCOAEiOwoJVW5pb25JbmZvEi4KCnRhcmdldFR5cGUYASABKAsyGi5mbHl0ZWlkbC5jb3JlLkxpdGVyYWxUeXBlIswCCgtCaW5kaW5nRGF0YRInCgZzY2FsYXIYASABKAsyFS5mbHl0ZWlkbC5jb3JlLlNjYWxhckgAEjoKCmNvbGxlY3Rpb24YAiABKAsyJC5mbHl0ZWlkbC5jb3JlLkJpbmRpbmdEYXRhQ29sbGVjdGlvbkgAEjEKB3Byb21pc2UYAyABKAsyHi5mbHl0ZWlkbC5jb3JlLk91dHB1dFJlZmVyZW5jZUgAEiwKA21hcBgEIAEoCzIdLmZseXRlaWRsLmNvcmUuQmluZGluZ0RhdGFNYXBIABJFChJvZmZsb2FkZWRfbWV0YWRhdGEYBiABKAsyJy5mbHl0ZWlkbC5jb3JlLkxpdGVyYWxPZmZsb2FkZWRNZXRhZGF0YUgAEicKBXVuaW9uGAUgASgLMhguZmx5dGVpZGwuY29yZS5VbmlvbkluZm9CBwoFdmFsdWUiQwoHQmluZGluZxILCgN2YXIYASABKAkSKwoHYmluZGluZxgCIAEoCzIaLmZseXRlaWRsLmNvcmUuQmluZGluZ0RhdGEiKgoMS2V5VmFsdWVQYWlyEgsKA2tleRgBIAEoCRINCgV2YWx1ZRgCIAEoCSIgCg1SZXRyeVN0cmF0ZWd5Eg8KB3JldHJpZXMYBSABKA1CoAEKEWNvbS5mbHl0ZWlkbC5jb3JlQg1MaXRlcmFsc1Byb3RvSAJQAVolZ2l0aHViLmNvbS9mbHl0ZW9yZy9mbHl0ZS9nZW4vZ28vY29yZaICA0ZDWKoCDUZseXRlaWRsLkNvcmXKAg1GbHl0ZWlkbFxDb3Jl4gIZRmx5dGVpZGxcQ29yZVxHUEJNZXRhZGF0YeoCDkZseXRlaWRsOjpDb3JlYgZwcm90bzM", [file_google_protobuf_timestamp, file_google_protobuf_duration, file_google_protobuf_struct, file_core_types]);

/**
 * Primitive Types
 *
 * @generated from message flyteidl.core.Primitive
 */
export type Primitive = Message<"flyteidl.core.Primitive"> & {
  /**
   * Defines one of simple primitive types. These types will get translated into different programming languages as
   * described in https://developers.google.com/protocol-buffers/docs/proto#scalar.
   *
   * @generated from oneof flyteidl.core.Primitive.value
   */
  value: {
    /**
     * @generated from field: int64 integer = 1;
     */
    value: bigint;
    case: "integer";
  } | {
    /**
     * @generated from field: double float_value = 2;
     */
    value: number;
    case: "floatValue";
  } | {
    /**
     * @generated from field: string string_value = 3;
     */
    value: string;
    case: "stringValue";
  } | {
    /**
     * @generated from field: bool boolean = 4;
     */
    value: boolean;
    case: "boolean";
  } | {
    /**
     * @generated from field: google.protobuf.Timestamp datetime = 5;
     */
    value: Timestamp;
    case: "datetime";
  } | {
    /**
     * @generated from field: google.protobuf.Duration duration = 6;
     */
    value: Duration;
    case: "duration";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message flyteidl.core.Primitive.
 * Use `create(PrimitiveSchema)` to create a new message.
 */
export const PrimitiveSchema: GenMessage<Primitive> = /*@__PURE__*/
  messageDesc(file_core_literals, 0);

/**
 * Used to denote a nil/null/None assignment to a scalar value. The underlying LiteralType for Void is intentionally
 * undefined since it can be assigned to a scalar of any LiteralType.
 *
 * @generated from message flyteidl.core.Void
 */
export type Void = Message<"flyteidl.core.Void"> & {
};

/**
 * Describes the message flyteidl.core.Void.
 * Use `create(VoidSchema)` to create a new message.
 */
export const VoidSchema: GenMessage<Void> = /*@__PURE__*/
  messageDesc(file_core_literals, 1);

/**
 * Refers to an offloaded set of files. It encapsulates the type of the store and a unique uri for where the data is.
 * There are no restrictions on how the uri is formatted since it will depend on how to interact with the store.
 *
 * @generated from message flyteidl.core.Blob
 */
export type Blob = Message<"flyteidl.core.Blob"> & {
  /**
   * @generated from field: flyteidl.core.BlobMetadata metadata = 1;
   */
  metadata?: BlobMetadata;

  /**
   * @generated from field: string uri = 3;
   */
  uri: string;
};

/**
 * Describes the message flyteidl.core.Blob.
 * Use `create(BlobSchema)` to create a new message.
 */
export const BlobSchema: GenMessage<Blob> = /*@__PURE__*/
  messageDesc(file_core_literals, 2);

/**
 * @generated from message flyteidl.core.BlobMetadata
 */
export type BlobMetadata = Message<"flyteidl.core.BlobMetadata"> & {
  /**
   * @generated from field: flyteidl.core.BlobType type = 1;
   */
  type?: BlobType;
};

/**
 * Describes the message flyteidl.core.BlobMetadata.
 * Use `create(BlobMetadataSchema)` to create a new message.
 */
export const BlobMetadataSchema: GenMessage<BlobMetadata> = /*@__PURE__*/
  messageDesc(file_core_literals, 3);

/**
 * A simple byte array with a tag to help different parts of the system communicate about what is in the byte array.
 * It's strongly advisable that consumers of this type define a unique tag and validate the tag before parsing the data.
 *
 * @generated from message flyteidl.core.Binary
 */
export type Binary = Message<"flyteidl.core.Binary"> & {
  /**
   * Serialized data (MessagePack) for supported types like Dataclass, Pydantic BaseModel, and untyped dict.
   *
   * @generated from field: bytes value = 1;
   */
  value: Uint8Array;

  /**
   * The serialization format identifier (e.g., MessagePack). Consumers must define unique tags and validate them before deserialization.
   *
   * @generated from field: string tag = 2;
   */
  tag: string;
};

/**
 * Describes the message flyteidl.core.Binary.
 * Use `create(BinarySchema)` to create a new message.
 */
export const BinarySchema: GenMessage<Binary> = /*@__PURE__*/
  messageDesc(file_core_literals, 4);

/**
 * A strongly typed schema that defines the interface of data retrieved from the underlying storage medium.
 *
 * @generated from message flyteidl.core.Schema
 */
export type Schema = Message<"flyteidl.core.Schema"> & {
  /**
   * @generated from field: string uri = 1;
   */
  uri: string;

  /**
   * @generated from field: flyteidl.core.SchemaType type = 3;
   */
  type?: SchemaType;
};

/**
 * Describes the message flyteidl.core.Schema.
 * Use `create(SchemaSchema)` to create a new message.
 */
export const SchemaSchema: GenMessage<Schema> = /*@__PURE__*/
  messageDesc(file_core_literals, 5);

/**
 * The runtime representation of a tagged union value. See `UnionType` for more details.
 *
 * @generated from message flyteidl.core.Union
 */
export type Union = Message<"flyteidl.core.Union"> & {
  /**
   * @generated from field: flyteidl.core.Literal value = 1;
   */
  value?: Literal;

  /**
   * @generated from field: flyteidl.core.LiteralType type = 2;
   */
  type?: LiteralType;
};

/**
 * Describes the message flyteidl.core.Union.
 * Use `create(UnionSchema)` to create a new message.
 */
export const UnionSchema: GenMessage<Union> = /*@__PURE__*/
  messageDesc(file_core_literals, 6);

/**
 * @generated from message flyteidl.core.StructuredDatasetMetadata
 */
export type StructuredDatasetMetadata = Message<"flyteidl.core.StructuredDatasetMetadata"> & {
  /**
   * Bundle the type information along with the literal.
   * This is here because StructuredDatasets can often be more defined at run time than at compile time.
   * That is, at compile time you might only declare a task to return a pandas dataframe or a StructuredDataset,
   * without any column information, but at run time, you might have that column information.
   * flytekit python will copy this type information into the literal, from the type information, if not provided by
   * the various plugins (encoders).
   * Since this field is run time generated, it's not used for any type checking.
   *
   * @generated from field: flyteidl.core.StructuredDatasetType structured_dataset_type = 1;
   */
  structuredDatasetType?: StructuredDatasetType;
};

/**
 * Describes the message flyteidl.core.StructuredDatasetMetadata.
 * Use `create(StructuredDatasetMetadataSchema)` to create a new message.
 */
export const StructuredDatasetMetadataSchema: GenMessage<StructuredDatasetMetadata> = /*@__PURE__*/
  messageDesc(file_core_literals, 7);

/**
 * @generated from message flyteidl.core.StructuredDataset
 */
export type StructuredDataset = Message<"flyteidl.core.StructuredDataset"> & {
  /**
   * String location uniquely identifying where the data is.
   * Should start with the storage location (e.g. s3://, gs://, bq://, etc.)
   *
   * @generated from field: string uri = 1;
   */
  uri: string;

  /**
   * @generated from field: flyteidl.core.StructuredDatasetMetadata metadata = 2;
   */
  metadata?: StructuredDatasetMetadata;
};

/**
 * Describes the message flyteidl.core.StructuredDataset.
 * Use `create(StructuredDatasetSchema)` to create a new message.
 */
export const StructuredDatasetSchema: GenMessage<StructuredDataset> = /*@__PURE__*/
  messageDesc(file_core_literals, 8);

/**
 * @generated from message flyteidl.core.Scalar
 */
export type Scalar = Message<"flyteidl.core.Scalar"> & {
  /**
   * @generated from oneof flyteidl.core.Scalar.value
   */
  value: {
    /**
     * @generated from field: flyteidl.core.Primitive primitive = 1;
     */
    value: Primitive;
    case: "primitive";
  } | {
    /**
     * @generated from field: flyteidl.core.Blob blob = 2;
     */
    value: Blob;
    case: "blob";
  } | {
    /**
     * @generated from field: flyteidl.core.Binary binary = 3;
     */
    value: Binary;
    case: "binary";
  } | {
    /**
     * @generated from field: flyteidl.core.Schema schema = 4;
     */
    value: Schema;
    case: "schema";
  } | {
    /**
     * @generated from field: flyteidl.core.Void none_type = 5;
     */
    value: Void;
    case: "noneType";
  } | {
    /**
     * @generated from field: flyteidl.core.Error error = 6;
     */
    value: Error;
    case: "error";
  } | {
    /**
     * @generated from field: google.protobuf.Struct generic = 7;
     */
    value: JsonObject;
    case: "generic";
  } | {
    /**
     * @generated from field: flyteidl.core.StructuredDataset structured_dataset = 8;
     */
    value: StructuredDataset;
    case: "structuredDataset";
  } | {
    /**
     * @generated from field: flyteidl.core.Union union = 9;
     */
    value: Union;
    case: "union";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message flyteidl.core.Scalar.
 * Use `create(ScalarSchema)` to create a new message.
 */
export const ScalarSchema: GenMessage<Scalar> = /*@__PURE__*/
  messageDesc(file_core_literals, 9);

/**
 * A simple value. This supports any level of nesting (e.g. array of array of array of Blobs) as well as simple primitives.
 *
 * @generated from message flyteidl.core.Literal
 */
export type Literal = Message<"flyteidl.core.Literal"> & {
  /**
   * @generated from oneof flyteidl.core.Literal.value
   */
  value: {
    /**
     * A simple value.
     *
     * @generated from field: flyteidl.core.Scalar scalar = 1;
     */
    value: Scalar;
    case: "scalar";
  } | {
    /**
     * A collection of literals to allow nesting.
     *
     * @generated from field: flyteidl.core.LiteralCollection collection = 2;
     */
    value: LiteralCollection;
    case: "collection";
  } | {
    /**
     * A map of strings to literals.
     *
     * @generated from field: flyteidl.core.LiteralMap map = 3;
     */
    value: LiteralMap;
    case: "map";
  } | {
    /**
     * Offloaded literal metadata
     * When you deserialize the offloaded metadata, it would be of Literal and its type would be defined by LiteralType stored in offloaded_metadata.
     *
     * @generated from field: flyteidl.core.LiteralOffloadedMetadata offloaded_metadata = 8;
     */
    value: LiteralOffloadedMetadata;
    case: "offloadedMetadata";
  } | { case: undefined; value?: undefined };

  /**
   * A hash representing this literal.
   * This is used for caching purposes. For more details refer to RFC 1893
   * (https://github.com/flyteorg/flyte/blob/master/rfc/system/1893-caching-of-offloaded-objects.md)
   *
   * @generated from field: string hash = 4;
   */
  hash: string;

  /**
   * Additional metadata for literals.
   *
   * @generated from field: map<string, string> metadata = 5;
   */
  metadata: { [key: string]: string };
};

/**
 * Describes the message flyteidl.core.Literal.
 * Use `create(LiteralSchema)` to create a new message.
 */
export const LiteralSchema: GenMessage<Literal> = /*@__PURE__*/
  messageDesc(file_core_literals, 10);

/**
 * A message that contains the metadata of the offloaded data.
 *
 * @generated from message flyteidl.core.LiteralOffloadedMetadata
 */
export type LiteralOffloadedMetadata = Message<"flyteidl.core.LiteralOffloadedMetadata"> & {
  /**
   * The location of the offloaded core.Literal.
   *
   * @generated from field: string uri = 1;
   */
  uri: string;

  /**
   * The size of the offloaded data.
   *
   * @generated from field: uint64 size_bytes = 2;
   */
  sizeBytes: bigint;

  /**
   * The inferred literal type of the offloaded data.
   *
   * @generated from field: flyteidl.core.LiteralType inferred_type = 3;
   */
  inferredType?: LiteralType;
};

/**
 * Describes the message flyteidl.core.LiteralOffloadedMetadata.
 * Use `create(LiteralOffloadedMetadataSchema)` to create a new message.
 */
export const LiteralOffloadedMetadataSchema: GenMessage<LiteralOffloadedMetadata> = /*@__PURE__*/
  messageDesc(file_core_literals, 11);

/**
 * A collection of literals. This is a workaround since oneofs in proto messages cannot contain a repeated field.
 *
 * @generated from message flyteidl.core.LiteralCollection
 */
export type LiteralCollection = Message<"flyteidl.core.LiteralCollection"> & {
  /**
   * @generated from field: repeated flyteidl.core.Literal literals = 1;
   */
  literals: Literal[];
};

/**
 * Describes the message flyteidl.core.LiteralCollection.
 * Use `create(LiteralCollectionSchema)` to create a new message.
 */
export const LiteralCollectionSchema: GenMessage<LiteralCollection> = /*@__PURE__*/
  messageDesc(file_core_literals, 12);

/**
 * A map of literals. This is a workaround since oneofs in proto messages cannot contain a repeated field.
 *
 * @generated from message flyteidl.core.LiteralMap
 */
export type LiteralMap = Message<"flyteidl.core.LiteralMap"> & {
  /**
   * @generated from field: map<string, flyteidl.core.Literal> literals = 1;
   */
  literals: { [key: string]: Literal };
};

/**
 * Describes the message flyteidl.core.LiteralMap.
 * Use `create(LiteralMapSchema)` to create a new message.
 */
export const LiteralMapSchema: GenMessage<LiteralMap> = /*@__PURE__*/
  messageDesc(file_core_literals, 13);

/**
 * A collection of BindingData items.
 *
 * @generated from message flyteidl.core.BindingDataCollection
 */
export type BindingDataCollection = Message<"flyteidl.core.BindingDataCollection"> & {
  /**
   * @generated from field: repeated flyteidl.core.BindingData bindings = 1;
   */
  bindings: BindingData[];
};

/**
 * Describes the message flyteidl.core.BindingDataCollection.
 * Use `create(BindingDataCollectionSchema)` to create a new message.
 */
export const BindingDataCollectionSchema: GenMessage<BindingDataCollection> = /*@__PURE__*/
  messageDesc(file_core_literals, 14);

/**
 * A map of BindingData items.
 *
 * @generated from message flyteidl.core.BindingDataMap
 */
export type BindingDataMap = Message<"flyteidl.core.BindingDataMap"> & {
  /**
   * @generated from field: map<string, flyteidl.core.BindingData> bindings = 1;
   */
  bindings: { [key: string]: BindingData };
};

/**
 * Describes the message flyteidl.core.BindingDataMap.
 * Use `create(BindingDataMapSchema)` to create a new message.
 */
export const BindingDataMapSchema: GenMessage<BindingDataMap> = /*@__PURE__*/
  messageDesc(file_core_literals, 15);

/**
 * @generated from message flyteidl.core.UnionInfo
 */
export type UnionInfo = Message<"flyteidl.core.UnionInfo"> & {
  /**
   * @generated from field: flyteidl.core.LiteralType targetType = 1;
   */
  targetType?: LiteralType;
};

/**
 * Describes the message flyteidl.core.UnionInfo.
 * Use `create(UnionInfoSchema)` to create a new message.
 */
export const UnionInfoSchema: GenMessage<UnionInfo> = /*@__PURE__*/
  messageDesc(file_core_literals, 16);

/**
 * Specifies either a simple value or a reference to another output.
 *
 * @generated from message flyteidl.core.BindingData
 */
export type BindingData = Message<"flyteidl.core.BindingData"> & {
  /**
   * @generated from oneof flyteidl.core.BindingData.value
   */
  value: {
    /**
     * A simple scalar value.
     *
     * @generated from field: flyteidl.core.Scalar scalar = 1;
     */
    value: Scalar;
    case: "scalar";
  } | {
    /**
     * A collection of binding data. This allows nesting of binding data to any number
     * of levels.
     *
     * @generated from field: flyteidl.core.BindingDataCollection collection = 2;
     */
    value: BindingDataCollection;
    case: "collection";
  } | {
    /**
     * References an output promised by another node.
     *
     * @generated from field: flyteidl.core.OutputReference promise = 3;
     */
    value: OutputReference;
    case: "promise";
  } | {
    /**
     * A map of bindings. The key is always a string.
     *
     * @generated from field: flyteidl.core.BindingDataMap map = 4;
     */
    value: BindingDataMap;
    case: "map";
  } | {
    /**
     * Offloaded literal metadata
     * When you deserialize the offloaded metadata, it would be of Literal and its type would be defined by LiteralType stored in offloaded_metadata.
     * Used for nodes that don't have promises from upstream nodes such as ArrayNode subNodes.
     *
     * @generated from field: flyteidl.core.LiteralOffloadedMetadata offloaded_metadata = 6;
     */
    value: LiteralOffloadedMetadata;
    case: "offloadedMetadata";
  } | { case: undefined; value?: undefined };

  /**
   * @generated from field: flyteidl.core.UnionInfo union = 5;
   */
  union?: UnionInfo;
};

/**
 * Describes the message flyteidl.core.BindingData.
 * Use `create(BindingDataSchema)` to create a new message.
 */
export const BindingDataSchema: GenMessage<BindingData> = /*@__PURE__*/
  messageDesc(file_core_literals, 17);

/**
 * An input/output binding of a variable to either static value or a node output.
 *
 * @generated from message flyteidl.core.Binding
 */
export type Binding = Message<"flyteidl.core.Binding"> & {
  /**
   * Variable name must match an input/output variable of the node.
   *
   * @generated from field: string var = 1;
   */
  var: string;

  /**
   * Data to use to bind this variable.
   *
   * @generated from field: flyteidl.core.BindingData binding = 2;
   */
  binding?: BindingData;
};

/**
 * Describes the message flyteidl.core.Binding.
 * Use `create(BindingSchema)` to create a new message.
 */
export const BindingSchema: GenMessage<Binding> = /*@__PURE__*/
  messageDesc(file_core_literals, 18);

/**
 * A generic key value pair.
 *
 * @generated from message flyteidl.core.KeyValuePair
 */
export type KeyValuePair = Message<"flyteidl.core.KeyValuePair"> & {
  /**
   * required.
   *
   * @generated from field: string key = 1;
   */
  key: string;

  /**
   * +optional.
   *
   * @generated from field: string value = 2;
   */
  value: string;
};

/**
 * Describes the message flyteidl.core.KeyValuePair.
 * Use `create(KeyValuePairSchema)` to create a new message.
 */
export const KeyValuePairSchema: GenMessage<KeyValuePair> = /*@__PURE__*/
  messageDesc(file_core_literals, 19);

/**
 * Retry strategy associated with an executable unit.
 *
 * @generated from message flyteidl.core.RetryStrategy
 */
export type RetryStrategy = Message<"flyteidl.core.RetryStrategy"> & {
  /**
   * Number of retries. Retries will be consumed when the job fails with a recoverable error.
   * The number of retries must be less than or equals to 10.
   *
   * @generated from field: uint32 retries = 5;
   */
  retries: number;
};

/**
 * Describes the message flyteidl.core.RetryStrategy.
 * Use `create(RetryStrategySchema)` to create a new message.
 */
export const RetryStrategySchema: GenMessage<RetryStrategy> = /*@__PURE__*/
  messageDesc(file_core_literals, 20);

