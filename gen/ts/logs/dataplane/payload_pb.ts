// @generated by protoc-gen-es v2.2.5 with parameter "target=ts,import_extension=.ts"
// @generated from file logs/dataplane/payload.proto (package flyteidl.logs.dataplane, syntax proto3)
/* eslint-disable */

import type { GenEnum, GenFile, GenMessage } from "@bufbuild/protobuf/codegenv1";
import { enumDesc, fileDesc, messageDesc } from "@bufbuild/protobuf/codegenv1";
import type { Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import { file_validate_validate } from "../../validate/validate_pb.ts";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file logs/dataplane/payload.proto.
 */
export const file_logs_dataplane_payload: GenFile = /*@__PURE__*/
  fileDesc("Chxsb2dzL2RhdGFwbGFuZS9wYXlsb2FkLnByb3RvEhdmbHl0ZWlkbC5sb2dzLmRhdGFwbGFuZSJTCgtQb2RSZXNvdXJjZRIaCgluYW1lc3BhY2UYASABKAlCB/pCBHICEAESFQoEbmFtZRgCIAEoCUIH+kIEcgIQARIRCgljb250YWluZXIYAyABKAkiuAEKHFRhaWxUYXNrRXhlY3V0aW9uTG9nc1JlcXVlc3QSSgoPbG9nZ2luZ19jb250ZXh0GAEgASgLMicuZmx5dGVpZGwubG9ncy5kYXRhcGxhbmUuTG9nZ2luZ0NvbnRleHRCCPpCBYoBAhABEjMKBnNvdXJjZRgDIAEoDjIjLmZseXRlaWRsLmxvZ3MuZGF0YXBsYW5lLkxvZ3NTb3VyY2USEQoJbm9fZm9sbG93GAQgASgISgQIAhADIs0BCh1UYWlsVGFza0V4ZWN1dGlvbkxvZ3NSZXNwb25zZRJLCgRsb2dzGAEgASgLMjsuZmx5dGVpZGwubG9ncy5kYXRhcGxhbmUuVGFpbFRhc2tFeGVjdXRpb25Mb2dzUmVzcG9uc2UuTG9nc0gAGlUKBExvZ3MSEQoFbGluZXMYASADKAlCAhgBEjoKEHN0cnVjdHVyZWRfbGluZXMYAiADKAsyIC5mbHl0ZWlkbC5sb2dzLmRhdGFwbGFuZS5Mb2dMaW5lQggKBnJlc3VsdCLTAwoOTG9nZ2luZ0NvbnRleHQSHQoMY2x1c3Rlcl9uYW1lGAMgASgJQgf6QgRyAhABEiUKFGt1YmVybmV0ZXNfbmFtZXNwYWNlGAQgASgJQgf6QgRyAhABEiQKE2t1YmVybmV0ZXNfcG9kX25hbWUYBSABKAlCB/pCBHICEAESKgoZa3ViZXJuZXRlc19jb250YWluZXJfbmFtZRgGIAEoCUIH+kIEcgIQARJAChxleGVjdXRpb25fYXR0ZW1wdF9zdGFydF90aW1lGAcgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBI+ChpleGVjdXRpb25fYXR0ZW1wdF9lbmRfdGltZRgIIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASXwoVa3ViZXJuZXRlc19wb2RfbGFiZWxzGAkgAygLMkAuZmx5dGVpZGwubG9ncy5kYXRhcGxhbmUuTG9nZ2luZ0NvbnRleHQuS3ViZXJuZXRlc1BvZExhYmVsc0VudHJ5GjoKGEt1YmVybmV0ZXNQb2RMYWJlbHNFbnRyeRILCgNrZXkYASABKAkSDQoFdmFsdWUYAiABKAk6AjgBSgQIARACSgQIAhADIqQBChNDb250YWluZXJJZGVudGlmaWVyEh0KDGNsdXN0ZXJfbmFtZRgBIAEoCUIH+kIEcgIQARIlChRrdWJlcm5ldGVzX25hbWVzcGFjZRgCIAEoCUIH+kIEcgIQARIkChNrdWJlcm5ldGVzX3BvZF9uYW1lGAMgASgJQgf6QgRyAhABEiEKGWt1YmVybmV0ZXNfY29udGFpbmVyX25hbWUYBCABKAkixwEKEUNvbnRhaW5lclNlbGVjdG9yEh0KDGNsdXN0ZXJfbmFtZRgBIAEoCUIH+kIEcgIQARIlChRrdWJlcm5ldGVzX25hbWVzcGFjZRgCIAEoCUIH+kIEcgIQARIiChprdWJlcm5ldGVzX3BvZF9uYW1lX3ByZWZpeBgDIAEoCRIhChlrdWJlcm5ldGVzX2NvbnRhaW5lcl9uYW1lGAQgASgJEiUKHWt1YmVybmV0ZXNfcG9kX2xhYmVsX3NlbGVjdG9yGAUgASgJIkEKD0xpdmVMb2dzT3B0aW9ucxIWCg5sb2dfcG9kX3N0YXR1cxgBIAEoCBIWCg5sb2dfdGltZXN0YW1wcxgCIAEoCCKKAwoPVGFpbExvZ3NSZXF1ZXN0EkEKCWNvbnRhaW5lchgBIAEoCzIsLmZseXRlaWRsLmxvZ3MuZGF0YXBsYW5lLkNvbnRhaW5lcklkZW50aWZpZXJIABJIChJjb250YWluZXJfc2VsZWN0b3IYAiABKAsyKi5mbHl0ZWlkbC5sb2dzLmRhdGFwbGFuZS5Db250YWluZXJTZWxlY3RvckgAEjgKCnN0YXJ0X3RpbWUYAyABKAsyGi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wQgj6QgWyAQIIARIsCghlbmRfdGltZRgEIAEoCzIaLmdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXASMwoGc291cmNlGAUgASgOMiMuZmx5dGVpZGwubG9ncy5kYXRhcGxhbmUuTG9nc1NvdXJjZRJDChFsaXZlX2xvZ3Nfb3B0aW9ucxgGIAEoCzIoLmZseXRlaWRsLmxvZ3MuZGF0YXBsYW5lLkxpdmVMb2dzT3B0aW9uc0IICgZ0YXJnZXQiiQEKB0xvZ0xpbmUSLQoJdGltZXN0YW1wGAEgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBIPCgdtZXNzYWdlGAIgASgJEj4KCm9yaWdpbmF0b3IYAyABKA4yKi5mbHl0ZWlkbC5sb2dzLmRhdGFwbGFuZS5Mb2dMaW5lT3JpZ2luYXRvciK9AQoITG9nTGluZXMSEQoFbGluZXMYASADKAlCAhgBEhcKD2NvbnRhaW5lcl9pbmRleBgCIAEoDRJJCgljb250YWluZXIYAyABKAsyLC5mbHl0ZWlkbC5sb2dzLmRhdGFwbGFuZS5Db250YWluZXJJZGVudGlmaWVyQgj6QgWKAQIQARI6ChBzdHJ1Y3R1cmVkX2xpbmVzGAQgAygLMiAuZmx5dGVpZGwubG9ncy5kYXRhcGxhbmUuTG9nTGluZSJVChFMb2dDb250YWluZXJzTGlzdBJACgpjb250YWluZXJzGAEgAygLMiwuZmx5dGVpZGwubG9ncy5kYXRhcGxhbmUuQ29udGFpbmVySWRlbnRpZmllciJACg1Mb2dMaW5lc0JhdGNoEi8KBGxvZ3MYASADKAsyIS5mbHl0ZWlkbC5sb2dzLmRhdGFwbGFuZS5Mb2dMaW5lcyK+AQoQVGFpbExvZ3NSZXNwb25zZRJKCgpjb250YWluZXJzGAEgASgLMiouZmx5dGVpZGwubG9ncy5kYXRhcGxhbmUuTG9nQ29udGFpbmVyc0xpc3RCCPpCBYoBAhABSAASSwoPbG9nX2xpbmVzX2JhdGNoGAMgASgLMiYuZmx5dGVpZGwubG9ncy5kYXRhcGxhbmUuTG9nTGluZXNCYXRjaEII+kIFigECEAFIAEILCgRyZXNwEgP4QgFKBAgCEAMqNgoRTG9nTGluZU9yaWdpbmF0b3ISCwoHVU5LTk9XThAAEggKBFVTRVIQARIKCgZTWVNURU0QAipGCgpMb2dzU291cmNlEhUKEUxJVkVfT1JfUEVSU0lTVEVEEAASDQoJTElWRV9PTkxZEAESEgoOUEVSU0lTVEVEX09OTFkQAkLcAQobY29tLmZseXRlaWRsLmxvZ3MuZGF0YXBsYW5lQgxQYXlsb2FkUHJvdG9IAlABWi9naXRodWIuY29tL2ZseXRlb3JnL2ZseXRlL2dlbi9nby9sb2dzL2RhdGFwbGFuZaICA0ZMRKoCF0ZseXRlaWRsLkxvZ3MuRGF0YXBsYW5lygIXRmx5dGVpZGxcTG9nc1xEYXRhcGxhbmXiAiNGbHl0ZWlkbFxMb2dzXERhdGFwbGFuZVxHUEJNZXRhZGF0YeoCGUZseXRlaWRsOjpMb2dzOjpEYXRhcGxhbmViBnByb3RvMw", [file_google_protobuf_timestamp, file_validate_validate]);

/**
 * @generated from message flyteidl.logs.dataplane.PodResource
 */
export type PodResource = Message<"flyteidl.logs.dataplane.PodResource"> & {
  /**
   * The namespace of the pod.
   *
   * @generated from field: string namespace = 1;
   */
  namespace: string;

  /**
   * The pod name.
   *
   * @generated from field: string name = 2;
   */
  name: string;

  /**
   * The container name. If not provided, attempt to find the primary container, else assume the first container.
   * +optional
   *
   * @generated from field: string container = 3;
   */
  container: string;
};

/**
 * Describes the message flyteidl.logs.dataplane.PodResource.
 * Use `create(PodResourceSchema)` to create a new message.
 */
export const PodResourceSchema: GenMessage<PodResource> = /*@__PURE__*/
  messageDesc(file_logs_dataplane_payload, 0);

/**
 * @generated from message flyteidl.logs.dataplane.TailTaskExecutionLogsRequest
 */
export type TailTaskExecutionLogsRequest = Message<"flyteidl.logs.dataplane.TailTaskExecutionLogsRequest"> & {
  /**
   * @generated from field: flyteidl.logs.dataplane.LoggingContext logging_context = 1;
   */
  loggingContext?: LoggingContext;

  /**
   * +optional, used in api-tests
   *
   * @generated from field: flyteidl.logs.dataplane.LogsSource source = 3;
   */
  source: LogsSource;

  /**
   * +optional, used in api-tests
   *
   * This will be extended in the future:
   * see https://unionai.atlassian.net/wiki/spaces/ENG/pages/922583046/Persisted+Logs
   *
   * @generated from field: bool no_follow = 4;
   */
  noFollow: boolean;
};

/**
 * Describes the message flyteidl.logs.dataplane.TailTaskExecutionLogsRequest.
 * Use `create(TailTaskExecutionLogsRequestSchema)` to create a new message.
 */
export const TailTaskExecutionLogsRequestSchema: GenMessage<TailTaskExecutionLogsRequest> = /*@__PURE__*/
  messageDesc(file_logs_dataplane_payload, 1);

/**
 * @generated from message flyteidl.logs.dataplane.TailTaskExecutionLogsResponse
 */
export type TailTaskExecutionLogsResponse = Message<"flyteidl.logs.dataplane.TailTaskExecutionLogsResponse"> & {
  /**
   * @generated from oneof flyteidl.logs.dataplane.TailTaskExecutionLogsResponse.result
   */
  result: {
    /**
     * @generated from field: flyteidl.logs.dataplane.TailTaskExecutionLogsResponse.Logs logs = 1;
     */
    value: TailTaskExecutionLogsResponse_Logs;
    case: "logs";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message flyteidl.logs.dataplane.TailTaskExecutionLogsResponse.
 * Use `create(TailTaskExecutionLogsResponseSchema)` to create a new message.
 */
export const TailTaskExecutionLogsResponseSchema: GenMessage<TailTaskExecutionLogsResponse> = /*@__PURE__*/
  messageDesc(file_logs_dataplane_payload, 2);

/**
 * @generated from message flyteidl.logs.dataplane.TailTaskExecutionLogsResponse.Logs
 */
export type TailTaskExecutionLogsResponse_Logs = Message<"flyteidl.logs.dataplane.TailTaskExecutionLogsResponse.Logs"> & {
  /**
   * Each line is separated by either CRLF, CR or LF, which are included
   * at the ends of the lines. This lets clients know whether log emitter
   * wanted to overwrite the previous line (LF) or append a new line (CRLF).
   *
   * @generated from field: repeated string lines = 1 [deprecated = true];
   * @deprecated
   */
  lines: string[];

  /**
   * Each line is separated by either CRLF, CR or LF, which are included
   * at the ends of the lines. This lets clients know whether log emitter
   * wanted to overwrite the previous line (LF) or append a new line (CRLF).
   *
   * @generated from field: repeated flyteidl.logs.dataplane.LogLine structured_lines = 2;
   */
  structuredLines: LogLine[];
};

/**
 * Describes the message flyteidl.logs.dataplane.TailTaskExecutionLogsResponse.Logs.
 * Use `create(TailTaskExecutionLogsResponse_LogsSchema)` to create a new message.
 */
export const TailTaskExecutionLogsResponse_LogsSchema: GenMessage<TailTaskExecutionLogsResponse_Logs> = /*@__PURE__*/
  messageDesc(file_logs_dataplane_payload, 2, 0);

/**
 * Parameters of environment in which logs were collected. Should contain everything
 * necessary to identify location of task execution logs in cloud providers.
 *
 * @generated from message flyteidl.logs.dataplane.LoggingContext
 */
export type LoggingContext = Message<"flyteidl.logs.dataplane.LoggingContext"> & {
  /**
   * @generated from field: string cluster_name = 3;
   */
  clusterName: string;

  /**
   * @generated from field: string kubernetes_namespace = 4;
   */
  kubernetesNamespace: string;

  /**
   * @generated from field: string kubernetes_pod_name = 5;
   */
  kubernetesPodName: string;

  /**
   * @generated from field: string kubernetes_container_name = 6;
   */
  kubernetesContainerName: string;

  /**
   * @generated from field: google.protobuf.Timestamp execution_attempt_start_time = 7;
   */
  executionAttemptStartTime?: Timestamp;

  /**
   * @generated from field: google.protobuf.Timestamp execution_attempt_end_time = 8;
   */
  executionAttemptEndTime?: Timestamp;

  /**
   * @generated from field: map<string, string> kubernetes_pod_labels = 9;
   */
  kubernetesPodLabels: { [key: string]: string };
};

/**
 * Describes the message flyteidl.logs.dataplane.LoggingContext.
 * Use `create(LoggingContextSchema)` to create a new message.
 */
export const LoggingContextSchema: GenMessage<LoggingContext> = /*@__PURE__*/
  messageDesc(file_logs_dataplane_payload, 3);

/**
 * Parameters of environment in which logs were collected. Should contain everything
 * necessary to identify location of task execution logs in cloud providers.
 *
 * @generated from message flyteidl.logs.dataplane.ContainerIdentifier
 */
export type ContainerIdentifier = Message<"flyteidl.logs.dataplane.ContainerIdentifier"> & {
  /**
   * The name of the cluster.
   *
   * @generated from field: string cluster_name = 1;
   */
  clusterName: string;

  /**
   * The namespace in Kubernetes.
   *
   * @generated from field: string kubernetes_namespace = 2;
   */
  kubernetesNamespace: string;

  /**
   * The name of the pod in Kubernetes.
   *
   * @generated from field: string kubernetes_pod_name = 3;
   */
  kubernetesPodName: string;

  /**
   * The name of the container in Kubernetes.
   *
   * @generated from field: string kubernetes_container_name = 4;
   */
  kubernetesContainerName: string;
};

/**
 * Describes the message flyteidl.logs.dataplane.ContainerIdentifier.
 * Use `create(ContainerIdentifierSchema)` to create a new message.
 */
export const ContainerIdentifierSchema: GenMessage<ContainerIdentifier> = /*@__PURE__*/
  messageDesc(file_logs_dataplane_payload, 4);

/**
 * @generated from message flyteidl.logs.dataplane.ContainerSelector
 */
export type ContainerSelector = Message<"flyteidl.logs.dataplane.ContainerSelector"> & {
  /**
   * The name of the cluster.
   *
   * @generated from field: string cluster_name = 1;
   */
  clusterName: string;

  /**
   * The namespace in Kubernetes.
   *
   * @generated from field: string kubernetes_namespace = 2;
   */
  kubernetesNamespace: string;

  /**
   * The prefix of the name of the pod in Kubernetes. This will only apply to persisted pods' logs because listing by
   * prefix is the supported way to filter pods.
   *
   * @generated from field: string kubernetes_pod_name_prefix = 3;
   */
  kubernetesPodNamePrefix: string;

  /**
   * The name of the container in Kubernetes. If not specified, logs for all containers
   * will be streamed.
   *
   * @generated from field: string kubernetes_container_name = 4;
   */
  kubernetesContainerName: string;

  /**
   * The label selector to filter pods. This will only apply to live pods' logs because Listing by prefix
   * isn't supported.
   *
   * @generated from field: string kubernetes_pod_label_selector = 5;
   */
  kubernetesPodLabelSelector: string;
};

/**
 * Describes the message flyteidl.logs.dataplane.ContainerSelector.
 * Use `create(ContainerSelectorSchema)` to create a new message.
 */
export const ContainerSelectorSchema: GenMessage<ContainerSelector> = /*@__PURE__*/
  messageDesc(file_logs_dataplane_payload, 5);

/**
 * @generated from message flyteidl.logs.dataplane.LiveLogsOptions
 */
export type LiveLogsOptions = Message<"flyteidl.logs.dataplane.LiveLogsOptions"> & {
  /**
   * LogPodStatus indicates whether to log the pod status along with the logs.
   *
   * @generated from field: bool log_pod_status = 1;
   */
  logPodStatus: boolean;

  /**
   * LogTimestamps indicates whether to log the timestamps along with the logs. It prepends RFC3339 or RFC3339Nano
   * format in the beginning of each log line.
   *
   * @generated from field: bool log_timestamps = 2;
   */
  logTimestamps: boolean;
};

/**
 * Describes the message flyteidl.logs.dataplane.LiveLogsOptions.
 * Use `create(LiveLogsOptionsSchema)` to create a new message.
 */
export const LiveLogsOptionsSchema: GenMessage<LiveLogsOptions> = /*@__PURE__*/
  messageDesc(file_logs_dataplane_payload, 6);

/**
 * @generated from message flyteidl.logs.dataplane.TailLogsRequest
 */
export type TailLogsRequest = Message<"flyteidl.logs.dataplane.TailLogsRequest"> & {
  /**
   * @generated from oneof flyteidl.logs.dataplane.TailLogsRequest.target
   */
  target: {
    /**
     * Container identifier.
     *
     * @generated from field: flyteidl.logs.dataplane.ContainerIdentifier container = 1;
     */
    value: ContainerIdentifier;
    case: "container";
  } | {
    /**
     * Container selector to collect logs from multiple pods/containers.
     *
     * @generated from field: flyteidl.logs.dataplane.ContainerSelector container_selector = 2;
     */
    value: ContainerSelector;
    case: "containerSelector";
  } | { case: undefined; value?: undefined };

  /**
   * StartTime defines the earliest time at which logs should be retrieved.
   *
   * @generated from field: google.protobuf.Timestamp start_time = 3;
   */
  startTime?: Timestamp;

  /**
   * EndTime defines the latest time at which logs should be retrieved. If left empty, it'll stream indefinitely for live
   * pods and Now() will be used for persisted logs.
   *
   * @generated from field: google.protobuf.Timestamp end_time = 4;
   */
  endTime?: Timestamp;

  /**
   * +optional
   *
   * @generated from field: flyteidl.logs.dataplane.LogsSource source = 5;
   */
  source: LogsSource;

  /**
   * +optional
   *
   * @generated from field: flyteidl.logs.dataplane.LiveLogsOptions live_logs_options = 6;
   */
  liveLogsOptions?: LiveLogsOptions;
};

/**
 * Describes the message flyteidl.logs.dataplane.TailLogsRequest.
 * Use `create(TailLogsRequestSchema)` to create a new message.
 */
export const TailLogsRequestSchema: GenMessage<TailLogsRequest> = /*@__PURE__*/
  messageDesc(file_logs_dataplane_payload, 7);

/**
 * @generated from message flyteidl.logs.dataplane.LogLine
 */
export type LogLine = Message<"flyteidl.logs.dataplane.LogLine"> & {
  /**
   * @generated from field: google.protobuf.Timestamp timestamp = 1;
   */
  timestamp?: Timestamp;

  /**
   * Each line is separated by either CRLF, CR or LF, which are included
   * at the ends of the lines. This lets clients know whether log emitter
   * wanted to overwrite the previous line (LF) or append a new line (CRLF).
   *
   * @generated from field: string message = 2;
   */
  message: string;

  /**
   * @generated from field: flyteidl.logs.dataplane.LogLineOriginator originator = 3;
   */
  originator: LogLineOriginator;
};

/**
 * Describes the message flyteidl.logs.dataplane.LogLine.
 * Use `create(LogLineSchema)` to create a new message.
 */
export const LogLineSchema: GenMessage<LogLine> = /*@__PURE__*/
  messageDesc(file_logs_dataplane_payload, 8);

/**
 * @generated from message flyteidl.logs.dataplane.LogLines
 */
export type LogLines = Message<"flyteidl.logs.dataplane.LogLines"> & {
  /**
   * Each line is separated by either CRLF, CR or LF, which are included
   * at the ends of the lines. This lets clients know whether log emitter
   * wanted to overwrite the previous line (LF) or append a new line (CRLF).
   *
   * @generated from field: repeated string lines = 1 [deprecated = true];
   * @deprecated
   */
  lines: string[];

  /**
   * The index of the container in the list of containers. If the request was made with a single container identifier,
   * this value will always be 0. Otherwise, it'll be an index into the last list of containers sent in the stream.
   *
   * @generated from field: uint32 container_index = 2;
   */
  containerIndex: number;

  /**
   * The container identifier.
   *
   * @generated from field: flyteidl.logs.dataplane.ContainerIdentifier container = 3;
   */
  container?: ContainerIdentifier;

  /**
   * Each line is separated by either CRLF, CR or LF, which are included
   * at the ends of the lines. This lets clients know whether log emitter
   * wanted to overwrite the previous line (LF) or append a new line (CRLF).
   *
   * @generated from field: repeated flyteidl.logs.dataplane.LogLine structured_lines = 4;
   */
  structuredLines: LogLine[];
};

/**
 * Describes the message flyteidl.logs.dataplane.LogLines.
 * Use `create(LogLinesSchema)` to create a new message.
 */
export const LogLinesSchema: GenMessage<LogLines> = /*@__PURE__*/
  messageDesc(file_logs_dataplane_payload, 9);

/**
 * @generated from message flyteidl.logs.dataplane.LogContainersList
 */
export type LogContainersList = Message<"flyteidl.logs.dataplane.LogContainersList"> & {
  /**
   * @generated from field: repeated flyteidl.logs.dataplane.ContainerIdentifier containers = 1;
   */
  containers: ContainerIdentifier[];
};

/**
 * Describes the message flyteidl.logs.dataplane.LogContainersList.
 * Use `create(LogContainersListSchema)` to create a new message.
 */
export const LogContainersListSchema: GenMessage<LogContainersList> = /*@__PURE__*/
  messageDesc(file_logs_dataplane_payload, 10);

/**
 * @generated from message flyteidl.logs.dataplane.LogLinesBatch
 */
export type LogLinesBatch = Message<"flyteidl.logs.dataplane.LogLinesBatch"> & {
  /**
   * @generated from field: repeated flyteidl.logs.dataplane.LogLines logs = 1;
   */
  logs: LogLines[];
};

/**
 * Describes the message flyteidl.logs.dataplane.LogLinesBatch.
 * Use `create(LogLinesBatchSchema)` to create a new message.
 */
export const LogLinesBatchSchema: GenMessage<LogLinesBatch> = /*@__PURE__*/
  messageDesc(file_logs_dataplane_payload, 11);

/**
 * @generated from message flyteidl.logs.dataplane.TailLogsResponse
 */
export type TailLogsResponse = Message<"flyteidl.logs.dataplane.TailLogsResponse"> & {
  /**
   * @generated from oneof flyteidl.logs.dataplane.TailLogsResponse.resp
   */
  resp: {
    /**
     * Containers lists the containers that the logs are being tailed for. This is expected to be the first
     * message to be sent in the stream but also can be sent at any later time to update the list of
     * containers being tailed.
     *
     * @generated from field: flyteidl.logs.dataplane.LogContainersList containers = 1;
     */
    value: LogContainersList;
    case: "containers";
  } | {
    /**
     * The latest log lines for the application.
     *
     * @generated from field: flyteidl.logs.dataplane.LogLinesBatch log_lines_batch = 3;
     */
    value: LogLinesBatch;
    case: "logLinesBatch";
  } | { case: undefined; value?: undefined };
};

/**
 * Describes the message flyteidl.logs.dataplane.TailLogsResponse.
 * Use `create(TailLogsResponseSchema)` to create a new message.
 */
export const TailLogsResponseSchema: GenMessage<TailLogsResponse> = /*@__PURE__*/
  messageDesc(file_logs_dataplane_payload, 12);

/**
 * @generated from enum flyteidl.logs.dataplane.LogLineOriginator
 */
export enum LogLineOriginator {
  /**
   * The originator of the log line is unknown.
   *
   * @generated from enum value: UNKNOWN = 0;
   */
  UNKNOWN = 0,

  /**
   * The originator of the log line is the user application.
   *
   * @generated from enum value: USER = 1;
   */
  USER = 1,

  /**
   * The originator of the log line is the system.
   *
   * @generated from enum value: SYSTEM = 2;
   */
  SYSTEM = 2,
}

/**
 * Describes the enum flyteidl.logs.dataplane.LogLineOriginator.
 */
export const LogLineOriginatorSchema: GenEnum<LogLineOriginator> = /*@__PURE__*/
  enumDesc(file_logs_dataplane_payload, 0);

/**
 * @generated from enum flyteidl.logs.dataplane.LogsSource
 */
export enum LogsSource {
  /**
   * Return live logs and fall back to persisted if not available.
   *
   * @generated from enum value: LIVE_OR_PERSISTED = 0;
   */
  LIVE_OR_PERSISTED = 0,

  /**
   * Return live logs only or error if pod is no longer around.
   *
   * @generated from enum value: LIVE_ONLY = 1;
   */
  LIVE_ONLY = 1,

  /**
   * Return persisted logs only.
   *
   * @generated from enum value: PERSISTED_ONLY = 2;
   */
  PERSISTED_ONLY = 2,
}

/**
 * Describes the enum flyteidl.logs.dataplane.LogsSource.
 */
export const LogsSourceSchema: GenEnum<LogsSource> = /*@__PURE__*/
  enumDesc(file_logs_dataplane_payload, 1);

