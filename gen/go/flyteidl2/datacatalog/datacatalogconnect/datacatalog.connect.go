// Code generated by protoc-gen-connect-go. DO NOT EDIT.
//
// Source: flyteidl2/datacatalog/datacatalog.proto

package datacatalogconnect

import (
	connect "connectrpc.com/connect"
	context "context"
	errors "errors"
	datacatalog "github.com/flyteorg/flyte/v2/gen/go/flyteidl2/datacatalog"
	http "net/http"
	strings "strings"
)

// This is a compile-time assertion to ensure that this generated file and the connect package are
// compatible. If you get a compiler error that this constant is not defined, this code was
// generated with a version of connect newer than the one compiled into your binary. You can fix the
// problem by either regenerating this code with an older version of connect or updating the connect
// version compiled into your binary.
const _ = connect.IsAtLeastVersion1_13_0

const (
	// DataCatalogName is the fully-qualified name of the DataCatalog service.
	DataCatalogName = "flyteidl2.datacatalog.DataCatalog"
)

// These constants are the fully-qualified names of the RPCs defined in this package. They're
// exposed at runtime as Spec.Procedure and as the final two segments of the HTTP route.
//
// Note that these are different from the fully-qualified method names used by
// google.golang.org/protobuf/reflect/protoreflect. To convert from these constants to
// reflection-formatted method names, remove the leading slash and convert the remaining slash to a
// period.
const (
	// DataCatalogCreateDatasetProcedure is the fully-qualified name of the DataCatalog's CreateDataset
	// RPC.
	DataCatalogCreateDatasetProcedure = "/flyteidl2.datacatalog.DataCatalog/CreateDataset"
	// DataCatalogGetDatasetProcedure is the fully-qualified name of the DataCatalog's GetDataset RPC.
	DataCatalogGetDatasetProcedure = "/flyteidl2.datacatalog.DataCatalog/GetDataset"
	// DataCatalogCreateArtifactProcedure is the fully-qualified name of the DataCatalog's
	// CreateArtifact RPC.
	DataCatalogCreateArtifactProcedure = "/flyteidl2.datacatalog.DataCatalog/CreateArtifact"
	// DataCatalogGetArtifactProcedure is the fully-qualified name of the DataCatalog's GetArtifact RPC.
	DataCatalogGetArtifactProcedure = "/flyteidl2.datacatalog.DataCatalog/GetArtifact"
	// DataCatalogAddTagProcedure is the fully-qualified name of the DataCatalog's AddTag RPC.
	DataCatalogAddTagProcedure = "/flyteidl2.datacatalog.DataCatalog/AddTag"
	// DataCatalogListArtifactsProcedure is the fully-qualified name of the DataCatalog's ListArtifacts
	// RPC.
	DataCatalogListArtifactsProcedure = "/flyteidl2.datacatalog.DataCatalog/ListArtifacts"
	// DataCatalogListDatasetsProcedure is the fully-qualified name of the DataCatalog's ListDatasets
	// RPC.
	DataCatalogListDatasetsProcedure = "/flyteidl2.datacatalog.DataCatalog/ListDatasets"
	// DataCatalogUpdateArtifactProcedure is the fully-qualified name of the DataCatalog's
	// UpdateArtifact RPC.
	DataCatalogUpdateArtifactProcedure = "/flyteidl2.datacatalog.DataCatalog/UpdateArtifact"
	// DataCatalogGetOrExtendReservationProcedure is the fully-qualified name of the DataCatalog's
	// GetOrExtendReservation RPC.
	DataCatalogGetOrExtendReservationProcedure = "/flyteidl2.datacatalog.DataCatalog/GetOrExtendReservation"
	// DataCatalogReleaseReservationProcedure is the fully-qualified name of the DataCatalog's
	// ReleaseReservation RPC.
	DataCatalogReleaseReservationProcedure = "/flyteidl2.datacatalog.DataCatalog/ReleaseReservation"
)

// These variables are the protoreflect.Descriptor objects for the RPCs defined in this package.
var (
	dataCatalogServiceDescriptor                      = datacatalog.File_flyteidl2_datacatalog_datacatalog_proto.Services().ByName("DataCatalog")
	dataCatalogCreateDatasetMethodDescriptor          = dataCatalogServiceDescriptor.Methods().ByName("CreateDataset")
	dataCatalogGetDatasetMethodDescriptor             = dataCatalogServiceDescriptor.Methods().ByName("GetDataset")
	dataCatalogCreateArtifactMethodDescriptor         = dataCatalogServiceDescriptor.Methods().ByName("CreateArtifact")
	dataCatalogGetArtifactMethodDescriptor            = dataCatalogServiceDescriptor.Methods().ByName("GetArtifact")
	dataCatalogAddTagMethodDescriptor                 = dataCatalogServiceDescriptor.Methods().ByName("AddTag")
	dataCatalogListArtifactsMethodDescriptor          = dataCatalogServiceDescriptor.Methods().ByName("ListArtifacts")
	dataCatalogListDatasetsMethodDescriptor           = dataCatalogServiceDescriptor.Methods().ByName("ListDatasets")
	dataCatalogUpdateArtifactMethodDescriptor         = dataCatalogServiceDescriptor.Methods().ByName("UpdateArtifact")
	dataCatalogGetOrExtendReservationMethodDescriptor = dataCatalogServiceDescriptor.Methods().ByName("GetOrExtendReservation")
	dataCatalogReleaseReservationMethodDescriptor     = dataCatalogServiceDescriptor.Methods().ByName("ReleaseReservation")
)

// DataCatalogClient is a client for the flyteidl2.datacatalog.DataCatalog service.
type DataCatalogClient interface {
	// Create a new Dataset. Datasets are unique based on the DatasetID. Datasets are logical groupings of artifacts.
	// Each dataset can have one or more artifacts
	CreateDataset(context.Context, *connect.Request[datacatalog.CreateDatasetRequest]) (*connect.Response[datacatalog.CreateDatasetResponse], error)
	// Get a Dataset by the DatasetID. This returns the Dataset with the associated metadata.
	GetDataset(context.Context, *connect.Request[datacatalog.GetDatasetRequest]) (*connect.Response[datacatalog.GetDatasetResponse], error)
	// Create an artifact and the artifact data associated with it. An artifact can be a hive partition or arbitrary
	// files or data values
	CreateArtifact(context.Context, *connect.Request[datacatalog.CreateArtifactRequest]) (*connect.Response[datacatalog.CreateArtifactResponse], error)
	// Retrieve an artifact by an identifying handle. This returns an artifact along with the artifact data.
	GetArtifact(context.Context, *connect.Request[datacatalog.GetArtifactRequest]) (*connect.Response[datacatalog.GetArtifactResponse], error)
	// Associate a tag with an artifact. Tags are unique within a Dataset.
	AddTag(context.Context, *connect.Request[datacatalog.AddTagRequest]) (*connect.Response[datacatalog.AddTagResponse], error)
	// Return a paginated list of artifacts
	ListArtifacts(context.Context, *connect.Request[datacatalog.ListArtifactsRequest]) (*connect.Response[datacatalog.ListArtifactsResponse], error)
	// Return a paginated list of datasets
	ListDatasets(context.Context, *connect.Request[datacatalog.ListDatasetsRequest]) (*connect.Response[datacatalog.ListDatasetsResponse], error)
	// Updates an existing artifact, overwriting the stored artifact data in the underlying blob storage.
	UpdateArtifact(context.Context, *connect.Request[datacatalog.UpdateArtifactRequest]) (*connect.Response[datacatalog.UpdateArtifactResponse], error)
	// Attempts to get or extend a reservation for the corresponding artifact. If one already exists
	// (ie. another entity owns the reservation) then that reservation is retrieved.
	// Once you acquire a reservation, you need to  periodically extend the reservation with an
	// identical call. If the reservation is not extended before the defined expiration, it may be
	// acquired by another task.
	// Note: We may have multiple concurrent tasks with the same signature and the same input that
	// try to populate the same artifact at the same time. Thus with reservation, only one task can
	// run at a time, until the reservation expires.
	// Note: If task A does not extend the reservation in time and the reservation expires, another
	// task B may take over the reservation, resulting in two tasks A and B running in parallel. So
	// a third task C may get the Artifact from A or B, whichever writes last.
	GetOrExtendReservation(context.Context, *connect.Request[datacatalog.GetOrExtendReservationRequest]) (*connect.Response[datacatalog.GetOrExtendReservationResponse], error)
	// Release the reservation when the task holding the spot fails so that the other tasks
	// can grab the spot.
	ReleaseReservation(context.Context, *connect.Request[datacatalog.ReleaseReservationRequest]) (*connect.Response[datacatalog.ReleaseReservationResponse], error)
}

// NewDataCatalogClient constructs a client for the flyteidl2.datacatalog.DataCatalog service. By
// default, it uses the Connect protocol with the binary Protobuf Codec, asks for gzipped responses,
// and sends uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the
// connect.WithGRPC() or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewDataCatalogClient(httpClient connect.HTTPClient, baseURL string, opts ...connect.ClientOption) DataCatalogClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &dataCatalogClient{
		createDataset: connect.NewClient[datacatalog.CreateDatasetRequest, datacatalog.CreateDatasetResponse](
			httpClient,
			baseURL+DataCatalogCreateDatasetProcedure,
			connect.WithSchema(dataCatalogCreateDatasetMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		getDataset: connect.NewClient[datacatalog.GetDatasetRequest, datacatalog.GetDatasetResponse](
			httpClient,
			baseURL+DataCatalogGetDatasetProcedure,
			connect.WithSchema(dataCatalogGetDatasetMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		createArtifact: connect.NewClient[datacatalog.CreateArtifactRequest, datacatalog.CreateArtifactResponse](
			httpClient,
			baseURL+DataCatalogCreateArtifactProcedure,
			connect.WithSchema(dataCatalogCreateArtifactMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		getArtifact: connect.NewClient[datacatalog.GetArtifactRequest, datacatalog.GetArtifactResponse](
			httpClient,
			baseURL+DataCatalogGetArtifactProcedure,
			connect.WithSchema(dataCatalogGetArtifactMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		addTag: connect.NewClient[datacatalog.AddTagRequest, datacatalog.AddTagResponse](
			httpClient,
			baseURL+DataCatalogAddTagProcedure,
			connect.WithSchema(dataCatalogAddTagMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		listArtifacts: connect.NewClient[datacatalog.ListArtifactsRequest, datacatalog.ListArtifactsResponse](
			httpClient,
			baseURL+DataCatalogListArtifactsProcedure,
			connect.WithSchema(dataCatalogListArtifactsMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		listDatasets: connect.NewClient[datacatalog.ListDatasetsRequest, datacatalog.ListDatasetsResponse](
			httpClient,
			baseURL+DataCatalogListDatasetsProcedure,
			connect.WithSchema(dataCatalogListDatasetsMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		updateArtifact: connect.NewClient[datacatalog.UpdateArtifactRequest, datacatalog.UpdateArtifactResponse](
			httpClient,
			baseURL+DataCatalogUpdateArtifactProcedure,
			connect.WithSchema(dataCatalogUpdateArtifactMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		getOrExtendReservation: connect.NewClient[datacatalog.GetOrExtendReservationRequest, datacatalog.GetOrExtendReservationResponse](
			httpClient,
			baseURL+DataCatalogGetOrExtendReservationProcedure,
			connect.WithSchema(dataCatalogGetOrExtendReservationMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		releaseReservation: connect.NewClient[datacatalog.ReleaseReservationRequest, datacatalog.ReleaseReservationResponse](
			httpClient,
			baseURL+DataCatalogReleaseReservationProcedure,
			connect.WithSchema(dataCatalogReleaseReservationMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
	}
}

// dataCatalogClient implements DataCatalogClient.
type dataCatalogClient struct {
	createDataset          *connect.Client[datacatalog.CreateDatasetRequest, datacatalog.CreateDatasetResponse]
	getDataset             *connect.Client[datacatalog.GetDatasetRequest, datacatalog.GetDatasetResponse]
	createArtifact         *connect.Client[datacatalog.CreateArtifactRequest, datacatalog.CreateArtifactResponse]
	getArtifact            *connect.Client[datacatalog.GetArtifactRequest, datacatalog.GetArtifactResponse]
	addTag                 *connect.Client[datacatalog.AddTagRequest, datacatalog.AddTagResponse]
	listArtifacts          *connect.Client[datacatalog.ListArtifactsRequest, datacatalog.ListArtifactsResponse]
	listDatasets           *connect.Client[datacatalog.ListDatasetsRequest, datacatalog.ListDatasetsResponse]
	updateArtifact         *connect.Client[datacatalog.UpdateArtifactRequest, datacatalog.UpdateArtifactResponse]
	getOrExtendReservation *connect.Client[datacatalog.GetOrExtendReservationRequest, datacatalog.GetOrExtendReservationResponse]
	releaseReservation     *connect.Client[datacatalog.ReleaseReservationRequest, datacatalog.ReleaseReservationResponse]
}

// CreateDataset calls flyteidl2.datacatalog.DataCatalog.CreateDataset.
func (c *dataCatalogClient) CreateDataset(ctx context.Context, req *connect.Request[datacatalog.CreateDatasetRequest]) (*connect.Response[datacatalog.CreateDatasetResponse], error) {
	return c.createDataset.CallUnary(ctx, req)
}

// GetDataset calls flyteidl2.datacatalog.DataCatalog.GetDataset.
func (c *dataCatalogClient) GetDataset(ctx context.Context, req *connect.Request[datacatalog.GetDatasetRequest]) (*connect.Response[datacatalog.GetDatasetResponse], error) {
	return c.getDataset.CallUnary(ctx, req)
}

// CreateArtifact calls flyteidl2.datacatalog.DataCatalog.CreateArtifact.
func (c *dataCatalogClient) CreateArtifact(ctx context.Context, req *connect.Request[datacatalog.CreateArtifactRequest]) (*connect.Response[datacatalog.CreateArtifactResponse], error) {
	return c.createArtifact.CallUnary(ctx, req)
}

// GetArtifact calls flyteidl2.datacatalog.DataCatalog.GetArtifact.
func (c *dataCatalogClient) GetArtifact(ctx context.Context, req *connect.Request[datacatalog.GetArtifactRequest]) (*connect.Response[datacatalog.GetArtifactResponse], error) {
	return c.getArtifact.CallUnary(ctx, req)
}

// AddTag calls flyteidl2.datacatalog.DataCatalog.AddTag.
func (c *dataCatalogClient) AddTag(ctx context.Context, req *connect.Request[datacatalog.AddTagRequest]) (*connect.Response[datacatalog.AddTagResponse], error) {
	return c.addTag.CallUnary(ctx, req)
}

// ListArtifacts calls flyteidl2.datacatalog.DataCatalog.ListArtifacts.
func (c *dataCatalogClient) ListArtifacts(ctx context.Context, req *connect.Request[datacatalog.ListArtifactsRequest]) (*connect.Response[datacatalog.ListArtifactsResponse], error) {
	return c.listArtifacts.CallUnary(ctx, req)
}

// ListDatasets calls flyteidl2.datacatalog.DataCatalog.ListDatasets.
func (c *dataCatalogClient) ListDatasets(ctx context.Context, req *connect.Request[datacatalog.ListDatasetsRequest]) (*connect.Response[datacatalog.ListDatasetsResponse], error) {
	return c.listDatasets.CallUnary(ctx, req)
}

// UpdateArtifact calls flyteidl2.datacatalog.DataCatalog.UpdateArtifact.
func (c *dataCatalogClient) UpdateArtifact(ctx context.Context, req *connect.Request[datacatalog.UpdateArtifactRequest]) (*connect.Response[datacatalog.UpdateArtifactResponse], error) {
	return c.updateArtifact.CallUnary(ctx, req)
}

// GetOrExtendReservation calls flyteidl2.datacatalog.DataCatalog.GetOrExtendReservation.
func (c *dataCatalogClient) GetOrExtendReservation(ctx context.Context, req *connect.Request[datacatalog.GetOrExtendReservationRequest]) (*connect.Response[datacatalog.GetOrExtendReservationResponse], error) {
	return c.getOrExtendReservation.CallUnary(ctx, req)
}

// ReleaseReservation calls flyteidl2.datacatalog.DataCatalog.ReleaseReservation.
func (c *dataCatalogClient) ReleaseReservation(ctx context.Context, req *connect.Request[datacatalog.ReleaseReservationRequest]) (*connect.Response[datacatalog.ReleaseReservationResponse], error) {
	return c.releaseReservation.CallUnary(ctx, req)
}

// DataCatalogHandler is an implementation of the flyteidl2.datacatalog.DataCatalog service.
type DataCatalogHandler interface {
	// Create a new Dataset. Datasets are unique based on the DatasetID. Datasets are logical groupings of artifacts.
	// Each dataset can have one or more artifacts
	CreateDataset(context.Context, *connect.Request[datacatalog.CreateDatasetRequest]) (*connect.Response[datacatalog.CreateDatasetResponse], error)
	// Get a Dataset by the DatasetID. This returns the Dataset with the associated metadata.
	GetDataset(context.Context, *connect.Request[datacatalog.GetDatasetRequest]) (*connect.Response[datacatalog.GetDatasetResponse], error)
	// Create an artifact and the artifact data associated with it. An artifact can be a hive partition or arbitrary
	// files or data values
	CreateArtifact(context.Context, *connect.Request[datacatalog.CreateArtifactRequest]) (*connect.Response[datacatalog.CreateArtifactResponse], error)
	// Retrieve an artifact by an identifying handle. This returns an artifact along with the artifact data.
	GetArtifact(context.Context, *connect.Request[datacatalog.GetArtifactRequest]) (*connect.Response[datacatalog.GetArtifactResponse], error)
	// Associate a tag with an artifact. Tags are unique within a Dataset.
	AddTag(context.Context, *connect.Request[datacatalog.AddTagRequest]) (*connect.Response[datacatalog.AddTagResponse], error)
	// Return a paginated list of artifacts
	ListArtifacts(context.Context, *connect.Request[datacatalog.ListArtifactsRequest]) (*connect.Response[datacatalog.ListArtifactsResponse], error)
	// Return a paginated list of datasets
	ListDatasets(context.Context, *connect.Request[datacatalog.ListDatasetsRequest]) (*connect.Response[datacatalog.ListDatasetsResponse], error)
	// Updates an existing artifact, overwriting the stored artifact data in the underlying blob storage.
	UpdateArtifact(context.Context, *connect.Request[datacatalog.UpdateArtifactRequest]) (*connect.Response[datacatalog.UpdateArtifactResponse], error)
	// Attempts to get or extend a reservation for the corresponding artifact. If one already exists
	// (ie. another entity owns the reservation) then that reservation is retrieved.
	// Once you acquire a reservation, you need to  periodically extend the reservation with an
	// identical call. If the reservation is not extended before the defined expiration, it may be
	// acquired by another task.
	// Note: We may have multiple concurrent tasks with the same signature and the same input that
	// try to populate the same artifact at the same time. Thus with reservation, only one task can
	// run at a time, until the reservation expires.
	// Note: If task A does not extend the reservation in time and the reservation expires, another
	// task B may take over the reservation, resulting in two tasks A and B running in parallel. So
	// a third task C may get the Artifact from A or B, whichever writes last.
	GetOrExtendReservation(context.Context, *connect.Request[datacatalog.GetOrExtendReservationRequest]) (*connect.Response[datacatalog.GetOrExtendReservationResponse], error)
	// Release the reservation when the task holding the spot fails so that the other tasks
	// can grab the spot.
	ReleaseReservation(context.Context, *connect.Request[datacatalog.ReleaseReservationRequest]) (*connect.Response[datacatalog.ReleaseReservationResponse], error)
}

// NewDataCatalogHandler builds an HTTP handler from the service implementation. It returns the path
// on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewDataCatalogHandler(svc DataCatalogHandler, opts ...connect.HandlerOption) (string, http.Handler) {
	dataCatalogCreateDatasetHandler := connect.NewUnaryHandler(
		DataCatalogCreateDatasetProcedure,
		svc.CreateDataset,
		connect.WithSchema(dataCatalogCreateDatasetMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	dataCatalogGetDatasetHandler := connect.NewUnaryHandler(
		DataCatalogGetDatasetProcedure,
		svc.GetDataset,
		connect.WithSchema(dataCatalogGetDatasetMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	dataCatalogCreateArtifactHandler := connect.NewUnaryHandler(
		DataCatalogCreateArtifactProcedure,
		svc.CreateArtifact,
		connect.WithSchema(dataCatalogCreateArtifactMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	dataCatalogGetArtifactHandler := connect.NewUnaryHandler(
		DataCatalogGetArtifactProcedure,
		svc.GetArtifact,
		connect.WithSchema(dataCatalogGetArtifactMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	dataCatalogAddTagHandler := connect.NewUnaryHandler(
		DataCatalogAddTagProcedure,
		svc.AddTag,
		connect.WithSchema(dataCatalogAddTagMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	dataCatalogListArtifactsHandler := connect.NewUnaryHandler(
		DataCatalogListArtifactsProcedure,
		svc.ListArtifacts,
		connect.WithSchema(dataCatalogListArtifactsMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	dataCatalogListDatasetsHandler := connect.NewUnaryHandler(
		DataCatalogListDatasetsProcedure,
		svc.ListDatasets,
		connect.WithSchema(dataCatalogListDatasetsMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	dataCatalogUpdateArtifactHandler := connect.NewUnaryHandler(
		DataCatalogUpdateArtifactProcedure,
		svc.UpdateArtifact,
		connect.WithSchema(dataCatalogUpdateArtifactMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	dataCatalogGetOrExtendReservationHandler := connect.NewUnaryHandler(
		DataCatalogGetOrExtendReservationProcedure,
		svc.GetOrExtendReservation,
		connect.WithSchema(dataCatalogGetOrExtendReservationMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	dataCatalogReleaseReservationHandler := connect.NewUnaryHandler(
		DataCatalogReleaseReservationProcedure,
		svc.ReleaseReservation,
		connect.WithSchema(dataCatalogReleaseReservationMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	return "/flyteidl2.datacatalog.DataCatalog/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case DataCatalogCreateDatasetProcedure:
			dataCatalogCreateDatasetHandler.ServeHTTP(w, r)
		case DataCatalogGetDatasetProcedure:
			dataCatalogGetDatasetHandler.ServeHTTP(w, r)
		case DataCatalogCreateArtifactProcedure:
			dataCatalogCreateArtifactHandler.ServeHTTP(w, r)
		case DataCatalogGetArtifactProcedure:
			dataCatalogGetArtifactHandler.ServeHTTP(w, r)
		case DataCatalogAddTagProcedure:
			dataCatalogAddTagHandler.ServeHTTP(w, r)
		case DataCatalogListArtifactsProcedure:
			dataCatalogListArtifactsHandler.ServeHTTP(w, r)
		case DataCatalogListDatasetsProcedure:
			dataCatalogListDatasetsHandler.ServeHTTP(w, r)
		case DataCatalogUpdateArtifactProcedure:
			dataCatalogUpdateArtifactHandler.ServeHTTP(w, r)
		case DataCatalogGetOrExtendReservationProcedure:
			dataCatalogGetOrExtendReservationHandler.ServeHTTP(w, r)
		case DataCatalogReleaseReservationProcedure:
			dataCatalogReleaseReservationHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedDataCatalogHandler returns CodeUnimplemented from all methods.
type UnimplementedDataCatalogHandler struct{}

func (UnimplementedDataCatalogHandler) CreateDataset(context.Context, *connect.Request[datacatalog.CreateDatasetRequest]) (*connect.Response[datacatalog.CreateDatasetResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("flyteidl2.datacatalog.DataCatalog.CreateDataset is not implemented"))
}

func (UnimplementedDataCatalogHandler) GetDataset(context.Context, *connect.Request[datacatalog.GetDatasetRequest]) (*connect.Response[datacatalog.GetDatasetResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("flyteidl2.datacatalog.DataCatalog.GetDataset is not implemented"))
}

func (UnimplementedDataCatalogHandler) CreateArtifact(context.Context, *connect.Request[datacatalog.CreateArtifactRequest]) (*connect.Response[datacatalog.CreateArtifactResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("flyteidl2.datacatalog.DataCatalog.CreateArtifact is not implemented"))
}

func (UnimplementedDataCatalogHandler) GetArtifact(context.Context, *connect.Request[datacatalog.GetArtifactRequest]) (*connect.Response[datacatalog.GetArtifactResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("flyteidl2.datacatalog.DataCatalog.GetArtifact is not implemented"))
}

func (UnimplementedDataCatalogHandler) AddTag(context.Context, *connect.Request[datacatalog.AddTagRequest]) (*connect.Response[datacatalog.AddTagResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("flyteidl2.datacatalog.DataCatalog.AddTag is not implemented"))
}

func (UnimplementedDataCatalogHandler) ListArtifacts(context.Context, *connect.Request[datacatalog.ListArtifactsRequest]) (*connect.Response[datacatalog.ListArtifactsResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("flyteidl2.datacatalog.DataCatalog.ListArtifacts is not implemented"))
}

func (UnimplementedDataCatalogHandler) ListDatasets(context.Context, *connect.Request[datacatalog.ListDatasetsRequest]) (*connect.Response[datacatalog.ListDatasetsResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("flyteidl2.datacatalog.DataCatalog.ListDatasets is not implemented"))
}

func (UnimplementedDataCatalogHandler) UpdateArtifact(context.Context, *connect.Request[datacatalog.UpdateArtifactRequest]) (*connect.Response[datacatalog.UpdateArtifactResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("flyteidl2.datacatalog.DataCatalog.UpdateArtifact is not implemented"))
}

func (UnimplementedDataCatalogHandler) GetOrExtendReservation(context.Context, *connect.Request[datacatalog.GetOrExtendReservationRequest]) (*connect.Response[datacatalog.GetOrExtendReservationResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("flyteidl2.datacatalog.DataCatalog.GetOrExtendReservation is not implemented"))
}

func (UnimplementedDataCatalogHandler) ReleaseReservation(context.Context, *connect.Request[datacatalog.ReleaseReservationRequest]) (*connect.Response[datacatalog.ReleaseReservationResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("flyteidl2.datacatalog.DataCatalog.ReleaseReservation is not implemented"))
}
