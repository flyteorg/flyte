// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: flyteidl2/workflow/run_definition.proto

package workflow

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"

	core "github.com/flyteorg/flyte/v2/gen/go/flyteidl2/core"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort

	_ = core.CatalogCacheStatus(0)
)

// Validate checks the field values on Run with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Run) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Run with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in RunMultiError, or nil if none found.
func (m *Run) ValidateAll() error {
	return m.validate(true)
}

func (m *Run) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetAction()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RunValidationError{
					field:  "Action",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RunValidationError{
					field:  "Action",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RunValidationError{
				field:  "Action",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RunMultiError(errors)
	}

	return nil
}

// RunMultiError is an error wrapping multiple validation errors returned by
// Run.ValidateAll() if the designated constraints aren't met.
type RunMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RunMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RunMultiError) AllErrors() []error { return m }

// RunValidationError is the validation error returned by Run.Validate if the
// designated constraints aren't met.
type RunValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RunValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RunValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RunValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RunValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RunValidationError) ErrorName() string { return "RunValidationError" }

// Error satisfies the builtin error interface
func (e RunValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRun.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RunValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RunValidationError{}

// Validate checks the field values on RunDetails with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RunDetails) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RunDetails with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RunDetailsMultiError, or
// nil if none found.
func (m *RunDetails) ValidateAll() error {
	return m.validate(true)
}

func (m *RunDetails) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRunSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RunDetailsValidationError{
					field:  "RunSpec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RunDetailsValidationError{
					field:  "RunSpec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRunSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RunDetailsValidationError{
				field:  "RunSpec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAction()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RunDetailsValidationError{
					field:  "Action",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RunDetailsValidationError{
					field:  "Action",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RunDetailsValidationError{
				field:  "Action",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RunDetailsMultiError(errors)
	}

	return nil
}

// RunDetailsMultiError is an error wrapping multiple validation errors
// returned by RunDetails.ValidateAll() if the designated constraints aren't met.
type RunDetailsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RunDetailsMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RunDetailsMultiError) AllErrors() []error { return m }

// RunDetailsValidationError is the validation error returned by
// RunDetails.Validate if the designated constraints aren't met.
type RunDetailsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RunDetailsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RunDetailsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RunDetailsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RunDetailsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RunDetailsValidationError) ErrorName() string { return "RunDetailsValidationError" }

// Error satisfies the builtin error interface
func (e RunDetailsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRunDetails.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RunDetailsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RunDetailsValidationError{}

// Validate checks the field values on TaskAction with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TaskAction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TaskAction with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TaskActionMultiError, or
// nil if none found.
func (m *TaskAction) ValidateAll() error {
	return m.validate(true)
}

func (m *TaskAction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TaskActionValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TaskActionValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TaskActionValidationError{
				field:  "Id",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TaskActionValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TaskActionValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TaskActionValidationError{
				field:  "Spec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCacheKey()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TaskActionValidationError{
					field:  "CacheKey",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TaskActionValidationError{
					field:  "CacheKey",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCacheKey()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TaskActionValidationError{
				field:  "CacheKey",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Cluster

	if len(errors) > 0 {
		return TaskActionMultiError(errors)
	}

	return nil
}

// TaskActionMultiError is an error wrapping multiple validation errors
// returned by TaskAction.ValidateAll() if the designated constraints aren't met.
type TaskActionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TaskActionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TaskActionMultiError) AllErrors() []error { return m }

// TaskActionValidationError is the validation error returned by
// TaskAction.Validate if the designated constraints aren't met.
type TaskActionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TaskActionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TaskActionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TaskActionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TaskActionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TaskActionValidationError) ErrorName() string { return "TaskActionValidationError" }

// Error satisfies the builtin error interface
func (e TaskActionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTaskAction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TaskActionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TaskActionValidationError{}

// Validate checks the field values on TraceAction with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TraceAction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TraceAction with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TraceActionMultiError, or
// nil if none found.
func (m *TraceAction) ValidateAll() error {
	return m.validate(true)
}

func (m *TraceAction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Phase

	if all {
		switch v := interface{}(m.GetStartTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TraceActionValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TraceActionValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TraceActionValidationError{
				field:  "StartTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOutputs()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TraceActionValidationError{
					field:  "Outputs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TraceActionValidationError{
					field:  "Outputs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutputs()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TraceActionValidationError{
				field:  "Outputs",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TraceActionValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TraceActionValidationError{
					field:  "Spec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TraceActionValidationError{
				field:  "Spec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.EndTime != nil {

		if all {
			switch v := interface{}(m.GetEndTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TraceActionValidationError{
						field:  "EndTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TraceActionValidationError{
						field:  "EndTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEndTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TraceActionValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TraceActionMultiError(errors)
	}

	return nil
}

// TraceActionMultiError is an error wrapping multiple validation errors
// returned by TraceAction.ValidateAll() if the designated constraints aren't met.
type TraceActionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TraceActionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TraceActionMultiError) AllErrors() []error { return m }

// TraceActionValidationError is the validation error returned by
// TraceAction.Validate if the designated constraints aren't met.
type TraceActionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TraceActionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TraceActionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TraceActionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TraceActionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TraceActionValidationError) ErrorName() string { return "TraceActionValidationError" }

// Error satisfies the builtin error interface
func (e TraceActionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTraceAction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TraceActionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TraceActionValidationError{}

// Validate checks the field values on ConditionAction with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ConditionAction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConditionAction with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ConditionActionMultiError, or nil if none found.
func (m *ConditionAction) ValidateAll() error {
	return m.validate(true)
}

func (m *ConditionAction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if all {
		switch v := interface{}(m.GetType()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConditionActionValidationError{
					field:  "Type",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConditionActionValidationError{
					field:  "Type",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetType()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConditionActionValidationError{
				field:  "Type",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Prompt

	// no validation rules for Description

	switch v := m.Scope.(type) {
	case *ConditionAction_RunId:
		if v == nil {
			err := ConditionActionValidationError{
				field:  "Scope",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for RunId
	case *ConditionAction_ActionId:
		if v == nil {
			err := ConditionActionValidationError{
				field:  "Scope",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for ActionId
	case *ConditionAction_Global:
		if v == nil {
			err := ConditionActionValidationError{
				field:  "Scope",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for Global
	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ConditionActionMultiError(errors)
	}

	return nil
}

// ConditionActionMultiError is an error wrapping multiple validation errors
// returned by ConditionAction.ValidateAll() if the designated constraints
// aren't met.
type ConditionActionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConditionActionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConditionActionMultiError) AllErrors() []error { return m }

// ConditionActionValidationError is the validation error returned by
// ConditionAction.Validate if the designated constraints aren't met.
type ConditionActionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConditionActionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConditionActionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConditionActionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConditionActionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConditionActionValidationError) ErrorName() string { return "ConditionActionValidationError" }

// Error satisfies the builtin error interface
func (e ConditionActionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConditionAction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConditionActionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConditionActionValidationError{}

// Validate checks the field values on TaskActionMetadata with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TaskActionMetadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TaskActionMetadata with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TaskActionMetadataMultiError, or nil if none found.
func (m *TaskActionMetadata) ValidateAll() error {
	return m.validate(true)
}

func (m *TaskActionMetadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TaskActionMetadataValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TaskActionMetadataValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TaskActionMetadataValidationError{
				field:  "Id",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for TaskType

	// no validation rules for ShortName

	if len(errors) > 0 {
		return TaskActionMetadataMultiError(errors)
	}

	return nil
}

// TaskActionMetadataMultiError is an error wrapping multiple validation errors
// returned by TaskActionMetadata.ValidateAll() if the designated constraints
// aren't met.
type TaskActionMetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TaskActionMetadataMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TaskActionMetadataMultiError) AllErrors() []error { return m }

// TaskActionMetadataValidationError is the validation error returned by
// TaskActionMetadata.Validate if the designated constraints aren't met.
type TaskActionMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TaskActionMetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TaskActionMetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TaskActionMetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TaskActionMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TaskActionMetadataValidationError) ErrorName() string {
	return "TaskActionMetadataValidationError"
}

// Error satisfies the builtin error interface
func (e TaskActionMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTaskActionMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TaskActionMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TaskActionMetadataValidationError{}

// Validate checks the field values on TraceActionMetadata with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TraceActionMetadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TraceActionMetadata with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TraceActionMetadataMultiError, or nil if none found.
func (m *TraceActionMetadata) ValidateAll() error {
	return m.validate(true)
}

func (m *TraceActionMetadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if len(errors) > 0 {
		return TraceActionMetadataMultiError(errors)
	}

	return nil
}

// TraceActionMetadataMultiError is an error wrapping multiple validation
// errors returned by TraceActionMetadata.ValidateAll() if the designated
// constraints aren't met.
type TraceActionMetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TraceActionMetadataMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TraceActionMetadataMultiError) AllErrors() []error { return m }

// TraceActionMetadataValidationError is the validation error returned by
// TraceActionMetadata.Validate if the designated constraints aren't met.
type TraceActionMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TraceActionMetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TraceActionMetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TraceActionMetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TraceActionMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TraceActionMetadataValidationError) ErrorName() string {
	return "TraceActionMetadataValidationError"
}

// Error satisfies the builtin error interface
func (e TraceActionMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTraceActionMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TraceActionMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TraceActionMetadataValidationError{}

// Validate checks the field values on ConditionActionMetadata with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ConditionActionMetadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConditionActionMetadata with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ConditionActionMetadataMultiError, or nil if none found.
func (m *ConditionActionMetadata) ValidateAll() error {
	return m.validate(true)
}

func (m *ConditionActionMetadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	switch v := m.Scope.(type) {
	case *ConditionActionMetadata_RunId:
		if v == nil {
			err := ConditionActionMetadataValidationError{
				field:  "Scope",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for RunId
	case *ConditionActionMetadata_ActionId:
		if v == nil {
			err := ConditionActionMetadataValidationError{
				field:  "Scope",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for ActionId
	case *ConditionActionMetadata_Global:
		if v == nil {
			err := ConditionActionMetadataValidationError{
				field:  "Scope",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for Global
	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ConditionActionMetadataMultiError(errors)
	}

	return nil
}

// ConditionActionMetadataMultiError is an error wrapping multiple validation
// errors returned by ConditionActionMetadata.ValidateAll() if the designated
// constraints aren't met.
type ConditionActionMetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConditionActionMetadataMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConditionActionMetadataMultiError) AllErrors() []error { return m }

// ConditionActionMetadataValidationError is the validation error returned by
// ConditionActionMetadata.Validate if the designated constraints aren't met.
type ConditionActionMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConditionActionMetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConditionActionMetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConditionActionMetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConditionActionMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConditionActionMetadataValidationError) ErrorName() string {
	return "ConditionActionMetadataValidationError"
}

// Error satisfies the builtin error interface
func (e ConditionActionMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConditionActionMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConditionActionMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConditionActionMetadataValidationError{}

// Validate checks the field values on ActionMetadata with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ActionMetadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ActionMetadata with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ActionMetadataMultiError,
// or nil if none found.
func (m *ActionMetadata) ValidateAll() error {
	return m.validate(true)
}

func (m *ActionMetadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Parent

	// no validation rules for Group

	if all {
		switch v := interface{}(m.GetExecutedBy()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ActionMetadataValidationError{
					field:  "ExecutedBy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ActionMetadataValidationError{
					field:  "ExecutedBy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExecutedBy()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ActionMetadataValidationError{
				field:  "ExecutedBy",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ActionType

	if all {
		switch v := interface{}(m.GetTriggerId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ActionMetadataValidationError{
					field:  "TriggerId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ActionMetadataValidationError{
					field:  "TriggerId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTriggerId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ActionMetadataValidationError{
				field:  "TriggerId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	switch v := m.Spec.(type) {
	case *ActionMetadata_Task:
		if v == nil {
			err := ActionMetadataValidationError{
				field:  "Spec",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTask()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ActionMetadataValidationError{
						field:  "Task",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ActionMetadataValidationError{
						field:  "Task",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTask()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ActionMetadataValidationError{
					field:  "Task",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ActionMetadata_Trace:
		if v == nil {
			err := ActionMetadataValidationError{
				field:  "Spec",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTrace()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ActionMetadataValidationError{
						field:  "Trace",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ActionMetadataValidationError{
						field:  "Trace",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTrace()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ActionMetadataValidationError{
					field:  "Trace",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ActionMetadata_Condition:
		if v == nil {
			err := ActionMetadataValidationError{
				field:  "Spec",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCondition()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ActionMetadataValidationError{
						field:  "Condition",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ActionMetadataValidationError{
						field:  "Condition",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCondition()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ActionMetadataValidationError{
					field:  "Condition",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ActionMetadataMultiError(errors)
	}

	return nil
}

// ActionMetadataMultiError is an error wrapping multiple validation errors
// returned by ActionMetadata.ValidateAll() if the designated constraints
// aren't met.
type ActionMetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ActionMetadataMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ActionMetadataMultiError) AllErrors() []error { return m }

// ActionMetadataValidationError is the validation error returned by
// ActionMetadata.Validate if the designated constraints aren't met.
type ActionMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ActionMetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ActionMetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ActionMetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ActionMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ActionMetadataValidationError) ErrorName() string { return "ActionMetadataValidationError" }

// Error satisfies the builtin error interface
func (e ActionMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sActionMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ActionMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ActionMetadataValidationError{}

// Validate checks the field values on ActionStatus with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ActionStatus) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ActionStatus with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ActionStatusMultiError, or
// nil if none found.
func (m *ActionStatus) ValidateAll() error {
	return m.validate(true)
}

func (m *ActionStatus) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Phase

	if all {
		switch v := interface{}(m.GetStartTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ActionStatusValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ActionStatusValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ActionStatusValidationError{
				field:  "StartTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Attempts

	// no validation rules for CacheStatus

	if m.EndTime != nil {

		if all {
			switch v := interface{}(m.GetEndTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ActionStatusValidationError{
						field:  "EndTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ActionStatusValidationError{
						field:  "EndTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEndTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ActionStatusValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ActionStatusMultiError(errors)
	}

	return nil
}

// ActionStatusMultiError is an error wrapping multiple validation errors
// returned by ActionStatus.ValidateAll() if the designated constraints aren't met.
type ActionStatusMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ActionStatusMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ActionStatusMultiError) AllErrors() []error { return m }

// ActionStatusValidationError is the validation error returned by
// ActionStatus.Validate if the designated constraints aren't met.
type ActionStatusValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ActionStatusValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ActionStatusValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ActionStatusValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ActionStatusValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ActionStatusValidationError) ErrorName() string { return "ActionStatusValidationError" }

// Error satisfies the builtin error interface
func (e ActionStatusValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sActionStatus.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ActionStatusValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ActionStatusValidationError{}

// Validate checks the field values on Action with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Action) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Action with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ActionMultiError, or nil if none found.
func (m *Action) ValidateAll() error {
	return m.validate(true)
}

func (m *Action) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ActionValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ActionValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ActionValidationError{
				field:  "Id",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ActionValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ActionValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ActionValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetStatus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ActionValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ActionValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStatus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ActionValidationError{
				field:  "Status",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ActionMultiError(errors)
	}

	return nil
}

// ActionMultiError is an error wrapping multiple validation errors returned by
// Action.ValidateAll() if the designated constraints aren't met.
type ActionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ActionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ActionMultiError) AllErrors() []error { return m }

// ActionValidationError is the validation error returned by Action.Validate if
// the designated constraints aren't met.
type ActionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ActionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ActionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ActionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ActionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ActionValidationError) ErrorName() string { return "ActionValidationError" }

// Error satisfies the builtin error interface
func (e ActionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ActionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ActionValidationError{}

// Validate checks the field values on EnrichedAction with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EnrichedAction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EnrichedAction with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EnrichedActionMultiError,
// or nil if none found.
func (m *EnrichedAction) ValidateAll() error {
	return m.validate(true)
}

func (m *EnrichedAction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetAction()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EnrichedActionValidationError{
					field:  "Action",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EnrichedActionValidationError{
					field:  "Action",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EnrichedActionValidationError{
				field:  "Action",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MeetsFilter

	// no validation rules for ChildrenPhaseCounts

	if len(errors) > 0 {
		return EnrichedActionMultiError(errors)
	}

	return nil
}

// EnrichedActionMultiError is an error wrapping multiple validation errors
// returned by EnrichedAction.ValidateAll() if the designated constraints
// aren't met.
type EnrichedActionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EnrichedActionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EnrichedActionMultiError) AllErrors() []error { return m }

// EnrichedActionValidationError is the validation error returned by
// EnrichedAction.Validate if the designated constraints aren't met.
type EnrichedActionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EnrichedActionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EnrichedActionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EnrichedActionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EnrichedActionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EnrichedActionValidationError) ErrorName() string { return "EnrichedActionValidationError" }

// Error satisfies the builtin error interface
func (e EnrichedActionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEnrichedAction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EnrichedActionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EnrichedActionValidationError{}

// Validate checks the field values on ErrorInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ErrorInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ErrorInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ErrorInfoMultiError, or nil
// if none found.
func (m *ErrorInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *ErrorInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Message

	// no validation rules for Kind

	if len(errors) > 0 {
		return ErrorInfoMultiError(errors)
	}

	return nil
}

// ErrorInfoMultiError is an error wrapping multiple validation errors returned
// by ErrorInfo.ValidateAll() if the designated constraints aren't met.
type ErrorInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ErrorInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ErrorInfoMultiError) AllErrors() []error { return m }

// ErrorInfoValidationError is the validation error returned by
// ErrorInfo.Validate if the designated constraints aren't met.
type ErrorInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ErrorInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ErrorInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ErrorInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ErrorInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ErrorInfoValidationError) ErrorName() string { return "ErrorInfoValidationError" }

// Error satisfies the builtin error interface
func (e ErrorInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sErrorInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ErrorInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ErrorInfoValidationError{}

// Validate checks the field values on AbortInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AbortInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AbortInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AbortInfoMultiError, or nil
// if none found.
func (m *AbortInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *AbortInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Reason

	if all {
		switch v := interface{}(m.GetAbortedBy()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AbortInfoValidationError{
					field:  "AbortedBy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AbortInfoValidationError{
					field:  "AbortedBy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAbortedBy()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AbortInfoValidationError{
				field:  "AbortedBy",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AbortInfoMultiError(errors)
	}

	return nil
}

// AbortInfoMultiError is an error wrapping multiple validation errors returned
// by AbortInfo.ValidateAll() if the designated constraints aren't met.
type AbortInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AbortInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AbortInfoMultiError) AllErrors() []error { return m }

// AbortInfoValidationError is the validation error returned by
// AbortInfo.Validate if the designated constraints aren't met.
type AbortInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AbortInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AbortInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AbortInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AbortInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AbortInfoValidationError) ErrorName() string { return "AbortInfoValidationError" }

// Error satisfies the builtin error interface
func (e AbortInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAbortInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AbortInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AbortInfoValidationError{}

// Validate checks the field values on ActionDetails with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ActionDetails) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ActionDetails with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ActionDetailsMultiError, or
// nil if none found.
func (m *ActionDetails) ValidateAll() error {
	return m.validate(true)
}

func (m *ActionDetails) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ActionDetailsValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ActionDetailsValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ActionDetailsValidationError{
				field:  "Id",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ActionDetailsValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ActionDetailsValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ActionDetailsValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetStatus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ActionDetailsValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ActionDetailsValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStatus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ActionDetailsValidationError{
				field:  "Status",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetAttempts() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ActionDetailsValidationError{
						field:  fmt.Sprintf("Attempts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ActionDetailsValidationError{
						field:  fmt.Sprintf("Attempts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ActionDetailsValidationError{
					field:  fmt.Sprintf("Attempts[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	switch v := m.Result.(type) {
	case *ActionDetails_ErrorInfo:
		if v == nil {
			err := ActionDetailsValidationError{
				field:  "Result",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetErrorInfo()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ActionDetailsValidationError{
						field:  "ErrorInfo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ActionDetailsValidationError{
						field:  "ErrorInfo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetErrorInfo()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ActionDetailsValidationError{
					field:  "ErrorInfo",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ActionDetails_AbortInfo:
		if v == nil {
			err := ActionDetailsValidationError{
				field:  "Result",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAbortInfo()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ActionDetailsValidationError{
						field:  "AbortInfo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ActionDetailsValidationError{
						field:  "AbortInfo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAbortInfo()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ActionDetailsValidationError{
					field:  "AbortInfo",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}
	switch v := m.Spec.(type) {
	case *ActionDetails_Task:
		if v == nil {
			err := ActionDetailsValidationError{
				field:  "Spec",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTask()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ActionDetailsValidationError{
						field:  "Task",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ActionDetailsValidationError{
						field:  "Task",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTask()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ActionDetailsValidationError{
					field:  "Task",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ActionDetails_Trace:
		if v == nil {
			err := ActionDetailsValidationError{
				field:  "Spec",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTrace()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ActionDetailsValidationError{
						field:  "Trace",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ActionDetailsValidationError{
						field:  "Trace",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTrace()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ActionDetailsValidationError{
					field:  "Trace",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ActionDetailsMultiError(errors)
	}

	return nil
}

// ActionDetailsMultiError is an error wrapping multiple validation errors
// returned by ActionDetails.ValidateAll() if the designated constraints
// aren't met.
type ActionDetailsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ActionDetailsMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ActionDetailsMultiError) AllErrors() []error { return m }

// ActionDetailsValidationError is the validation error returned by
// ActionDetails.Validate if the designated constraints aren't met.
type ActionDetailsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ActionDetailsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ActionDetailsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ActionDetailsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ActionDetailsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ActionDetailsValidationError) ErrorName() string { return "ActionDetailsValidationError" }

// Error satisfies the builtin error interface
func (e ActionDetailsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sActionDetails.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ActionDetailsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ActionDetailsValidationError{}

// Validate checks the field values on ActionAttempt with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ActionAttempt) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ActionAttempt with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ActionAttemptMultiError, or
// nil if none found.
func (m *ActionAttempt) ValidateAll() error {
	return m.validate(true)
}

func (m *ActionAttempt) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Phase

	if all {
		switch v := interface{}(m.GetStartTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ActionAttemptValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ActionAttemptValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ActionAttemptValidationError{
				field:  "StartTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Attempt

	for idx, item := range m.GetLogInfo() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ActionAttemptValidationError{
						field:  fmt.Sprintf("LogInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ActionAttemptValidationError{
						field:  fmt.Sprintf("LogInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ActionAttemptValidationError{
					field:  fmt.Sprintf("LogInfo[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetOutputs()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ActionAttemptValidationError{
					field:  "Outputs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ActionAttemptValidationError{
					field:  "Outputs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutputs()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ActionAttemptValidationError{
				field:  "Outputs",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for LogsAvailable

	// no validation rules for CacheStatus

	for idx, item := range m.GetClusterEvents() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ActionAttemptValidationError{
						field:  fmt.Sprintf("ClusterEvents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ActionAttemptValidationError{
						field:  fmt.Sprintf("ClusterEvents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ActionAttemptValidationError{
					field:  fmt.Sprintf("ClusterEvents[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetPhaseTransitions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ActionAttemptValidationError{
						field:  fmt.Sprintf("PhaseTransitions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ActionAttemptValidationError{
						field:  fmt.Sprintf("PhaseTransitions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ActionAttemptValidationError{
					field:  fmt.Sprintf("PhaseTransitions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Cluster

	if all {
		switch v := interface{}(m.GetLogContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ActionAttemptValidationError{
					field:  "LogContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ActionAttemptValidationError{
					field:  "LogContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLogContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ActionAttemptValidationError{
				field:  "LogContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.EndTime != nil {

		if all {
			switch v := interface{}(m.GetEndTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ActionAttemptValidationError{
						field:  "EndTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ActionAttemptValidationError{
						field:  "EndTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEndTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ActionAttemptValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.ErrorInfo != nil {

		if all {
			switch v := interface{}(m.GetErrorInfo()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ActionAttemptValidationError{
						field:  "ErrorInfo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ActionAttemptValidationError{
						field:  "ErrorInfo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetErrorInfo()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ActionAttemptValidationError{
					field:  "ErrorInfo",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ActionAttemptMultiError(errors)
	}

	return nil
}

// ActionAttemptMultiError is an error wrapping multiple validation errors
// returned by ActionAttempt.ValidateAll() if the designated constraints
// aren't met.
type ActionAttemptMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ActionAttemptMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ActionAttemptMultiError) AllErrors() []error { return m }

// ActionAttemptValidationError is the validation error returned by
// ActionAttempt.Validate if the designated constraints aren't met.
type ActionAttemptValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ActionAttemptValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ActionAttemptValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ActionAttemptValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ActionAttemptValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ActionAttemptValidationError) ErrorName() string { return "ActionAttemptValidationError" }

// Error satisfies the builtin error interface
func (e ActionAttemptValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sActionAttempt.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ActionAttemptValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ActionAttemptValidationError{}

// Validate checks the field values on ClusterEvent with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ClusterEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClusterEvent with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ClusterEventMultiError, or
// nil if none found.
func (m *ClusterEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *ClusterEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOccurredAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClusterEventValidationError{
					field:  "OccurredAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClusterEventValidationError{
					field:  "OccurredAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOccurredAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClusterEventValidationError{
				field:  "OccurredAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Message

	if len(errors) > 0 {
		return ClusterEventMultiError(errors)
	}

	return nil
}

// ClusterEventMultiError is an error wrapping multiple validation errors
// returned by ClusterEvent.ValidateAll() if the designated constraints aren't met.
type ClusterEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterEventMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterEventMultiError) AllErrors() []error { return m }

// ClusterEventValidationError is the validation error returned by
// ClusterEvent.Validate if the designated constraints aren't met.
type ClusterEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterEventValidationError) ErrorName() string { return "ClusterEventValidationError" }

// Error satisfies the builtin error interface
func (e ClusterEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClusterEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterEventValidationError{}

// Validate checks the field values on PhaseTransition with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PhaseTransition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PhaseTransition with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PhaseTransitionMultiError, or nil if none found.
func (m *PhaseTransition) ValidateAll() error {
	return m.validate(true)
}

func (m *PhaseTransition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Phase

	if all {
		switch v := interface{}(m.GetStartTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PhaseTransitionValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PhaseTransitionValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PhaseTransitionValidationError{
				field:  "StartTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.EndTime != nil {

		if all {
			switch v := interface{}(m.GetEndTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PhaseTransitionValidationError{
						field:  "EndTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PhaseTransitionValidationError{
						field:  "EndTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEndTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PhaseTransitionValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return PhaseTransitionMultiError(errors)
	}

	return nil
}

// PhaseTransitionMultiError is an error wrapping multiple validation errors
// returned by PhaseTransition.ValidateAll() if the designated constraints
// aren't met.
type PhaseTransitionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PhaseTransitionMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PhaseTransitionMultiError) AllErrors() []error { return m }

// PhaseTransitionValidationError is the validation error returned by
// PhaseTransition.Validate if the designated constraints aren't met.
type PhaseTransitionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PhaseTransitionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PhaseTransitionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PhaseTransitionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PhaseTransitionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PhaseTransitionValidationError) ErrorName() string { return "PhaseTransitionValidationError" }

// Error satisfies the builtin error interface
func (e PhaseTransitionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPhaseTransition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PhaseTransitionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PhaseTransitionValidationError{}

// Validate checks the field values on ActionEvent with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ActionEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ActionEvent with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ActionEventMultiError, or
// nil if none found.
func (m *ActionEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *ActionEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ActionEventValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ActionEventValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ActionEventValidationError{
				field:  "Id",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Attempt

	// no validation rules for Phase

	// no validation rules for Version

	if all {
		switch v := interface{}(m.GetStartTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ActionEventValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ActionEventValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ActionEventValidationError{
				field:  "StartTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ActionEventValidationError{
					field:  "UpdatedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ActionEventValidationError{
					field:  "UpdatedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ActionEventValidationError{
				field:  "UpdatedTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetLogInfo() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ActionEventValidationError{
						field:  fmt.Sprintf("LogInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ActionEventValidationError{
						field:  fmt.Sprintf("LogInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ActionEventValidationError{
					field:  fmt.Sprintf("LogInfo[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetLogContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ActionEventValidationError{
					field:  "LogContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ActionEventValidationError{
					field:  "LogContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLogContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ActionEventValidationError{
				field:  "LogContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Cluster

	if all {
		switch v := interface{}(m.GetOutputs()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ActionEventValidationError{
					field:  "Outputs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ActionEventValidationError{
					field:  "Outputs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutputs()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ActionEventValidationError{
				field:  "Outputs",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CacheStatus

	for idx, item := range m.GetClusterEvents() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ActionEventValidationError{
						field:  fmt.Sprintf("ClusterEvents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ActionEventValidationError{
						field:  fmt.Sprintf("ClusterEvents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ActionEventValidationError{
					field:  fmt.Sprintf("ClusterEvents[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetReportedTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ActionEventValidationError{
					field:  "ReportedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ActionEventValidationError{
					field:  "ReportedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReportedTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ActionEventValidationError{
				field:  "ReportedTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.EndTime != nil {

		if all {
			switch v := interface{}(m.GetEndTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ActionEventValidationError{
						field:  "EndTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ActionEventValidationError{
						field:  "EndTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEndTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ActionEventValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.ErrorInfo != nil {

		if all {
			switch v := interface{}(m.GetErrorInfo()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ActionEventValidationError{
						field:  "ErrorInfo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ActionEventValidationError{
						field:  "ErrorInfo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetErrorInfo()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ActionEventValidationError{
					field:  "ErrorInfo",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ActionEventMultiError(errors)
	}

	return nil
}

// ActionEventMultiError is an error wrapping multiple validation errors
// returned by ActionEvent.ValidateAll() if the designated constraints aren't met.
type ActionEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ActionEventMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ActionEventMultiError) AllErrors() []error { return m }

// ActionEventValidationError is the validation error returned by
// ActionEvent.Validate if the designated constraints aren't met.
type ActionEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ActionEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ActionEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ActionEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ActionEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ActionEventValidationError) ErrorName() string { return "ActionEventValidationError" }

// Error satisfies the builtin error interface
func (e ActionEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sActionEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ActionEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ActionEventValidationError{}

// Validate checks the field values on ActionSpec with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ActionSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ActionSpec with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ActionSpecMultiError, or
// nil if none found.
func (m *ActionSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *ActionSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetActionId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ActionSpecValidationError{
					field:  "ActionId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ActionSpecValidationError{
					field:  "ActionId",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetActionId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ActionSpecValidationError{
				field:  "ActionId",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetRunSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ActionSpecValidationError{
					field:  "RunSpec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ActionSpecValidationError{
					field:  "RunSpec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRunSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ActionSpecValidationError{
				field:  "RunSpec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for InputUri

	// no validation rules for RunOutputBase

	// no validation rules for Group

	switch v := m.Spec.(type) {
	case *ActionSpec_Task:
		if v == nil {
			err := ActionSpecValidationError{
				field:  "Spec",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTask()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ActionSpecValidationError{
						field:  "Task",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ActionSpecValidationError{
						field:  "Task",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTask()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ActionSpecValidationError{
					field:  "Task",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ActionSpec_Condition:
		if v == nil {
			err := ActionSpecValidationError{
				field:  "Spec",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCondition()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ActionSpecValidationError{
						field:  "Condition",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ActionSpecValidationError{
						field:  "Condition",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCondition()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ActionSpecValidationError{
					field:  "Condition",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ActionSpec_Trace:
		if v == nil {
			err := ActionSpecValidationError{
				field:  "Spec",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTrace()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ActionSpecValidationError{
						field:  "Trace",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ActionSpecValidationError{
						field:  "Trace",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTrace()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ActionSpecValidationError{
					field:  "Trace",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if m.ParentActionName != nil {
		// no validation rules for ParentActionName
	}

	if len(errors) > 0 {
		return ActionSpecMultiError(errors)
	}

	return nil
}

// ActionSpecMultiError is an error wrapping multiple validation errors
// returned by ActionSpec.ValidateAll() if the designated constraints aren't met.
type ActionSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ActionSpecMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ActionSpecMultiError) AllErrors() []error { return m }

// ActionSpecValidationError is the validation error returned by
// ActionSpec.Validate if the designated constraints aren't met.
type ActionSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ActionSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ActionSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ActionSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ActionSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ActionSpecValidationError) ErrorName() string { return "ActionSpecValidationError" }

// Error satisfies the builtin error interface
func (e ActionSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sActionSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ActionSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ActionSpecValidationError{}
