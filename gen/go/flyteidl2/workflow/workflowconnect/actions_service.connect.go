// Code generated by protoc-gen-connect-go. DO NOT EDIT.
//
// Source: flyteidl2/workflow/actions_service.proto

package workflowconnect

import (
	connect "connectrpc.com/connect"
	context "context"
	errors "errors"
	workflow "github.com/flyteorg/flyte/v2/gen/go/flyteidl2/workflow"
	http "net/http"
	strings "strings"
)

// This is a compile-time assertion to ensure that this generated file and the connect package are
// compatible. If you get a compiler error that this constant is not defined, this code was
// generated with a version of connect newer than the one compiled into your binary. You can fix the
// problem by either regenerating this code with an older version of connect or updating the connect
// version compiled into your binary.
const _ = connect.IsAtLeastVersion1_13_0

const (
	// ActionsServiceName is the fully-qualified name of the ActionsService service.
	ActionsServiceName = "flyteidl2.workflow.ActionsService"
)

// These constants are the fully-qualified names of the RPCs defined in this package. They're
// exposed at runtime as Spec.Procedure and as the final two segments of the HTTP route.
//
// Note that these are different from the fully-qualified method names used by
// google.golang.org/protobuf/reflect/protoreflect. To convert from these constants to
// reflection-formatted method names, remove the leading slash and convert the remaining slash to a
// period.
const (
	// ActionsServiceEnqueueProcedure is the fully-qualified name of the ActionsService's Enqueue RPC.
	ActionsServiceEnqueueProcedure = "/flyteidl2.workflow.ActionsService/Enqueue"
	// ActionsServiceGetLatestStateProcedure is the fully-qualified name of the ActionsService's
	// GetLatestState RPC.
	ActionsServiceGetLatestStateProcedure = "/flyteidl2.workflow.ActionsService/GetLatestState"
	// ActionsServiceWatchForUpdatesProcedure is the fully-qualified name of the ActionsService's
	// WatchForUpdates RPC.
	ActionsServiceWatchForUpdatesProcedure = "/flyteidl2.workflow.ActionsService/WatchForUpdates"
	// ActionsServiceUpdateProcedure is the fully-qualified name of the ActionsService's Update RPC.
	ActionsServiceUpdateProcedure = "/flyteidl2.workflow.ActionsService/Update"
	// ActionsServiceAbortProcedure is the fully-qualified name of the ActionsService's Abort RPC.
	ActionsServiceAbortProcedure = "/flyteidl2.workflow.ActionsService/Abort"
)

// These variables are the protoreflect.Descriptor objects for the RPCs defined in this package.
var (
	actionsServiceServiceDescriptor               = workflow.File_flyteidl2_workflow_actions_service_proto.Services().ByName("ActionsService")
	actionsServiceEnqueueMethodDescriptor         = actionsServiceServiceDescriptor.Methods().ByName("Enqueue")
	actionsServiceGetLatestStateMethodDescriptor  = actionsServiceServiceDescriptor.Methods().ByName("GetLatestState")
	actionsServiceWatchForUpdatesMethodDescriptor = actionsServiceServiceDescriptor.Methods().ByName("WatchForUpdates")
	actionsServiceUpdateMethodDescriptor          = actionsServiceServiceDescriptor.Methods().ByName("Update")
	actionsServiceAbortMethodDescriptor           = actionsServiceServiceDescriptor.Methods().ByName("Abort")
)

// ActionsServiceClient is a client for the flyteidl2.workflow.ActionsService service.
type ActionsServiceClient interface {
	// Enqueue queues a new action for execution.
	Enqueue(context.Context, *connect.Request[workflow.EnqueueActionRequest]) (*connect.Response[workflow.EnqueueActionResponse], error)
	// GetLatestState returns the latest `NodeStatus` of an action.
	// This deprecates Get in the current StateService.
	GetLatestState(context.Context, *connect.Request[workflow.GetLatestStateRequest]) (*connect.Response[workflow.GetLatestStateResponse], error)
	// WatchForUpdates watches for updates to the state of actions.
	// This API guarantees at-least-once delivery semantics.
	WatchForUpdates(context.Context, *connect.Request[workflow.WatchRequest]) (*connect.ServerStreamForClient[workflow.WatchResponse], error)
	// Update updates the status of an action and saves serialized NodeStatus.
	// This deprecates Put in the current StateService.
	Update(context.Context, *connect.Request[workflow.UpdateRequest]) (*connect.Response[workflow.UpdateResponse], error)
	// Abort aborts a single action that was previously queued or is currently being processed by a worker.
	// Note that this will cascade aborts to all descendant actions of the specified action.
	Abort(context.Context, *connect.Request[workflow.AbortQueuedActionRequest]) (*connect.Response[workflow.AbortQueuedActionResponse], error)
}

// NewActionsServiceClient constructs a client for the flyteidl2.workflow.ActionsService service. By
// default, it uses the Connect protocol with the binary Protobuf Codec, asks for gzipped responses,
// and sends uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the
// connect.WithGRPC() or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewActionsServiceClient(httpClient connect.HTTPClient, baseURL string, opts ...connect.ClientOption) ActionsServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &actionsServiceClient{
		enqueue: connect.NewClient[workflow.EnqueueActionRequest, workflow.EnqueueActionResponse](
			httpClient,
			baseURL+ActionsServiceEnqueueProcedure,
			connect.WithSchema(actionsServiceEnqueueMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		getLatestState: connect.NewClient[workflow.GetLatestStateRequest, workflow.GetLatestStateResponse](
			httpClient,
			baseURL+ActionsServiceGetLatestStateProcedure,
			connect.WithSchema(actionsServiceGetLatestStateMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		watchForUpdates: connect.NewClient[workflow.WatchRequest, workflow.WatchResponse](
			httpClient,
			baseURL+ActionsServiceWatchForUpdatesProcedure,
			connect.WithSchema(actionsServiceWatchForUpdatesMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		update: connect.NewClient[workflow.UpdateRequest, workflow.UpdateResponse](
			httpClient,
			baseURL+ActionsServiceUpdateProcedure,
			connect.WithSchema(actionsServiceUpdateMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		abort: connect.NewClient[workflow.AbortQueuedActionRequest, workflow.AbortQueuedActionResponse](
			httpClient,
			baseURL+ActionsServiceAbortProcedure,
			connect.WithSchema(actionsServiceAbortMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
	}
}

// actionsServiceClient implements ActionsServiceClient.
type actionsServiceClient struct {
	enqueue         *connect.Client[workflow.EnqueueActionRequest, workflow.EnqueueActionResponse]
	getLatestState  *connect.Client[workflow.GetLatestStateRequest, workflow.GetLatestStateResponse]
	watchForUpdates *connect.Client[workflow.WatchRequest, workflow.WatchResponse]
	update          *connect.Client[workflow.UpdateRequest, workflow.UpdateResponse]
	abort           *connect.Client[workflow.AbortQueuedActionRequest, workflow.AbortQueuedActionResponse]
}

// Enqueue calls flyteidl2.workflow.ActionsService.Enqueue.
func (c *actionsServiceClient) Enqueue(ctx context.Context, req *connect.Request[workflow.EnqueueActionRequest]) (*connect.Response[workflow.EnqueueActionResponse], error) {
	return c.enqueue.CallUnary(ctx, req)
}

// GetLatestState calls flyteidl2.workflow.ActionsService.GetLatestState.
func (c *actionsServiceClient) GetLatestState(ctx context.Context, req *connect.Request[workflow.GetLatestStateRequest]) (*connect.Response[workflow.GetLatestStateResponse], error) {
	return c.getLatestState.CallUnary(ctx, req)
}

// WatchForUpdates calls flyteidl2.workflow.ActionsService.WatchForUpdates.
func (c *actionsServiceClient) WatchForUpdates(ctx context.Context, req *connect.Request[workflow.WatchRequest]) (*connect.ServerStreamForClient[workflow.WatchResponse], error) {
	return c.watchForUpdates.CallServerStream(ctx, req)
}

// Update calls flyteidl2.workflow.ActionsService.Update.
func (c *actionsServiceClient) Update(ctx context.Context, req *connect.Request[workflow.UpdateRequest]) (*connect.Response[workflow.UpdateResponse], error) {
	return c.update.CallUnary(ctx, req)
}

// Abort calls flyteidl2.workflow.ActionsService.Abort.
func (c *actionsServiceClient) Abort(ctx context.Context, req *connect.Request[workflow.AbortQueuedActionRequest]) (*connect.Response[workflow.AbortQueuedActionResponse], error) {
	return c.abort.CallUnary(ctx, req)
}

// ActionsServiceHandler is an implementation of the flyteidl2.workflow.ActionsService service.
type ActionsServiceHandler interface {
	// Enqueue queues a new action for execution.
	Enqueue(context.Context, *connect.Request[workflow.EnqueueActionRequest]) (*connect.Response[workflow.EnqueueActionResponse], error)
	// GetLatestState returns the latest `NodeStatus` of an action.
	// This deprecates Get in the current StateService.
	GetLatestState(context.Context, *connect.Request[workflow.GetLatestStateRequest]) (*connect.Response[workflow.GetLatestStateResponse], error)
	// WatchForUpdates watches for updates to the state of actions.
	// This API guarantees at-least-once delivery semantics.
	WatchForUpdates(context.Context, *connect.Request[workflow.WatchRequest], *connect.ServerStream[workflow.WatchResponse]) error
	// Update updates the status of an action and saves serialized NodeStatus.
	// This deprecates Put in the current StateService.
	Update(context.Context, *connect.Request[workflow.UpdateRequest]) (*connect.Response[workflow.UpdateResponse], error)
	// Abort aborts a single action that was previously queued or is currently being processed by a worker.
	// Note that this will cascade aborts to all descendant actions of the specified action.
	Abort(context.Context, *connect.Request[workflow.AbortQueuedActionRequest]) (*connect.Response[workflow.AbortQueuedActionResponse], error)
}

// NewActionsServiceHandler builds an HTTP handler from the service implementation. It returns the
// path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewActionsServiceHandler(svc ActionsServiceHandler, opts ...connect.HandlerOption) (string, http.Handler) {
	actionsServiceEnqueueHandler := connect.NewUnaryHandler(
		ActionsServiceEnqueueProcedure,
		svc.Enqueue,
		connect.WithSchema(actionsServiceEnqueueMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	actionsServiceGetLatestStateHandler := connect.NewUnaryHandler(
		ActionsServiceGetLatestStateProcedure,
		svc.GetLatestState,
		connect.WithSchema(actionsServiceGetLatestStateMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	actionsServiceWatchForUpdatesHandler := connect.NewServerStreamHandler(
		ActionsServiceWatchForUpdatesProcedure,
		svc.WatchForUpdates,
		connect.WithSchema(actionsServiceWatchForUpdatesMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	actionsServiceUpdateHandler := connect.NewUnaryHandler(
		ActionsServiceUpdateProcedure,
		svc.Update,
		connect.WithSchema(actionsServiceUpdateMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	actionsServiceAbortHandler := connect.NewUnaryHandler(
		ActionsServiceAbortProcedure,
		svc.Abort,
		connect.WithSchema(actionsServiceAbortMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	return "/flyteidl2.workflow.ActionsService/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case ActionsServiceEnqueueProcedure:
			actionsServiceEnqueueHandler.ServeHTTP(w, r)
		case ActionsServiceGetLatestStateProcedure:
			actionsServiceGetLatestStateHandler.ServeHTTP(w, r)
		case ActionsServiceWatchForUpdatesProcedure:
			actionsServiceWatchForUpdatesHandler.ServeHTTP(w, r)
		case ActionsServiceUpdateProcedure:
			actionsServiceUpdateHandler.ServeHTTP(w, r)
		case ActionsServiceAbortProcedure:
			actionsServiceAbortHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedActionsServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedActionsServiceHandler struct{}

func (UnimplementedActionsServiceHandler) Enqueue(context.Context, *connect.Request[workflow.EnqueueActionRequest]) (*connect.Response[workflow.EnqueueActionResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("flyteidl2.workflow.ActionsService.Enqueue is not implemented"))
}

func (UnimplementedActionsServiceHandler) GetLatestState(context.Context, *connect.Request[workflow.GetLatestStateRequest]) (*connect.Response[workflow.GetLatestStateResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("flyteidl2.workflow.ActionsService.GetLatestState is not implemented"))
}

func (UnimplementedActionsServiceHandler) WatchForUpdates(context.Context, *connect.Request[workflow.WatchRequest], *connect.ServerStream[workflow.WatchResponse]) error {
	return connect.NewError(connect.CodeUnimplemented, errors.New("flyteidl2.workflow.ActionsService.WatchForUpdates is not implemented"))
}

func (UnimplementedActionsServiceHandler) Update(context.Context, *connect.Request[workflow.UpdateRequest]) (*connect.Response[workflow.UpdateResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("flyteidl2.workflow.ActionsService.Update is not implemented"))
}

func (UnimplementedActionsServiceHandler) Abort(context.Context, *connect.Request[workflow.AbortQueuedActionRequest]) (*connect.Response[workflow.AbortQueuedActionResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("flyteidl2.workflow.ActionsService.Abort is not implemented"))
}
