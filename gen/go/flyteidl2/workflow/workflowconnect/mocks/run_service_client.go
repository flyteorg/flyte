// Code generated by mockery. DO NOT EDIT.

package mocks

import (
	context "context"

	connect "connectrpc.com/connect"

	mock "github.com/stretchr/testify/mock"

	workflow "github.com/flyteorg/flyte/v2/gen/go/flyteidl2/workflow"
)

// RunServiceClient is an autogenerated mock type for the RunServiceClient type
type RunServiceClient struct {
	mock.Mock
}

type RunServiceClient_Expecter struct {
	mock *mock.Mock
}

func (_m *RunServiceClient) EXPECT() *RunServiceClient_Expecter {
	return &RunServiceClient_Expecter{mock: &_m.Mock}
}

// AbortAction provides a mock function with given fields: _a0, _a1
func (_m *RunServiceClient) AbortAction(_a0 context.Context, _a1 *connect.Request[workflow.AbortActionRequest]) (*connect.Response[workflow.AbortActionResponse], error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for AbortAction")
	}

	var r0 *connect.Response[workflow.AbortActionResponse]
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *connect.Request[workflow.AbortActionRequest]) (*connect.Response[workflow.AbortActionResponse], error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *connect.Request[workflow.AbortActionRequest]) *connect.Response[workflow.AbortActionResponse]); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*connect.Response[workflow.AbortActionResponse])
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *connect.Request[workflow.AbortActionRequest]) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RunServiceClient_AbortAction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AbortAction'
type RunServiceClient_AbortAction_Call struct {
	*mock.Call
}

// AbortAction is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *connect.Request[workflow.AbortActionRequest]
func (_e *RunServiceClient_Expecter) AbortAction(_a0 interface{}, _a1 interface{}) *RunServiceClient_AbortAction_Call {
	return &RunServiceClient_AbortAction_Call{Call: _e.mock.On("AbortAction", _a0, _a1)}
}

func (_c *RunServiceClient_AbortAction_Call) Run(run func(_a0 context.Context, _a1 *connect.Request[workflow.AbortActionRequest])) *RunServiceClient_AbortAction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*connect.Request[workflow.AbortActionRequest]))
	})
	return _c
}

func (_c *RunServiceClient_AbortAction_Call) Return(_a0 *connect.Response[workflow.AbortActionResponse], _a1 error) *RunServiceClient_AbortAction_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RunServiceClient_AbortAction_Call) RunAndReturn(run func(context.Context, *connect.Request[workflow.AbortActionRequest]) (*connect.Response[workflow.AbortActionResponse], error)) *RunServiceClient_AbortAction_Call {
	_c.Call.Return(run)
	return _c
}

// AbortRun provides a mock function with given fields: _a0, _a1
func (_m *RunServiceClient) AbortRun(_a0 context.Context, _a1 *connect.Request[workflow.AbortRunRequest]) (*connect.Response[workflow.AbortRunResponse], error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for AbortRun")
	}

	var r0 *connect.Response[workflow.AbortRunResponse]
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *connect.Request[workflow.AbortRunRequest]) (*connect.Response[workflow.AbortRunResponse], error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *connect.Request[workflow.AbortRunRequest]) *connect.Response[workflow.AbortRunResponse]); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*connect.Response[workflow.AbortRunResponse])
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *connect.Request[workflow.AbortRunRequest]) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RunServiceClient_AbortRun_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AbortRun'
type RunServiceClient_AbortRun_Call struct {
	*mock.Call
}

// AbortRun is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *connect.Request[workflow.AbortRunRequest]
func (_e *RunServiceClient_Expecter) AbortRun(_a0 interface{}, _a1 interface{}) *RunServiceClient_AbortRun_Call {
	return &RunServiceClient_AbortRun_Call{Call: _e.mock.On("AbortRun", _a0, _a1)}
}

func (_c *RunServiceClient_AbortRun_Call) Run(run func(_a0 context.Context, _a1 *connect.Request[workflow.AbortRunRequest])) *RunServiceClient_AbortRun_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*connect.Request[workflow.AbortRunRequest]))
	})
	return _c
}

func (_c *RunServiceClient_AbortRun_Call) Return(_a0 *connect.Response[workflow.AbortRunResponse], _a1 error) *RunServiceClient_AbortRun_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RunServiceClient_AbortRun_Call) RunAndReturn(run func(context.Context, *connect.Request[workflow.AbortRunRequest]) (*connect.Response[workflow.AbortRunResponse], error)) *RunServiceClient_AbortRun_Call {
	_c.Call.Return(run)
	return _c
}

// CreateRun provides a mock function with given fields: _a0, _a1
func (_m *RunServiceClient) CreateRun(_a0 context.Context, _a1 *connect.Request[workflow.CreateRunRequest]) (*connect.Response[workflow.CreateRunResponse], error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for CreateRun")
	}

	var r0 *connect.Response[workflow.CreateRunResponse]
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *connect.Request[workflow.CreateRunRequest]) (*connect.Response[workflow.CreateRunResponse], error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *connect.Request[workflow.CreateRunRequest]) *connect.Response[workflow.CreateRunResponse]); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*connect.Response[workflow.CreateRunResponse])
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *connect.Request[workflow.CreateRunRequest]) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RunServiceClient_CreateRun_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateRun'
type RunServiceClient_CreateRun_Call struct {
	*mock.Call
}

// CreateRun is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *connect.Request[workflow.CreateRunRequest]
func (_e *RunServiceClient_Expecter) CreateRun(_a0 interface{}, _a1 interface{}) *RunServiceClient_CreateRun_Call {
	return &RunServiceClient_CreateRun_Call{Call: _e.mock.On("CreateRun", _a0, _a1)}
}

func (_c *RunServiceClient_CreateRun_Call) Run(run func(_a0 context.Context, _a1 *connect.Request[workflow.CreateRunRequest])) *RunServiceClient_CreateRun_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*connect.Request[workflow.CreateRunRequest]))
	})
	return _c
}

func (_c *RunServiceClient_CreateRun_Call) Return(_a0 *connect.Response[workflow.CreateRunResponse], _a1 error) *RunServiceClient_CreateRun_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RunServiceClient_CreateRun_Call) RunAndReturn(run func(context.Context, *connect.Request[workflow.CreateRunRequest]) (*connect.Response[workflow.CreateRunResponse], error)) *RunServiceClient_CreateRun_Call {
	_c.Call.Return(run)
	return _c
}

// GetActionData provides a mock function with given fields: _a0, _a1
func (_m *RunServiceClient) GetActionData(_a0 context.Context, _a1 *connect.Request[workflow.GetActionDataRequest]) (*connect.Response[workflow.GetActionDataResponse], error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for GetActionData")
	}

	var r0 *connect.Response[workflow.GetActionDataResponse]
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *connect.Request[workflow.GetActionDataRequest]) (*connect.Response[workflow.GetActionDataResponse], error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *connect.Request[workflow.GetActionDataRequest]) *connect.Response[workflow.GetActionDataResponse]); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*connect.Response[workflow.GetActionDataResponse])
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *connect.Request[workflow.GetActionDataRequest]) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RunServiceClient_GetActionData_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetActionData'
type RunServiceClient_GetActionData_Call struct {
	*mock.Call
}

// GetActionData is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *connect.Request[workflow.GetActionDataRequest]
func (_e *RunServiceClient_Expecter) GetActionData(_a0 interface{}, _a1 interface{}) *RunServiceClient_GetActionData_Call {
	return &RunServiceClient_GetActionData_Call{Call: _e.mock.On("GetActionData", _a0, _a1)}
}

func (_c *RunServiceClient_GetActionData_Call) Run(run func(_a0 context.Context, _a1 *connect.Request[workflow.GetActionDataRequest])) *RunServiceClient_GetActionData_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*connect.Request[workflow.GetActionDataRequest]))
	})
	return _c
}

func (_c *RunServiceClient_GetActionData_Call) Return(_a0 *connect.Response[workflow.GetActionDataResponse], _a1 error) *RunServiceClient_GetActionData_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RunServiceClient_GetActionData_Call) RunAndReturn(run func(context.Context, *connect.Request[workflow.GetActionDataRequest]) (*connect.Response[workflow.GetActionDataResponse], error)) *RunServiceClient_GetActionData_Call {
	_c.Call.Return(run)
	return _c
}

// GetActionDetails provides a mock function with given fields: _a0, _a1
func (_m *RunServiceClient) GetActionDetails(_a0 context.Context, _a1 *connect.Request[workflow.GetActionDetailsRequest]) (*connect.Response[workflow.GetActionDetailsResponse], error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for GetActionDetails")
	}

	var r0 *connect.Response[workflow.GetActionDetailsResponse]
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *connect.Request[workflow.GetActionDetailsRequest]) (*connect.Response[workflow.GetActionDetailsResponse], error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *connect.Request[workflow.GetActionDetailsRequest]) *connect.Response[workflow.GetActionDetailsResponse]); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*connect.Response[workflow.GetActionDetailsResponse])
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *connect.Request[workflow.GetActionDetailsRequest]) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RunServiceClient_GetActionDetails_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetActionDetails'
type RunServiceClient_GetActionDetails_Call struct {
	*mock.Call
}

// GetActionDetails is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *connect.Request[workflow.GetActionDetailsRequest]
func (_e *RunServiceClient_Expecter) GetActionDetails(_a0 interface{}, _a1 interface{}) *RunServiceClient_GetActionDetails_Call {
	return &RunServiceClient_GetActionDetails_Call{Call: _e.mock.On("GetActionDetails", _a0, _a1)}
}

func (_c *RunServiceClient_GetActionDetails_Call) Run(run func(_a0 context.Context, _a1 *connect.Request[workflow.GetActionDetailsRequest])) *RunServiceClient_GetActionDetails_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*connect.Request[workflow.GetActionDetailsRequest]))
	})
	return _c
}

func (_c *RunServiceClient_GetActionDetails_Call) Return(_a0 *connect.Response[workflow.GetActionDetailsResponse], _a1 error) *RunServiceClient_GetActionDetails_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RunServiceClient_GetActionDetails_Call) RunAndReturn(run func(context.Context, *connect.Request[workflow.GetActionDetailsRequest]) (*connect.Response[workflow.GetActionDetailsResponse], error)) *RunServiceClient_GetActionDetails_Call {
	_c.Call.Return(run)
	return _c
}

// GetRunDetails provides a mock function with given fields: _a0, _a1
func (_m *RunServiceClient) GetRunDetails(_a0 context.Context, _a1 *connect.Request[workflow.GetRunDetailsRequest]) (*connect.Response[workflow.GetRunDetailsResponse], error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for GetRunDetails")
	}

	var r0 *connect.Response[workflow.GetRunDetailsResponse]
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *connect.Request[workflow.GetRunDetailsRequest]) (*connect.Response[workflow.GetRunDetailsResponse], error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *connect.Request[workflow.GetRunDetailsRequest]) *connect.Response[workflow.GetRunDetailsResponse]); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*connect.Response[workflow.GetRunDetailsResponse])
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *connect.Request[workflow.GetRunDetailsRequest]) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RunServiceClient_GetRunDetails_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRunDetails'
type RunServiceClient_GetRunDetails_Call struct {
	*mock.Call
}

// GetRunDetails is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *connect.Request[workflow.GetRunDetailsRequest]
func (_e *RunServiceClient_Expecter) GetRunDetails(_a0 interface{}, _a1 interface{}) *RunServiceClient_GetRunDetails_Call {
	return &RunServiceClient_GetRunDetails_Call{Call: _e.mock.On("GetRunDetails", _a0, _a1)}
}

func (_c *RunServiceClient_GetRunDetails_Call) Run(run func(_a0 context.Context, _a1 *connect.Request[workflow.GetRunDetailsRequest])) *RunServiceClient_GetRunDetails_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*connect.Request[workflow.GetRunDetailsRequest]))
	})
	return _c
}

func (_c *RunServiceClient_GetRunDetails_Call) Return(_a0 *connect.Response[workflow.GetRunDetailsResponse], _a1 error) *RunServiceClient_GetRunDetails_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RunServiceClient_GetRunDetails_Call) RunAndReturn(run func(context.Context, *connect.Request[workflow.GetRunDetailsRequest]) (*connect.Response[workflow.GetRunDetailsResponse], error)) *RunServiceClient_GetRunDetails_Call {
	_c.Call.Return(run)
	return _c
}

// ListActions provides a mock function with given fields: _a0, _a1
func (_m *RunServiceClient) ListActions(_a0 context.Context, _a1 *connect.Request[workflow.ListActionsRequest]) (*connect.Response[workflow.ListActionsResponse], error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for ListActions")
	}

	var r0 *connect.Response[workflow.ListActionsResponse]
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *connect.Request[workflow.ListActionsRequest]) (*connect.Response[workflow.ListActionsResponse], error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *connect.Request[workflow.ListActionsRequest]) *connect.Response[workflow.ListActionsResponse]); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*connect.Response[workflow.ListActionsResponse])
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *connect.Request[workflow.ListActionsRequest]) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RunServiceClient_ListActions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListActions'
type RunServiceClient_ListActions_Call struct {
	*mock.Call
}

// ListActions is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *connect.Request[workflow.ListActionsRequest]
func (_e *RunServiceClient_Expecter) ListActions(_a0 interface{}, _a1 interface{}) *RunServiceClient_ListActions_Call {
	return &RunServiceClient_ListActions_Call{Call: _e.mock.On("ListActions", _a0, _a1)}
}

func (_c *RunServiceClient_ListActions_Call) Run(run func(_a0 context.Context, _a1 *connect.Request[workflow.ListActionsRequest])) *RunServiceClient_ListActions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*connect.Request[workflow.ListActionsRequest]))
	})
	return _c
}

func (_c *RunServiceClient_ListActions_Call) Return(_a0 *connect.Response[workflow.ListActionsResponse], _a1 error) *RunServiceClient_ListActions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RunServiceClient_ListActions_Call) RunAndReturn(run func(context.Context, *connect.Request[workflow.ListActionsRequest]) (*connect.Response[workflow.ListActionsResponse], error)) *RunServiceClient_ListActions_Call {
	_c.Call.Return(run)
	return _c
}

// ListRuns provides a mock function with given fields: _a0, _a1
func (_m *RunServiceClient) ListRuns(_a0 context.Context, _a1 *connect.Request[workflow.ListRunsRequest]) (*connect.Response[workflow.ListRunsResponse], error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for ListRuns")
	}

	var r0 *connect.Response[workflow.ListRunsResponse]
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *connect.Request[workflow.ListRunsRequest]) (*connect.Response[workflow.ListRunsResponse], error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *connect.Request[workflow.ListRunsRequest]) *connect.Response[workflow.ListRunsResponse]); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*connect.Response[workflow.ListRunsResponse])
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *connect.Request[workflow.ListRunsRequest]) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RunServiceClient_ListRuns_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListRuns'
type RunServiceClient_ListRuns_Call struct {
	*mock.Call
}

// ListRuns is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *connect.Request[workflow.ListRunsRequest]
func (_e *RunServiceClient_Expecter) ListRuns(_a0 interface{}, _a1 interface{}) *RunServiceClient_ListRuns_Call {
	return &RunServiceClient_ListRuns_Call{Call: _e.mock.On("ListRuns", _a0, _a1)}
}

func (_c *RunServiceClient_ListRuns_Call) Run(run func(_a0 context.Context, _a1 *connect.Request[workflow.ListRunsRequest])) *RunServiceClient_ListRuns_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*connect.Request[workflow.ListRunsRequest]))
	})
	return _c
}

func (_c *RunServiceClient_ListRuns_Call) Return(_a0 *connect.Response[workflow.ListRunsResponse], _a1 error) *RunServiceClient_ListRuns_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RunServiceClient_ListRuns_Call) RunAndReturn(run func(context.Context, *connect.Request[workflow.ListRunsRequest]) (*connect.Response[workflow.ListRunsResponse], error)) *RunServiceClient_ListRuns_Call {
	_c.Call.Return(run)
	return _c
}

// WatchActionDetails provides a mock function with given fields: _a0, _a1
func (_m *RunServiceClient) WatchActionDetails(_a0 context.Context, _a1 *connect.Request[workflow.WatchActionDetailsRequest]) (*connect.ServerStreamForClient[workflow.WatchActionDetailsResponse], error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for WatchActionDetails")
	}

	var r0 *connect.ServerStreamForClient[workflow.WatchActionDetailsResponse]
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *connect.Request[workflow.WatchActionDetailsRequest]) (*connect.ServerStreamForClient[workflow.WatchActionDetailsResponse], error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *connect.Request[workflow.WatchActionDetailsRequest]) *connect.ServerStreamForClient[workflow.WatchActionDetailsResponse]); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*connect.ServerStreamForClient[workflow.WatchActionDetailsResponse])
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *connect.Request[workflow.WatchActionDetailsRequest]) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RunServiceClient_WatchActionDetails_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WatchActionDetails'
type RunServiceClient_WatchActionDetails_Call struct {
	*mock.Call
}

// WatchActionDetails is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *connect.Request[workflow.WatchActionDetailsRequest]
func (_e *RunServiceClient_Expecter) WatchActionDetails(_a0 interface{}, _a1 interface{}) *RunServiceClient_WatchActionDetails_Call {
	return &RunServiceClient_WatchActionDetails_Call{Call: _e.mock.On("WatchActionDetails", _a0, _a1)}
}

func (_c *RunServiceClient_WatchActionDetails_Call) Run(run func(_a0 context.Context, _a1 *connect.Request[workflow.WatchActionDetailsRequest])) *RunServiceClient_WatchActionDetails_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*connect.Request[workflow.WatchActionDetailsRequest]))
	})
	return _c
}

func (_c *RunServiceClient_WatchActionDetails_Call) Return(_a0 *connect.ServerStreamForClient[workflow.WatchActionDetailsResponse], _a1 error) *RunServiceClient_WatchActionDetails_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RunServiceClient_WatchActionDetails_Call) RunAndReturn(run func(context.Context, *connect.Request[workflow.WatchActionDetailsRequest]) (*connect.ServerStreamForClient[workflow.WatchActionDetailsResponse], error)) *RunServiceClient_WatchActionDetails_Call {
	_c.Call.Return(run)
	return _c
}

// WatchActions provides a mock function with given fields: _a0, _a1
func (_m *RunServiceClient) WatchActions(_a0 context.Context, _a1 *connect.Request[workflow.WatchActionsRequest]) (*connect.ServerStreamForClient[workflow.WatchActionsResponse], error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for WatchActions")
	}

	var r0 *connect.ServerStreamForClient[workflow.WatchActionsResponse]
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *connect.Request[workflow.WatchActionsRequest]) (*connect.ServerStreamForClient[workflow.WatchActionsResponse], error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *connect.Request[workflow.WatchActionsRequest]) *connect.ServerStreamForClient[workflow.WatchActionsResponse]); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*connect.ServerStreamForClient[workflow.WatchActionsResponse])
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *connect.Request[workflow.WatchActionsRequest]) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RunServiceClient_WatchActions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WatchActions'
type RunServiceClient_WatchActions_Call struct {
	*mock.Call
}

// WatchActions is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *connect.Request[workflow.WatchActionsRequest]
func (_e *RunServiceClient_Expecter) WatchActions(_a0 interface{}, _a1 interface{}) *RunServiceClient_WatchActions_Call {
	return &RunServiceClient_WatchActions_Call{Call: _e.mock.On("WatchActions", _a0, _a1)}
}

func (_c *RunServiceClient_WatchActions_Call) Run(run func(_a0 context.Context, _a1 *connect.Request[workflow.WatchActionsRequest])) *RunServiceClient_WatchActions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*connect.Request[workflow.WatchActionsRequest]))
	})
	return _c
}

func (_c *RunServiceClient_WatchActions_Call) Return(_a0 *connect.ServerStreamForClient[workflow.WatchActionsResponse], _a1 error) *RunServiceClient_WatchActions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RunServiceClient_WatchActions_Call) RunAndReturn(run func(context.Context, *connect.Request[workflow.WatchActionsRequest]) (*connect.ServerStreamForClient[workflow.WatchActionsResponse], error)) *RunServiceClient_WatchActions_Call {
	_c.Call.Return(run)
	return _c
}

// WatchClusterEvents provides a mock function with given fields: _a0, _a1
func (_m *RunServiceClient) WatchClusterEvents(_a0 context.Context, _a1 *connect.Request[workflow.WatchClusterEventsRequest]) (*connect.ServerStreamForClient[workflow.WatchClusterEventsResponse], error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for WatchClusterEvents")
	}

	var r0 *connect.ServerStreamForClient[workflow.WatchClusterEventsResponse]
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *connect.Request[workflow.WatchClusterEventsRequest]) (*connect.ServerStreamForClient[workflow.WatchClusterEventsResponse], error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *connect.Request[workflow.WatchClusterEventsRequest]) *connect.ServerStreamForClient[workflow.WatchClusterEventsResponse]); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*connect.ServerStreamForClient[workflow.WatchClusterEventsResponse])
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *connect.Request[workflow.WatchClusterEventsRequest]) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RunServiceClient_WatchClusterEvents_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WatchClusterEvents'
type RunServiceClient_WatchClusterEvents_Call struct {
	*mock.Call
}

// WatchClusterEvents is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *connect.Request[workflow.WatchClusterEventsRequest]
func (_e *RunServiceClient_Expecter) WatchClusterEvents(_a0 interface{}, _a1 interface{}) *RunServiceClient_WatchClusterEvents_Call {
	return &RunServiceClient_WatchClusterEvents_Call{Call: _e.mock.On("WatchClusterEvents", _a0, _a1)}
}

func (_c *RunServiceClient_WatchClusterEvents_Call) Run(run func(_a0 context.Context, _a1 *connect.Request[workflow.WatchClusterEventsRequest])) *RunServiceClient_WatchClusterEvents_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*connect.Request[workflow.WatchClusterEventsRequest]))
	})
	return _c
}

func (_c *RunServiceClient_WatchClusterEvents_Call) Return(_a0 *connect.ServerStreamForClient[workflow.WatchClusterEventsResponse], _a1 error) *RunServiceClient_WatchClusterEvents_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RunServiceClient_WatchClusterEvents_Call) RunAndReturn(run func(context.Context, *connect.Request[workflow.WatchClusterEventsRequest]) (*connect.ServerStreamForClient[workflow.WatchClusterEventsResponse], error)) *RunServiceClient_WatchClusterEvents_Call {
	_c.Call.Return(run)
	return _c
}

// WatchGroups provides a mock function with given fields: _a0, _a1
func (_m *RunServiceClient) WatchGroups(_a0 context.Context, _a1 *connect.Request[workflow.WatchGroupsRequest]) (*connect.ServerStreamForClient[workflow.WatchGroupsResponse], error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for WatchGroups")
	}

	var r0 *connect.ServerStreamForClient[workflow.WatchGroupsResponse]
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *connect.Request[workflow.WatchGroupsRequest]) (*connect.ServerStreamForClient[workflow.WatchGroupsResponse], error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *connect.Request[workflow.WatchGroupsRequest]) *connect.ServerStreamForClient[workflow.WatchGroupsResponse]); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*connect.ServerStreamForClient[workflow.WatchGroupsResponse])
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *connect.Request[workflow.WatchGroupsRequest]) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RunServiceClient_WatchGroups_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WatchGroups'
type RunServiceClient_WatchGroups_Call struct {
	*mock.Call
}

// WatchGroups is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *connect.Request[workflow.WatchGroupsRequest]
func (_e *RunServiceClient_Expecter) WatchGroups(_a0 interface{}, _a1 interface{}) *RunServiceClient_WatchGroups_Call {
	return &RunServiceClient_WatchGroups_Call{Call: _e.mock.On("WatchGroups", _a0, _a1)}
}

func (_c *RunServiceClient_WatchGroups_Call) Run(run func(_a0 context.Context, _a1 *connect.Request[workflow.WatchGroupsRequest])) *RunServiceClient_WatchGroups_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*connect.Request[workflow.WatchGroupsRequest]))
	})
	return _c
}

func (_c *RunServiceClient_WatchGroups_Call) Return(_a0 *connect.ServerStreamForClient[workflow.WatchGroupsResponse], _a1 error) *RunServiceClient_WatchGroups_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RunServiceClient_WatchGroups_Call) RunAndReturn(run func(context.Context, *connect.Request[workflow.WatchGroupsRequest]) (*connect.ServerStreamForClient[workflow.WatchGroupsResponse], error)) *RunServiceClient_WatchGroups_Call {
	_c.Call.Return(run)
	return _c
}

// WatchRunDetails provides a mock function with given fields: _a0, _a1
func (_m *RunServiceClient) WatchRunDetails(_a0 context.Context, _a1 *connect.Request[workflow.WatchRunDetailsRequest]) (*connect.ServerStreamForClient[workflow.WatchRunDetailsResponse], error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for WatchRunDetails")
	}

	var r0 *connect.ServerStreamForClient[workflow.WatchRunDetailsResponse]
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *connect.Request[workflow.WatchRunDetailsRequest]) (*connect.ServerStreamForClient[workflow.WatchRunDetailsResponse], error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *connect.Request[workflow.WatchRunDetailsRequest]) *connect.ServerStreamForClient[workflow.WatchRunDetailsResponse]); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*connect.ServerStreamForClient[workflow.WatchRunDetailsResponse])
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *connect.Request[workflow.WatchRunDetailsRequest]) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RunServiceClient_WatchRunDetails_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WatchRunDetails'
type RunServiceClient_WatchRunDetails_Call struct {
	*mock.Call
}

// WatchRunDetails is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *connect.Request[workflow.WatchRunDetailsRequest]
func (_e *RunServiceClient_Expecter) WatchRunDetails(_a0 interface{}, _a1 interface{}) *RunServiceClient_WatchRunDetails_Call {
	return &RunServiceClient_WatchRunDetails_Call{Call: _e.mock.On("WatchRunDetails", _a0, _a1)}
}

func (_c *RunServiceClient_WatchRunDetails_Call) Run(run func(_a0 context.Context, _a1 *connect.Request[workflow.WatchRunDetailsRequest])) *RunServiceClient_WatchRunDetails_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*connect.Request[workflow.WatchRunDetailsRequest]))
	})
	return _c
}

func (_c *RunServiceClient_WatchRunDetails_Call) Return(_a0 *connect.ServerStreamForClient[workflow.WatchRunDetailsResponse], _a1 error) *RunServiceClient_WatchRunDetails_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RunServiceClient_WatchRunDetails_Call) RunAndReturn(run func(context.Context, *connect.Request[workflow.WatchRunDetailsRequest]) (*connect.ServerStreamForClient[workflow.WatchRunDetailsResponse], error)) *RunServiceClient_WatchRunDetails_Call {
	_c.Call.Return(run)
	return _c
}

// WatchRuns provides a mock function with given fields: _a0, _a1
func (_m *RunServiceClient) WatchRuns(_a0 context.Context, _a1 *connect.Request[workflow.WatchRunsRequest]) (*connect.ServerStreamForClient[workflow.WatchRunsResponse], error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for WatchRuns")
	}

	var r0 *connect.ServerStreamForClient[workflow.WatchRunsResponse]
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *connect.Request[workflow.WatchRunsRequest]) (*connect.ServerStreamForClient[workflow.WatchRunsResponse], error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *connect.Request[workflow.WatchRunsRequest]) *connect.ServerStreamForClient[workflow.WatchRunsResponse]); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*connect.ServerStreamForClient[workflow.WatchRunsResponse])
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *connect.Request[workflow.WatchRunsRequest]) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RunServiceClient_WatchRuns_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WatchRuns'
type RunServiceClient_WatchRuns_Call struct {
	*mock.Call
}

// WatchRuns is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *connect.Request[workflow.WatchRunsRequest]
func (_e *RunServiceClient_Expecter) WatchRuns(_a0 interface{}, _a1 interface{}) *RunServiceClient_WatchRuns_Call {
	return &RunServiceClient_WatchRuns_Call{Call: _e.mock.On("WatchRuns", _a0, _a1)}
}

func (_c *RunServiceClient_WatchRuns_Call) Run(run func(_a0 context.Context, _a1 *connect.Request[workflow.WatchRunsRequest])) *RunServiceClient_WatchRuns_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*connect.Request[workflow.WatchRunsRequest]))
	})
	return _c
}

func (_c *RunServiceClient_WatchRuns_Call) Return(_a0 *connect.ServerStreamForClient[workflow.WatchRunsResponse], _a1 error) *RunServiceClient_WatchRuns_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RunServiceClient_WatchRuns_Call) RunAndReturn(run func(context.Context, *connect.Request[workflow.WatchRunsRequest]) (*connect.ServerStreamForClient[workflow.WatchRunsResponse], error)) *RunServiceClient_WatchRuns_Call {
	_c.Call.Return(run)
	return _c
}

// NewRunServiceClient creates a new instance of RunServiceClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewRunServiceClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *RunServiceClient {
	mock := &RunServiceClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
