// Code generated by mockery. DO NOT EDIT.

package mocks

import (
	context "context"

	connect "connectrpc.com/connect"

	mock "github.com/stretchr/testify/mock"

	workflow "github.com/flyteorg/flyte/v2/gen/go/flyteidl2/workflow"
)

// RunServiceHandler is an autogenerated mock type for the RunServiceHandler type
type RunServiceHandler struct {
	mock.Mock
}

type RunServiceHandler_Expecter struct {
	mock *mock.Mock
}

func (_m *RunServiceHandler) EXPECT() *RunServiceHandler_Expecter {
	return &RunServiceHandler_Expecter{mock: &_m.Mock}
}

// AbortAction provides a mock function with given fields: _a0, _a1
func (_m *RunServiceHandler) AbortAction(_a0 context.Context, _a1 *connect.Request[workflow.AbortActionRequest]) (*connect.Response[workflow.AbortActionResponse], error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for AbortAction")
	}

	var r0 *connect.Response[workflow.AbortActionResponse]
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *connect.Request[workflow.AbortActionRequest]) (*connect.Response[workflow.AbortActionResponse], error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *connect.Request[workflow.AbortActionRequest]) *connect.Response[workflow.AbortActionResponse]); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*connect.Response[workflow.AbortActionResponse])
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *connect.Request[workflow.AbortActionRequest]) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RunServiceHandler_AbortAction_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AbortAction'
type RunServiceHandler_AbortAction_Call struct {
	*mock.Call
}

// AbortAction is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *connect.Request[workflow.AbortActionRequest]
func (_e *RunServiceHandler_Expecter) AbortAction(_a0 interface{}, _a1 interface{}) *RunServiceHandler_AbortAction_Call {
	return &RunServiceHandler_AbortAction_Call{Call: _e.mock.On("AbortAction", _a0, _a1)}
}

func (_c *RunServiceHandler_AbortAction_Call) Run(run func(_a0 context.Context, _a1 *connect.Request[workflow.AbortActionRequest])) *RunServiceHandler_AbortAction_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*connect.Request[workflow.AbortActionRequest]))
	})
	return _c
}

func (_c *RunServiceHandler_AbortAction_Call) Return(_a0 *connect.Response[workflow.AbortActionResponse], _a1 error) *RunServiceHandler_AbortAction_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RunServiceHandler_AbortAction_Call) RunAndReturn(run func(context.Context, *connect.Request[workflow.AbortActionRequest]) (*connect.Response[workflow.AbortActionResponse], error)) *RunServiceHandler_AbortAction_Call {
	_c.Call.Return(run)
	return _c
}

// AbortRun provides a mock function with given fields: _a0, _a1
func (_m *RunServiceHandler) AbortRun(_a0 context.Context, _a1 *connect.Request[workflow.AbortRunRequest]) (*connect.Response[workflow.AbortRunResponse], error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for AbortRun")
	}

	var r0 *connect.Response[workflow.AbortRunResponse]
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *connect.Request[workflow.AbortRunRequest]) (*connect.Response[workflow.AbortRunResponse], error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *connect.Request[workflow.AbortRunRequest]) *connect.Response[workflow.AbortRunResponse]); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*connect.Response[workflow.AbortRunResponse])
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *connect.Request[workflow.AbortRunRequest]) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RunServiceHandler_AbortRun_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AbortRun'
type RunServiceHandler_AbortRun_Call struct {
	*mock.Call
}

// AbortRun is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *connect.Request[workflow.AbortRunRequest]
func (_e *RunServiceHandler_Expecter) AbortRun(_a0 interface{}, _a1 interface{}) *RunServiceHandler_AbortRun_Call {
	return &RunServiceHandler_AbortRun_Call{Call: _e.mock.On("AbortRun", _a0, _a1)}
}

func (_c *RunServiceHandler_AbortRun_Call) Run(run func(_a0 context.Context, _a1 *connect.Request[workflow.AbortRunRequest])) *RunServiceHandler_AbortRun_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*connect.Request[workflow.AbortRunRequest]))
	})
	return _c
}

func (_c *RunServiceHandler_AbortRun_Call) Return(_a0 *connect.Response[workflow.AbortRunResponse], _a1 error) *RunServiceHandler_AbortRun_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RunServiceHandler_AbortRun_Call) RunAndReturn(run func(context.Context, *connect.Request[workflow.AbortRunRequest]) (*connect.Response[workflow.AbortRunResponse], error)) *RunServiceHandler_AbortRun_Call {
	_c.Call.Return(run)
	return _c
}

// CreateRun provides a mock function with given fields: _a0, _a1
func (_m *RunServiceHandler) CreateRun(_a0 context.Context, _a1 *connect.Request[workflow.CreateRunRequest]) (*connect.Response[workflow.CreateRunResponse], error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for CreateRun")
	}

	var r0 *connect.Response[workflow.CreateRunResponse]
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *connect.Request[workflow.CreateRunRequest]) (*connect.Response[workflow.CreateRunResponse], error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *connect.Request[workflow.CreateRunRequest]) *connect.Response[workflow.CreateRunResponse]); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*connect.Response[workflow.CreateRunResponse])
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *connect.Request[workflow.CreateRunRequest]) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RunServiceHandler_CreateRun_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateRun'
type RunServiceHandler_CreateRun_Call struct {
	*mock.Call
}

// CreateRun is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *connect.Request[workflow.CreateRunRequest]
func (_e *RunServiceHandler_Expecter) CreateRun(_a0 interface{}, _a1 interface{}) *RunServiceHandler_CreateRun_Call {
	return &RunServiceHandler_CreateRun_Call{Call: _e.mock.On("CreateRun", _a0, _a1)}
}

func (_c *RunServiceHandler_CreateRun_Call) Run(run func(_a0 context.Context, _a1 *connect.Request[workflow.CreateRunRequest])) *RunServiceHandler_CreateRun_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*connect.Request[workflow.CreateRunRequest]))
	})
	return _c
}

func (_c *RunServiceHandler_CreateRun_Call) Return(_a0 *connect.Response[workflow.CreateRunResponse], _a1 error) *RunServiceHandler_CreateRun_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RunServiceHandler_CreateRun_Call) RunAndReturn(run func(context.Context, *connect.Request[workflow.CreateRunRequest]) (*connect.Response[workflow.CreateRunResponse], error)) *RunServiceHandler_CreateRun_Call {
	_c.Call.Return(run)
	return _c
}

// GetActionData provides a mock function with given fields: _a0, _a1
func (_m *RunServiceHandler) GetActionData(_a0 context.Context, _a1 *connect.Request[workflow.GetActionDataRequest]) (*connect.Response[workflow.GetActionDataResponse], error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for GetActionData")
	}

	var r0 *connect.Response[workflow.GetActionDataResponse]
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *connect.Request[workflow.GetActionDataRequest]) (*connect.Response[workflow.GetActionDataResponse], error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *connect.Request[workflow.GetActionDataRequest]) *connect.Response[workflow.GetActionDataResponse]); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*connect.Response[workflow.GetActionDataResponse])
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *connect.Request[workflow.GetActionDataRequest]) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RunServiceHandler_GetActionData_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetActionData'
type RunServiceHandler_GetActionData_Call struct {
	*mock.Call
}

// GetActionData is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *connect.Request[workflow.GetActionDataRequest]
func (_e *RunServiceHandler_Expecter) GetActionData(_a0 interface{}, _a1 interface{}) *RunServiceHandler_GetActionData_Call {
	return &RunServiceHandler_GetActionData_Call{Call: _e.mock.On("GetActionData", _a0, _a1)}
}

func (_c *RunServiceHandler_GetActionData_Call) Run(run func(_a0 context.Context, _a1 *connect.Request[workflow.GetActionDataRequest])) *RunServiceHandler_GetActionData_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*connect.Request[workflow.GetActionDataRequest]))
	})
	return _c
}

func (_c *RunServiceHandler_GetActionData_Call) Return(_a0 *connect.Response[workflow.GetActionDataResponse], _a1 error) *RunServiceHandler_GetActionData_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RunServiceHandler_GetActionData_Call) RunAndReturn(run func(context.Context, *connect.Request[workflow.GetActionDataRequest]) (*connect.Response[workflow.GetActionDataResponse], error)) *RunServiceHandler_GetActionData_Call {
	_c.Call.Return(run)
	return _c
}

// GetActionDetails provides a mock function with given fields: _a0, _a1
func (_m *RunServiceHandler) GetActionDetails(_a0 context.Context, _a1 *connect.Request[workflow.GetActionDetailsRequest]) (*connect.Response[workflow.GetActionDetailsResponse], error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for GetActionDetails")
	}

	var r0 *connect.Response[workflow.GetActionDetailsResponse]
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *connect.Request[workflow.GetActionDetailsRequest]) (*connect.Response[workflow.GetActionDetailsResponse], error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *connect.Request[workflow.GetActionDetailsRequest]) *connect.Response[workflow.GetActionDetailsResponse]); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*connect.Response[workflow.GetActionDetailsResponse])
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *connect.Request[workflow.GetActionDetailsRequest]) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RunServiceHandler_GetActionDetails_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetActionDetails'
type RunServiceHandler_GetActionDetails_Call struct {
	*mock.Call
}

// GetActionDetails is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *connect.Request[workflow.GetActionDetailsRequest]
func (_e *RunServiceHandler_Expecter) GetActionDetails(_a0 interface{}, _a1 interface{}) *RunServiceHandler_GetActionDetails_Call {
	return &RunServiceHandler_GetActionDetails_Call{Call: _e.mock.On("GetActionDetails", _a0, _a1)}
}

func (_c *RunServiceHandler_GetActionDetails_Call) Run(run func(_a0 context.Context, _a1 *connect.Request[workflow.GetActionDetailsRequest])) *RunServiceHandler_GetActionDetails_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*connect.Request[workflow.GetActionDetailsRequest]))
	})
	return _c
}

func (_c *RunServiceHandler_GetActionDetails_Call) Return(_a0 *connect.Response[workflow.GetActionDetailsResponse], _a1 error) *RunServiceHandler_GetActionDetails_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RunServiceHandler_GetActionDetails_Call) RunAndReturn(run func(context.Context, *connect.Request[workflow.GetActionDetailsRequest]) (*connect.Response[workflow.GetActionDetailsResponse], error)) *RunServiceHandler_GetActionDetails_Call {
	_c.Call.Return(run)
	return _c
}

// GetRunDetails provides a mock function with given fields: _a0, _a1
func (_m *RunServiceHandler) GetRunDetails(_a0 context.Context, _a1 *connect.Request[workflow.GetRunDetailsRequest]) (*connect.Response[workflow.GetRunDetailsResponse], error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for GetRunDetails")
	}

	var r0 *connect.Response[workflow.GetRunDetailsResponse]
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *connect.Request[workflow.GetRunDetailsRequest]) (*connect.Response[workflow.GetRunDetailsResponse], error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *connect.Request[workflow.GetRunDetailsRequest]) *connect.Response[workflow.GetRunDetailsResponse]); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*connect.Response[workflow.GetRunDetailsResponse])
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *connect.Request[workflow.GetRunDetailsRequest]) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RunServiceHandler_GetRunDetails_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetRunDetails'
type RunServiceHandler_GetRunDetails_Call struct {
	*mock.Call
}

// GetRunDetails is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *connect.Request[workflow.GetRunDetailsRequest]
func (_e *RunServiceHandler_Expecter) GetRunDetails(_a0 interface{}, _a1 interface{}) *RunServiceHandler_GetRunDetails_Call {
	return &RunServiceHandler_GetRunDetails_Call{Call: _e.mock.On("GetRunDetails", _a0, _a1)}
}

func (_c *RunServiceHandler_GetRunDetails_Call) Run(run func(_a0 context.Context, _a1 *connect.Request[workflow.GetRunDetailsRequest])) *RunServiceHandler_GetRunDetails_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*connect.Request[workflow.GetRunDetailsRequest]))
	})
	return _c
}

func (_c *RunServiceHandler_GetRunDetails_Call) Return(_a0 *connect.Response[workflow.GetRunDetailsResponse], _a1 error) *RunServiceHandler_GetRunDetails_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RunServiceHandler_GetRunDetails_Call) RunAndReturn(run func(context.Context, *connect.Request[workflow.GetRunDetailsRequest]) (*connect.Response[workflow.GetRunDetailsResponse], error)) *RunServiceHandler_GetRunDetails_Call {
	_c.Call.Return(run)
	return _c
}

// ListActions provides a mock function with given fields: _a0, _a1
func (_m *RunServiceHandler) ListActions(_a0 context.Context, _a1 *connect.Request[workflow.ListActionsRequest]) (*connect.Response[workflow.ListActionsResponse], error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for ListActions")
	}

	var r0 *connect.Response[workflow.ListActionsResponse]
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *connect.Request[workflow.ListActionsRequest]) (*connect.Response[workflow.ListActionsResponse], error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *connect.Request[workflow.ListActionsRequest]) *connect.Response[workflow.ListActionsResponse]); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*connect.Response[workflow.ListActionsResponse])
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *connect.Request[workflow.ListActionsRequest]) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RunServiceHandler_ListActions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListActions'
type RunServiceHandler_ListActions_Call struct {
	*mock.Call
}

// ListActions is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *connect.Request[workflow.ListActionsRequest]
func (_e *RunServiceHandler_Expecter) ListActions(_a0 interface{}, _a1 interface{}) *RunServiceHandler_ListActions_Call {
	return &RunServiceHandler_ListActions_Call{Call: _e.mock.On("ListActions", _a0, _a1)}
}

func (_c *RunServiceHandler_ListActions_Call) Run(run func(_a0 context.Context, _a1 *connect.Request[workflow.ListActionsRequest])) *RunServiceHandler_ListActions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*connect.Request[workflow.ListActionsRequest]))
	})
	return _c
}

func (_c *RunServiceHandler_ListActions_Call) Return(_a0 *connect.Response[workflow.ListActionsResponse], _a1 error) *RunServiceHandler_ListActions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RunServiceHandler_ListActions_Call) RunAndReturn(run func(context.Context, *connect.Request[workflow.ListActionsRequest]) (*connect.Response[workflow.ListActionsResponse], error)) *RunServiceHandler_ListActions_Call {
	_c.Call.Return(run)
	return _c
}

// ListRuns provides a mock function with given fields: _a0, _a1
func (_m *RunServiceHandler) ListRuns(_a0 context.Context, _a1 *connect.Request[workflow.ListRunsRequest]) (*connect.Response[workflow.ListRunsResponse], error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for ListRuns")
	}

	var r0 *connect.Response[workflow.ListRunsResponse]
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *connect.Request[workflow.ListRunsRequest]) (*connect.Response[workflow.ListRunsResponse], error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *connect.Request[workflow.ListRunsRequest]) *connect.Response[workflow.ListRunsResponse]); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*connect.Response[workflow.ListRunsResponse])
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *connect.Request[workflow.ListRunsRequest]) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RunServiceHandler_ListRuns_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListRuns'
type RunServiceHandler_ListRuns_Call struct {
	*mock.Call
}

// ListRuns is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *connect.Request[workflow.ListRunsRequest]
func (_e *RunServiceHandler_Expecter) ListRuns(_a0 interface{}, _a1 interface{}) *RunServiceHandler_ListRuns_Call {
	return &RunServiceHandler_ListRuns_Call{Call: _e.mock.On("ListRuns", _a0, _a1)}
}

func (_c *RunServiceHandler_ListRuns_Call) Run(run func(_a0 context.Context, _a1 *connect.Request[workflow.ListRunsRequest])) *RunServiceHandler_ListRuns_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*connect.Request[workflow.ListRunsRequest]))
	})
	return _c
}

func (_c *RunServiceHandler_ListRuns_Call) Return(_a0 *connect.Response[workflow.ListRunsResponse], _a1 error) *RunServiceHandler_ListRuns_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RunServiceHandler_ListRuns_Call) RunAndReturn(run func(context.Context, *connect.Request[workflow.ListRunsRequest]) (*connect.Response[workflow.ListRunsResponse], error)) *RunServiceHandler_ListRuns_Call {
	_c.Call.Return(run)
	return _c
}

// WatchActionDetails provides a mock function with given fields: _a0, _a1, _a2
func (_m *RunServiceHandler) WatchActionDetails(_a0 context.Context, _a1 *connect.Request[workflow.WatchActionDetailsRequest], _a2 *connect.ServerStream[workflow.WatchActionDetailsResponse]) error {
	ret := _m.Called(_a0, _a1, _a2)

	if len(ret) == 0 {
		panic("no return value specified for WatchActionDetails")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *connect.Request[workflow.WatchActionDetailsRequest], *connect.ServerStream[workflow.WatchActionDetailsResponse]) error); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RunServiceHandler_WatchActionDetails_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WatchActionDetails'
type RunServiceHandler_WatchActionDetails_Call struct {
	*mock.Call
}

// WatchActionDetails is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *connect.Request[workflow.WatchActionDetailsRequest]
//   - _a2 *connect.ServerStream[workflow.WatchActionDetailsResponse]
func (_e *RunServiceHandler_Expecter) WatchActionDetails(_a0 interface{}, _a1 interface{}, _a2 interface{}) *RunServiceHandler_WatchActionDetails_Call {
	return &RunServiceHandler_WatchActionDetails_Call{Call: _e.mock.On("WatchActionDetails", _a0, _a1, _a2)}
}

func (_c *RunServiceHandler_WatchActionDetails_Call) Run(run func(_a0 context.Context, _a1 *connect.Request[workflow.WatchActionDetailsRequest], _a2 *connect.ServerStream[workflow.WatchActionDetailsResponse])) *RunServiceHandler_WatchActionDetails_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*connect.Request[workflow.WatchActionDetailsRequest]), args[2].(*connect.ServerStream[workflow.WatchActionDetailsResponse]))
	})
	return _c
}

func (_c *RunServiceHandler_WatchActionDetails_Call) Return(_a0 error) *RunServiceHandler_WatchActionDetails_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *RunServiceHandler_WatchActionDetails_Call) RunAndReturn(run func(context.Context, *connect.Request[workflow.WatchActionDetailsRequest], *connect.ServerStream[workflow.WatchActionDetailsResponse]) error) *RunServiceHandler_WatchActionDetails_Call {
	_c.Call.Return(run)
	return _c
}

// WatchActions provides a mock function with given fields: _a0, _a1, _a2
func (_m *RunServiceHandler) WatchActions(_a0 context.Context, _a1 *connect.Request[workflow.WatchActionsRequest], _a2 *connect.ServerStream[workflow.WatchActionsResponse]) error {
	ret := _m.Called(_a0, _a1, _a2)

	if len(ret) == 0 {
		panic("no return value specified for WatchActions")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *connect.Request[workflow.WatchActionsRequest], *connect.ServerStream[workflow.WatchActionsResponse]) error); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RunServiceHandler_WatchActions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WatchActions'
type RunServiceHandler_WatchActions_Call struct {
	*mock.Call
}

// WatchActions is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *connect.Request[workflow.WatchActionsRequest]
//   - _a2 *connect.ServerStream[workflow.WatchActionsResponse]
func (_e *RunServiceHandler_Expecter) WatchActions(_a0 interface{}, _a1 interface{}, _a2 interface{}) *RunServiceHandler_WatchActions_Call {
	return &RunServiceHandler_WatchActions_Call{Call: _e.mock.On("WatchActions", _a0, _a1, _a2)}
}

func (_c *RunServiceHandler_WatchActions_Call) Run(run func(_a0 context.Context, _a1 *connect.Request[workflow.WatchActionsRequest], _a2 *connect.ServerStream[workflow.WatchActionsResponse])) *RunServiceHandler_WatchActions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*connect.Request[workflow.WatchActionsRequest]), args[2].(*connect.ServerStream[workflow.WatchActionsResponse]))
	})
	return _c
}

func (_c *RunServiceHandler_WatchActions_Call) Return(_a0 error) *RunServiceHandler_WatchActions_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *RunServiceHandler_WatchActions_Call) RunAndReturn(run func(context.Context, *connect.Request[workflow.WatchActionsRequest], *connect.ServerStream[workflow.WatchActionsResponse]) error) *RunServiceHandler_WatchActions_Call {
	_c.Call.Return(run)
	return _c
}

// WatchClusterEvents provides a mock function with given fields: _a0, _a1, _a2
func (_m *RunServiceHandler) WatchClusterEvents(_a0 context.Context, _a1 *connect.Request[workflow.WatchClusterEventsRequest], _a2 *connect.ServerStream[workflow.WatchClusterEventsResponse]) error {
	ret := _m.Called(_a0, _a1, _a2)

	if len(ret) == 0 {
		panic("no return value specified for WatchClusterEvents")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *connect.Request[workflow.WatchClusterEventsRequest], *connect.ServerStream[workflow.WatchClusterEventsResponse]) error); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RunServiceHandler_WatchClusterEvents_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WatchClusterEvents'
type RunServiceHandler_WatchClusterEvents_Call struct {
	*mock.Call
}

// WatchClusterEvents is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *connect.Request[workflow.WatchClusterEventsRequest]
//   - _a2 *connect.ServerStream[workflow.WatchClusterEventsResponse]
func (_e *RunServiceHandler_Expecter) WatchClusterEvents(_a0 interface{}, _a1 interface{}, _a2 interface{}) *RunServiceHandler_WatchClusterEvents_Call {
	return &RunServiceHandler_WatchClusterEvents_Call{Call: _e.mock.On("WatchClusterEvents", _a0, _a1, _a2)}
}

func (_c *RunServiceHandler_WatchClusterEvents_Call) Run(run func(_a0 context.Context, _a1 *connect.Request[workflow.WatchClusterEventsRequest], _a2 *connect.ServerStream[workflow.WatchClusterEventsResponse])) *RunServiceHandler_WatchClusterEvents_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*connect.Request[workflow.WatchClusterEventsRequest]), args[2].(*connect.ServerStream[workflow.WatchClusterEventsResponse]))
	})
	return _c
}

func (_c *RunServiceHandler_WatchClusterEvents_Call) Return(_a0 error) *RunServiceHandler_WatchClusterEvents_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *RunServiceHandler_WatchClusterEvents_Call) RunAndReturn(run func(context.Context, *connect.Request[workflow.WatchClusterEventsRequest], *connect.ServerStream[workflow.WatchClusterEventsResponse]) error) *RunServiceHandler_WatchClusterEvents_Call {
	_c.Call.Return(run)
	return _c
}

// WatchGroups provides a mock function with given fields: _a0, _a1, _a2
func (_m *RunServiceHandler) WatchGroups(_a0 context.Context, _a1 *connect.Request[workflow.WatchGroupsRequest], _a2 *connect.ServerStream[workflow.WatchGroupsResponse]) error {
	ret := _m.Called(_a0, _a1, _a2)

	if len(ret) == 0 {
		panic("no return value specified for WatchGroups")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *connect.Request[workflow.WatchGroupsRequest], *connect.ServerStream[workflow.WatchGroupsResponse]) error); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RunServiceHandler_WatchGroups_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WatchGroups'
type RunServiceHandler_WatchGroups_Call struct {
	*mock.Call
}

// WatchGroups is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *connect.Request[workflow.WatchGroupsRequest]
//   - _a2 *connect.ServerStream[workflow.WatchGroupsResponse]
func (_e *RunServiceHandler_Expecter) WatchGroups(_a0 interface{}, _a1 interface{}, _a2 interface{}) *RunServiceHandler_WatchGroups_Call {
	return &RunServiceHandler_WatchGroups_Call{Call: _e.mock.On("WatchGroups", _a0, _a1, _a2)}
}

func (_c *RunServiceHandler_WatchGroups_Call) Run(run func(_a0 context.Context, _a1 *connect.Request[workflow.WatchGroupsRequest], _a2 *connect.ServerStream[workflow.WatchGroupsResponse])) *RunServiceHandler_WatchGroups_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*connect.Request[workflow.WatchGroupsRequest]), args[2].(*connect.ServerStream[workflow.WatchGroupsResponse]))
	})
	return _c
}

func (_c *RunServiceHandler_WatchGroups_Call) Return(_a0 error) *RunServiceHandler_WatchGroups_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *RunServiceHandler_WatchGroups_Call) RunAndReturn(run func(context.Context, *connect.Request[workflow.WatchGroupsRequest], *connect.ServerStream[workflow.WatchGroupsResponse]) error) *RunServiceHandler_WatchGroups_Call {
	_c.Call.Return(run)
	return _c
}

// WatchRunDetails provides a mock function with given fields: _a0, _a1, _a2
func (_m *RunServiceHandler) WatchRunDetails(_a0 context.Context, _a1 *connect.Request[workflow.WatchRunDetailsRequest], _a2 *connect.ServerStream[workflow.WatchRunDetailsResponse]) error {
	ret := _m.Called(_a0, _a1, _a2)

	if len(ret) == 0 {
		panic("no return value specified for WatchRunDetails")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *connect.Request[workflow.WatchRunDetailsRequest], *connect.ServerStream[workflow.WatchRunDetailsResponse]) error); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RunServiceHandler_WatchRunDetails_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WatchRunDetails'
type RunServiceHandler_WatchRunDetails_Call struct {
	*mock.Call
}

// WatchRunDetails is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *connect.Request[workflow.WatchRunDetailsRequest]
//   - _a2 *connect.ServerStream[workflow.WatchRunDetailsResponse]
func (_e *RunServiceHandler_Expecter) WatchRunDetails(_a0 interface{}, _a1 interface{}, _a2 interface{}) *RunServiceHandler_WatchRunDetails_Call {
	return &RunServiceHandler_WatchRunDetails_Call{Call: _e.mock.On("WatchRunDetails", _a0, _a1, _a2)}
}

func (_c *RunServiceHandler_WatchRunDetails_Call) Run(run func(_a0 context.Context, _a1 *connect.Request[workflow.WatchRunDetailsRequest], _a2 *connect.ServerStream[workflow.WatchRunDetailsResponse])) *RunServiceHandler_WatchRunDetails_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*connect.Request[workflow.WatchRunDetailsRequest]), args[2].(*connect.ServerStream[workflow.WatchRunDetailsResponse]))
	})
	return _c
}

func (_c *RunServiceHandler_WatchRunDetails_Call) Return(_a0 error) *RunServiceHandler_WatchRunDetails_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *RunServiceHandler_WatchRunDetails_Call) RunAndReturn(run func(context.Context, *connect.Request[workflow.WatchRunDetailsRequest], *connect.ServerStream[workflow.WatchRunDetailsResponse]) error) *RunServiceHandler_WatchRunDetails_Call {
	_c.Call.Return(run)
	return _c
}

// WatchRuns provides a mock function with given fields: _a0, _a1, _a2
func (_m *RunServiceHandler) WatchRuns(_a0 context.Context, _a1 *connect.Request[workflow.WatchRunsRequest], _a2 *connect.ServerStream[workflow.WatchRunsResponse]) error {
	ret := _m.Called(_a0, _a1, _a2)

	if len(ret) == 0 {
		panic("no return value specified for WatchRuns")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *connect.Request[workflow.WatchRunsRequest], *connect.ServerStream[workflow.WatchRunsResponse]) error); ok {
		r0 = rf(_a0, _a1, _a2)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RunServiceHandler_WatchRuns_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'WatchRuns'
type RunServiceHandler_WatchRuns_Call struct {
	*mock.Call
}

// WatchRuns is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 *connect.Request[workflow.WatchRunsRequest]
//   - _a2 *connect.ServerStream[workflow.WatchRunsResponse]
func (_e *RunServiceHandler_Expecter) WatchRuns(_a0 interface{}, _a1 interface{}, _a2 interface{}) *RunServiceHandler_WatchRuns_Call {
	return &RunServiceHandler_WatchRuns_Call{Call: _e.mock.On("WatchRuns", _a0, _a1, _a2)}
}

func (_c *RunServiceHandler_WatchRuns_Call) Run(run func(_a0 context.Context, _a1 *connect.Request[workflow.WatchRunsRequest], _a2 *connect.ServerStream[workflow.WatchRunsResponse])) *RunServiceHandler_WatchRuns_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*connect.Request[workflow.WatchRunsRequest]), args[2].(*connect.ServerStream[workflow.WatchRunsResponse]))
	})
	return _c
}

func (_c *RunServiceHandler_WatchRuns_Call) Return(_a0 error) *RunServiceHandler_WatchRuns_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *RunServiceHandler_WatchRuns_Call) RunAndReturn(run func(context.Context, *connect.Request[workflow.WatchRunsRequest], *connect.ServerStream[workflow.WatchRunsResponse]) error) *RunServiceHandler_WatchRuns_Call {
	_c.Call.Return(run)
	return _c
}

// NewRunServiceHandler creates a new instance of RunServiceHandler. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewRunServiceHandler(t interface {
	mock.TestingT
	Cleanup(func())
}) *RunServiceHandler {
	mock := &RunServiceHandler{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
