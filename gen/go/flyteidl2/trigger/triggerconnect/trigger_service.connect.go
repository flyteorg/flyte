// Code generated by protoc-gen-connect-go. DO NOT EDIT.
//
// Source: flyteidl2/trigger/trigger_service.proto

package triggerconnect

import (
	connect "connectrpc.com/connect"
	context "context"
	errors "errors"
	trigger "github.com/flyteorg/flyte/v2/gen/go/flyteidl2/trigger"
	http "net/http"
	strings "strings"
)

// This is a compile-time assertion to ensure that this generated file and the connect package are
// compatible. If you get a compiler error that this constant is not defined, this code was
// generated with a version of connect newer than the one compiled into your binary. You can fix the
// problem by either regenerating this code with an older version of connect or updating the connect
// version compiled into your binary.
const _ = connect.IsAtLeastVersion1_13_0

const (
	// TriggerServiceName is the fully-qualified name of the TriggerService service.
	TriggerServiceName = "flyteidl2.trigger.TriggerService"
)

// These constants are the fully-qualified names of the RPCs defined in this package. They're
// exposed at runtime as Spec.Procedure and as the final two segments of the HTTP route.
//
// Note that these are different from the fully-qualified method names used by
// google.golang.org/protobuf/reflect/protoreflect. To convert from these constants to
// reflection-formatted method names, remove the leading slash and convert the remaining slash to a
// period.
const (
	// TriggerServiceDeployTriggerProcedure is the fully-qualified name of the TriggerService's
	// DeployTrigger RPC.
	TriggerServiceDeployTriggerProcedure = "/flyteidl2.trigger.TriggerService/DeployTrigger"
	// TriggerServiceGetTriggerDetailsProcedure is the fully-qualified name of the TriggerService's
	// GetTriggerDetails RPC.
	TriggerServiceGetTriggerDetailsProcedure = "/flyteidl2.trigger.TriggerService/GetTriggerDetails"
	// TriggerServiceGetTriggerRevisionDetailsProcedure is the fully-qualified name of the
	// TriggerService's GetTriggerRevisionDetails RPC.
	TriggerServiceGetTriggerRevisionDetailsProcedure = "/flyteidl2.trigger.TriggerService/GetTriggerRevisionDetails"
	// TriggerServiceListTriggersProcedure is the fully-qualified name of the TriggerService's
	// ListTriggers RPC.
	TriggerServiceListTriggersProcedure = "/flyteidl2.trigger.TriggerService/ListTriggers"
	// TriggerServiceGetTriggerRevisionHistoryProcedure is the fully-qualified name of the
	// TriggerService's GetTriggerRevisionHistory RPC.
	TriggerServiceGetTriggerRevisionHistoryProcedure = "/flyteidl2.trigger.TriggerService/GetTriggerRevisionHistory"
	// TriggerServiceUpdateTriggersProcedure is the fully-qualified name of the TriggerService's
	// UpdateTriggers RPC.
	TriggerServiceUpdateTriggersProcedure = "/flyteidl2.trigger.TriggerService/UpdateTriggers"
	// TriggerServiceDeleteTriggersProcedure is the fully-qualified name of the TriggerService's
	// DeleteTriggers RPC.
	TriggerServiceDeleteTriggersProcedure = "/flyteidl2.trigger.TriggerService/DeleteTriggers"
)

// These variables are the protoreflect.Descriptor objects for the RPCs defined in this package.
var (
	triggerServiceServiceDescriptor                         = trigger.File_flyteidl2_trigger_trigger_service_proto.Services().ByName("TriggerService")
	triggerServiceDeployTriggerMethodDescriptor             = triggerServiceServiceDescriptor.Methods().ByName("DeployTrigger")
	triggerServiceGetTriggerDetailsMethodDescriptor         = triggerServiceServiceDescriptor.Methods().ByName("GetTriggerDetails")
	triggerServiceGetTriggerRevisionDetailsMethodDescriptor = triggerServiceServiceDescriptor.Methods().ByName("GetTriggerRevisionDetails")
	triggerServiceListTriggersMethodDescriptor              = triggerServiceServiceDescriptor.Methods().ByName("ListTriggers")
	triggerServiceGetTriggerRevisionHistoryMethodDescriptor = triggerServiceServiceDescriptor.Methods().ByName("GetTriggerRevisionHistory")
	triggerServiceUpdateTriggersMethodDescriptor            = triggerServiceServiceDescriptor.Methods().ByName("UpdateTriggers")
	triggerServiceDeleteTriggersMethodDescriptor            = triggerServiceServiceDescriptor.Methods().ByName("DeleteTriggers")
)

// TriggerServiceClient is a client for the flyteidl2.trigger.TriggerService service.
type TriggerServiceClient interface {
	// Create if trigger didn't exist previously.
	// Update if it already exists.
	// Re-create(or undelete) if it was soft-deleted.
	// Client must fetch the latest trigger in order to obtain the latest `trigger.id.revision`.
	// If trigger is not found, client can set `trigger.id.revision` to 1, it is ignored and set automatically by backend.
	// If trigger is found, client should set `trigger.id.revision` to the <latest>.
	// Backend validates that version is the latest and creates a new revision of the trigger.
	// Otherwise, operation is rejected(optimistic locking) and client must re-fetch trigger again.
	DeployTrigger(context.Context, *connect.Request[trigger.DeployTriggerRequest]) (*connect.Response[trigger.DeployTriggerResponse], error)
	// Get detailed info about the latest trigger revision
	GetTriggerDetails(context.Context, *connect.Request[trigger.GetTriggerDetailsRequest]) (*connect.Response[trigger.GetTriggerDetailsResponse], error)
	// Get detailed info about a specific trigger revision
	GetTriggerRevisionDetails(context.Context, *connect.Request[trigger.GetTriggerRevisionDetailsRequest]) (*connect.Response[trigger.GetTriggerRevisionDetailsResponse], error)
	// List basic info about triggers based on various filtering and sorting rules.
	ListTriggers(context.Context, *connect.Request[trigger.ListTriggersRequest]) (*connect.Response[trigger.ListTriggersResponse], error)
	// GetTriggerRevisionHistory returns all revisions for a given trigger
	GetTriggerRevisionHistory(context.Context, *connect.Request[trigger.GetTriggerRevisionHistoryRequest]) (*connect.Response[trigger.GetTriggerRevisionHistoryResponse], error)
	// Update some trigger spec fields for multiple triggers at once
	UpdateTriggers(context.Context, *connect.Request[trigger.UpdateTriggersRequest]) (*connect.Response[trigger.UpdateTriggersResponse], error)
	// Soft-delete multiple triggers at once.
	DeleteTriggers(context.Context, *connect.Request[trigger.DeleteTriggersRequest]) (*connect.Response[trigger.DeleteTriggersResponse], error)
}

// NewTriggerServiceClient constructs a client for the flyteidl2.trigger.TriggerService service. By
// default, it uses the Connect protocol with the binary Protobuf Codec, asks for gzipped responses,
// and sends uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the
// connect.WithGRPC() or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewTriggerServiceClient(httpClient connect.HTTPClient, baseURL string, opts ...connect.ClientOption) TriggerServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &triggerServiceClient{
		deployTrigger: connect.NewClient[trigger.DeployTriggerRequest, trigger.DeployTriggerResponse](
			httpClient,
			baseURL+TriggerServiceDeployTriggerProcedure,
			connect.WithSchema(triggerServiceDeployTriggerMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		getTriggerDetails: connect.NewClient[trigger.GetTriggerDetailsRequest, trigger.GetTriggerDetailsResponse](
			httpClient,
			baseURL+TriggerServiceGetTriggerDetailsProcedure,
			connect.WithSchema(triggerServiceGetTriggerDetailsMethodDescriptor),
			connect.WithIdempotency(connect.IdempotencyNoSideEffects),
			connect.WithClientOptions(opts...),
		),
		getTriggerRevisionDetails: connect.NewClient[trigger.GetTriggerRevisionDetailsRequest, trigger.GetTriggerRevisionDetailsResponse](
			httpClient,
			baseURL+TriggerServiceGetTriggerRevisionDetailsProcedure,
			connect.WithSchema(triggerServiceGetTriggerRevisionDetailsMethodDescriptor),
			connect.WithIdempotency(connect.IdempotencyNoSideEffects),
			connect.WithClientOptions(opts...),
		),
		listTriggers: connect.NewClient[trigger.ListTriggersRequest, trigger.ListTriggersResponse](
			httpClient,
			baseURL+TriggerServiceListTriggersProcedure,
			connect.WithSchema(triggerServiceListTriggersMethodDescriptor),
			connect.WithIdempotency(connect.IdempotencyNoSideEffects),
			connect.WithClientOptions(opts...),
		),
		getTriggerRevisionHistory: connect.NewClient[trigger.GetTriggerRevisionHistoryRequest, trigger.GetTriggerRevisionHistoryResponse](
			httpClient,
			baseURL+TriggerServiceGetTriggerRevisionHistoryProcedure,
			connect.WithSchema(triggerServiceGetTriggerRevisionHistoryMethodDescriptor),
			connect.WithIdempotency(connect.IdempotencyNoSideEffects),
			connect.WithClientOptions(opts...),
		),
		updateTriggers: connect.NewClient[trigger.UpdateTriggersRequest, trigger.UpdateTriggersResponse](
			httpClient,
			baseURL+TriggerServiceUpdateTriggersProcedure,
			connect.WithSchema(triggerServiceUpdateTriggersMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
		deleteTriggers: connect.NewClient[trigger.DeleteTriggersRequest, trigger.DeleteTriggersResponse](
			httpClient,
			baseURL+TriggerServiceDeleteTriggersProcedure,
			connect.WithSchema(triggerServiceDeleteTriggersMethodDescriptor),
			connect.WithClientOptions(opts...),
		),
	}
}

// triggerServiceClient implements TriggerServiceClient.
type triggerServiceClient struct {
	deployTrigger             *connect.Client[trigger.DeployTriggerRequest, trigger.DeployTriggerResponse]
	getTriggerDetails         *connect.Client[trigger.GetTriggerDetailsRequest, trigger.GetTriggerDetailsResponse]
	getTriggerRevisionDetails *connect.Client[trigger.GetTriggerRevisionDetailsRequest, trigger.GetTriggerRevisionDetailsResponse]
	listTriggers              *connect.Client[trigger.ListTriggersRequest, trigger.ListTriggersResponse]
	getTriggerRevisionHistory *connect.Client[trigger.GetTriggerRevisionHistoryRequest, trigger.GetTriggerRevisionHistoryResponse]
	updateTriggers            *connect.Client[trigger.UpdateTriggersRequest, trigger.UpdateTriggersResponse]
	deleteTriggers            *connect.Client[trigger.DeleteTriggersRequest, trigger.DeleteTriggersResponse]
}

// DeployTrigger calls flyteidl2.trigger.TriggerService.DeployTrigger.
func (c *triggerServiceClient) DeployTrigger(ctx context.Context, req *connect.Request[trigger.DeployTriggerRequest]) (*connect.Response[trigger.DeployTriggerResponse], error) {
	return c.deployTrigger.CallUnary(ctx, req)
}

// GetTriggerDetails calls flyteidl2.trigger.TriggerService.GetTriggerDetails.
func (c *triggerServiceClient) GetTriggerDetails(ctx context.Context, req *connect.Request[trigger.GetTriggerDetailsRequest]) (*connect.Response[trigger.GetTriggerDetailsResponse], error) {
	return c.getTriggerDetails.CallUnary(ctx, req)
}

// GetTriggerRevisionDetails calls flyteidl2.trigger.TriggerService.GetTriggerRevisionDetails.
func (c *triggerServiceClient) GetTriggerRevisionDetails(ctx context.Context, req *connect.Request[trigger.GetTriggerRevisionDetailsRequest]) (*connect.Response[trigger.GetTriggerRevisionDetailsResponse], error) {
	return c.getTriggerRevisionDetails.CallUnary(ctx, req)
}

// ListTriggers calls flyteidl2.trigger.TriggerService.ListTriggers.
func (c *triggerServiceClient) ListTriggers(ctx context.Context, req *connect.Request[trigger.ListTriggersRequest]) (*connect.Response[trigger.ListTriggersResponse], error) {
	return c.listTriggers.CallUnary(ctx, req)
}

// GetTriggerRevisionHistory calls flyteidl2.trigger.TriggerService.GetTriggerRevisionHistory.
func (c *triggerServiceClient) GetTriggerRevisionHistory(ctx context.Context, req *connect.Request[trigger.GetTriggerRevisionHistoryRequest]) (*connect.Response[trigger.GetTriggerRevisionHistoryResponse], error) {
	return c.getTriggerRevisionHistory.CallUnary(ctx, req)
}

// UpdateTriggers calls flyteidl2.trigger.TriggerService.UpdateTriggers.
func (c *triggerServiceClient) UpdateTriggers(ctx context.Context, req *connect.Request[trigger.UpdateTriggersRequest]) (*connect.Response[trigger.UpdateTriggersResponse], error) {
	return c.updateTriggers.CallUnary(ctx, req)
}

// DeleteTriggers calls flyteidl2.trigger.TriggerService.DeleteTriggers.
func (c *triggerServiceClient) DeleteTriggers(ctx context.Context, req *connect.Request[trigger.DeleteTriggersRequest]) (*connect.Response[trigger.DeleteTriggersResponse], error) {
	return c.deleteTriggers.CallUnary(ctx, req)
}

// TriggerServiceHandler is an implementation of the flyteidl2.trigger.TriggerService service.
type TriggerServiceHandler interface {
	// Create if trigger didn't exist previously.
	// Update if it already exists.
	// Re-create(or undelete) if it was soft-deleted.
	// Client must fetch the latest trigger in order to obtain the latest `trigger.id.revision`.
	// If trigger is not found, client can set `trigger.id.revision` to 1, it is ignored and set automatically by backend.
	// If trigger is found, client should set `trigger.id.revision` to the <latest>.
	// Backend validates that version is the latest and creates a new revision of the trigger.
	// Otherwise, operation is rejected(optimistic locking) and client must re-fetch trigger again.
	DeployTrigger(context.Context, *connect.Request[trigger.DeployTriggerRequest]) (*connect.Response[trigger.DeployTriggerResponse], error)
	// Get detailed info about the latest trigger revision
	GetTriggerDetails(context.Context, *connect.Request[trigger.GetTriggerDetailsRequest]) (*connect.Response[trigger.GetTriggerDetailsResponse], error)
	// Get detailed info about a specific trigger revision
	GetTriggerRevisionDetails(context.Context, *connect.Request[trigger.GetTriggerRevisionDetailsRequest]) (*connect.Response[trigger.GetTriggerRevisionDetailsResponse], error)
	// List basic info about triggers based on various filtering and sorting rules.
	ListTriggers(context.Context, *connect.Request[trigger.ListTriggersRequest]) (*connect.Response[trigger.ListTriggersResponse], error)
	// GetTriggerRevisionHistory returns all revisions for a given trigger
	GetTriggerRevisionHistory(context.Context, *connect.Request[trigger.GetTriggerRevisionHistoryRequest]) (*connect.Response[trigger.GetTriggerRevisionHistoryResponse], error)
	// Update some trigger spec fields for multiple triggers at once
	UpdateTriggers(context.Context, *connect.Request[trigger.UpdateTriggersRequest]) (*connect.Response[trigger.UpdateTriggersResponse], error)
	// Soft-delete multiple triggers at once.
	DeleteTriggers(context.Context, *connect.Request[trigger.DeleteTriggersRequest]) (*connect.Response[trigger.DeleteTriggersResponse], error)
}

// NewTriggerServiceHandler builds an HTTP handler from the service implementation. It returns the
// path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewTriggerServiceHandler(svc TriggerServiceHandler, opts ...connect.HandlerOption) (string, http.Handler) {
	triggerServiceDeployTriggerHandler := connect.NewUnaryHandler(
		TriggerServiceDeployTriggerProcedure,
		svc.DeployTrigger,
		connect.WithSchema(triggerServiceDeployTriggerMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	triggerServiceGetTriggerDetailsHandler := connect.NewUnaryHandler(
		TriggerServiceGetTriggerDetailsProcedure,
		svc.GetTriggerDetails,
		connect.WithSchema(triggerServiceGetTriggerDetailsMethodDescriptor),
		connect.WithIdempotency(connect.IdempotencyNoSideEffects),
		connect.WithHandlerOptions(opts...),
	)
	triggerServiceGetTriggerRevisionDetailsHandler := connect.NewUnaryHandler(
		TriggerServiceGetTriggerRevisionDetailsProcedure,
		svc.GetTriggerRevisionDetails,
		connect.WithSchema(triggerServiceGetTriggerRevisionDetailsMethodDescriptor),
		connect.WithIdempotency(connect.IdempotencyNoSideEffects),
		connect.WithHandlerOptions(opts...),
	)
	triggerServiceListTriggersHandler := connect.NewUnaryHandler(
		TriggerServiceListTriggersProcedure,
		svc.ListTriggers,
		connect.WithSchema(triggerServiceListTriggersMethodDescriptor),
		connect.WithIdempotency(connect.IdempotencyNoSideEffects),
		connect.WithHandlerOptions(opts...),
	)
	triggerServiceGetTriggerRevisionHistoryHandler := connect.NewUnaryHandler(
		TriggerServiceGetTriggerRevisionHistoryProcedure,
		svc.GetTriggerRevisionHistory,
		connect.WithSchema(triggerServiceGetTriggerRevisionHistoryMethodDescriptor),
		connect.WithIdempotency(connect.IdempotencyNoSideEffects),
		connect.WithHandlerOptions(opts...),
	)
	triggerServiceUpdateTriggersHandler := connect.NewUnaryHandler(
		TriggerServiceUpdateTriggersProcedure,
		svc.UpdateTriggers,
		connect.WithSchema(triggerServiceUpdateTriggersMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	triggerServiceDeleteTriggersHandler := connect.NewUnaryHandler(
		TriggerServiceDeleteTriggersProcedure,
		svc.DeleteTriggers,
		connect.WithSchema(triggerServiceDeleteTriggersMethodDescriptor),
		connect.WithHandlerOptions(opts...),
	)
	return "/flyteidl2.trigger.TriggerService/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case TriggerServiceDeployTriggerProcedure:
			triggerServiceDeployTriggerHandler.ServeHTTP(w, r)
		case TriggerServiceGetTriggerDetailsProcedure:
			triggerServiceGetTriggerDetailsHandler.ServeHTTP(w, r)
		case TriggerServiceGetTriggerRevisionDetailsProcedure:
			triggerServiceGetTriggerRevisionDetailsHandler.ServeHTTP(w, r)
		case TriggerServiceListTriggersProcedure:
			triggerServiceListTriggersHandler.ServeHTTP(w, r)
		case TriggerServiceGetTriggerRevisionHistoryProcedure:
			triggerServiceGetTriggerRevisionHistoryHandler.ServeHTTP(w, r)
		case TriggerServiceUpdateTriggersProcedure:
			triggerServiceUpdateTriggersHandler.ServeHTTP(w, r)
		case TriggerServiceDeleteTriggersProcedure:
			triggerServiceDeleteTriggersHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedTriggerServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedTriggerServiceHandler struct{}

func (UnimplementedTriggerServiceHandler) DeployTrigger(context.Context, *connect.Request[trigger.DeployTriggerRequest]) (*connect.Response[trigger.DeployTriggerResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("flyteidl2.trigger.TriggerService.DeployTrigger is not implemented"))
}

func (UnimplementedTriggerServiceHandler) GetTriggerDetails(context.Context, *connect.Request[trigger.GetTriggerDetailsRequest]) (*connect.Response[trigger.GetTriggerDetailsResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("flyteidl2.trigger.TriggerService.GetTriggerDetails is not implemented"))
}

func (UnimplementedTriggerServiceHandler) GetTriggerRevisionDetails(context.Context, *connect.Request[trigger.GetTriggerRevisionDetailsRequest]) (*connect.Response[trigger.GetTriggerRevisionDetailsResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("flyteidl2.trigger.TriggerService.GetTriggerRevisionDetails is not implemented"))
}

func (UnimplementedTriggerServiceHandler) ListTriggers(context.Context, *connect.Request[trigger.ListTriggersRequest]) (*connect.Response[trigger.ListTriggersResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("flyteidl2.trigger.TriggerService.ListTriggers is not implemented"))
}

func (UnimplementedTriggerServiceHandler) GetTriggerRevisionHistory(context.Context, *connect.Request[trigger.GetTriggerRevisionHistoryRequest]) (*connect.Response[trigger.GetTriggerRevisionHistoryResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("flyteidl2.trigger.TriggerService.GetTriggerRevisionHistory is not implemented"))
}

func (UnimplementedTriggerServiceHandler) UpdateTriggers(context.Context, *connect.Request[trigger.UpdateTriggersRequest]) (*connect.Response[trigger.UpdateTriggersResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("flyteidl2.trigger.TriggerService.UpdateTriggers is not implemented"))
}

func (UnimplementedTriggerServiceHandler) DeleteTriggers(context.Context, *connect.Request[trigger.DeleteTriggersRequest]) (*connect.Response[trigger.DeleteTriggersResponse], error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("flyteidl2.trigger.TriggerService.DeleteTriggers is not implemented"))
}
