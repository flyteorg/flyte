{
  "swagger": "2.0",
  "info": {
    "title": "flyteidl2/app/app_service.proto",
    "version": "version not set"
  },
  "tags": [
    {
      "name": "AppService"
    }
  ],
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "paths": {},
  "definitions": {
    "ContainerArchitecture": {
      "type": "string",
      "enum": [
        "UNKNOWN",
        "AMD64",
        "ARM64",
        "ARM_V6",
        "ARM_V7"
      ],
      "default": "UNKNOWN",
      "description": "Architecture-type the container image supports."
    },
    "DataLoadingConfigLiteralMapFormat": {
      "type": "string",
      "enum": [
        "JSON",
        "YAML",
        "PROTO"
      ],
      "default": "JSON",
      "description": "- JSON: JSON / YAML for the metadata (which contains inlined primitive values). The representation is inline with the standard json specification as specified - https://www.json.org/json-en.html\n - PROTO: Proto is a serialized binary of `core.LiteralMap` defined in flyteidl/core",
      "title": "LiteralMapFormat decides the encoding format in which the input metadata should be made available to the containers.\nIf the user has access to the protocol buffer definitions, it is recommended to use the PROTO format.\nJSON and YAML do not need any protobuf definitions to read it\nAll remote references in core.LiteralMap are replaced with local filesystem references (the data is downloaded to local filesystem)"
    },
    "FilterFunction": {
      "type": "string",
      "enum": [
        "EQUAL",
        "NOT_EQUAL",
        "GREATER_THAN",
        "GREATER_THAN_OR_EQUAL",
        "LESS_THAN",
        "LESS_THAN_OR_EQUAL",
        "CONTAINS",
        "VALUE_IN",
        "ENDS_WITH",
        "NOT_ENDS_WITH",
        "CONTAINS_CASE_INSENSITIVE"
      ],
      "default": "EQUAL",
      "description": " - CONTAINS: Case sensitive contains function.\n - CONTAINS_CASE_INSENSITIVE: Case insensitive contains function."
    },
    "GPUAcceleratorDeviceClass": {
      "type": "string",
      "enum": [
        "NVIDIA_GPU",
        "GOOGLE_TPU",
        "AMAZON_NEURON",
        "AMD_GPU",
        "HABANA_GAUDI"
      ],
      "default": "NVIDIA_GPU",
      "description": "Specifies the class of accelerator device.\n\n - NVIDIA_GPU: NVIDIA GPU devices (default for backward compatibility)\n - GOOGLE_TPU: Google TPU devices\n - AMAZON_NEURON: Amazon Neuron devices\n - AMD_GPU: AMD GPU devices\n - HABANA_GAUDI: Habana Gaudi devices"
    },
    "IOStrategyDownloadMode": {
      "type": "string",
      "enum": [
        "DOWNLOAD_EAGER",
        "DOWNLOAD_STREAM",
        "DO_NOT_DOWNLOAD"
      ],
      "default": "DOWNLOAD_EAGER",
      "description": "- DOWNLOAD_EAGER: All data will be downloaded before the main container is executed\n - DOWNLOAD_STREAM: Data will be downloaded as a stream and an End-Of-Stream marker will be written to indicate all data has been downloaded. Refer to protocol for details\n - DO_NOT_DOWNLOAD: Large objects (offloaded) will not be downloaded",
      "title": "Mode to use for downloading"
    },
    "IOStrategyUploadMode": {
      "type": "string",
      "enum": [
        "UPLOAD_ON_EXIT",
        "UPLOAD_EAGER",
        "DO_NOT_UPLOAD"
      ],
      "default": "UPLOAD_ON_EXIT",
      "description": "- UPLOAD_ON_EXIT: All data will be uploaded after the main container exits\n - UPLOAD_EAGER: Data will be uploaded as it appears. Refer to protocol specification for details\n - DO_NOT_UPLOAD: Data will not be uploaded, only references will be written",
      "title": "Mode to use for uploading"
    },
    "ResourcesResourceEntry": {
      "type": "object",
      "properties": {
        "name": {
          "$ref": "#/definitions/ResourcesResourceName",
          "description": "Resource name."
        },
        "value": {
          "type": "string",
          "title": "Value must be a valid k8s quantity. See\nhttps://github.com/kubernetes/apimachinery/blob/master/pkg/api/resource/quantity.go#L30-L80"
        }
      },
      "description": "Encapsulates a resource name and value."
    },
    "ResourcesResourceName": {
      "type": "string",
      "enum": [
        "UNKNOWN",
        "CPU",
        "GPU",
        "MEMORY",
        "STORAGE",
        "EPHEMERAL_STORAGE"
      ],
      "default": "UNKNOWN",
      "description": "Known resource names.\n\n - EPHEMERAL_STORAGE: For Kubernetes-based deployments, pods use ephemeral local storage for scratch space, caching, and for logs."
    },
    "SecretMountType": {
      "type": "string",
      "enum": [
        "ANY",
        "ENV_VAR",
        "FILE"
      ],
      "default": "ANY",
      "description": " - ANY: Default case, indicates the client can tolerate either mounting options.\n - ENV_VAR: ENV_VAR indicates the secret needs to be mounted as an environment variable.\n - FILE: FILE indicates the secret needs to be mounted as a file."
    },
    "SortDirection": {
      "type": "string",
      "enum": [
        "DESCENDING",
        "ASCENDING"
      ],
      "default": "DESCENDING",
      "description": " - DESCENDING: By default, fields are sorted in descending order."
    },
    "SpecDesiredState": {
      "type": "string",
      "enum": [
        "DESIRED_STATE_UNSPECIFIED",
        "DESIRED_STATE_STOPPED",
        "DESIRED_STATE_STARTED",
        "DESIRED_STATE_ACTIVE"
      ],
      "default": "DESIRED_STATE_UNSPECIFIED",
      "description": "Enum for deployment status of the app.\n\n - DESIRED_STATE_UNSPECIFIED: Unspecified state\n - DESIRED_STATE_STOPPED: Deployment is disabled.\n - DESIRED_STATE_STARTED: Deployment is completed. Please use DESIRED_STATE_ACTIVE instead.\n - DESIRED_STATE_ACTIVE: Deployment is completed."
    },
    "StatusDeploymentStatus": {
      "type": "string",
      "enum": [
        "DEPLOYMENT_STATUS_UNSPECIFIED",
        "DEPLOYMENT_STATUS_UNASSIGNED",
        "DEPLOYMENT_STATUS_ASSIGNED",
        "DEPLOYMENT_STATUS_PENDING",
        "DEPLOYMENT_STATUS_STOPPED",
        "DEPLOYMENT_STATUS_STARTED",
        "DEPLOYMENT_STATUS_FAILED",
        "DEPLOYMENT_STATUS_ACTIVE",
        "DEPLOYMENT_STATUS_SCALING_UP",
        "DEPLOYMENT_STATUS_SCALING_DOWN",
        "DEPLOYMENT_STATUS_DEPLOYING"
      ],
      "default": "DEPLOYMENT_STATUS_UNSPECIFIED",
      "description": "Enum for deployment status of the app.\n\n - DEPLOYMENT_STATUS_UNSPECIFIED: Unspecified deployment status.\n - DEPLOYMENT_STATUS_UNASSIGNED: Deployment is enabled but hasn't been assigned to a cluster yet.\n - DEPLOYMENT_STATUS_ASSIGNED: Deployment is assigned to a cluster but hasn't been acknowledged yet.\n - DEPLOYMENT_STATUS_PENDING: Deployment is picked up by a cluster but is awaiting deployment.\n - DEPLOYMENT_STATUS_STOPPED: Deployment is disabled.\n - DEPLOYMENT_STATUS_STARTED: Deployment is completed. Please use DEPLOYMENT_STATUS_ACTIVE instead.\n - DEPLOYMENT_STATUS_FAILED: Deployment has failed.\n - DEPLOYMENT_STATUS_ACTIVE: Deployment is completed.\n - DEPLOYMENT_STATUS_SCALING_UP: Triggered in response to desired app replicas \u003e actual app replicas\n - DEPLOYMENT_STATUS_SCALING_DOWN: Triggered in response to desired app replicas \u003c actual app replicas\n - DEPLOYMENT_STATUS_DEPLOYING: Triggered in response to the latest app spec changing"
    },
    "appApp": {
      "type": "object",
      "properties": {
        "metadata": {
          "$ref": "#/definitions/appMeta",
          "description": "Metadata of the app."
        },
        "spec": {
          "$ref": "#/definitions/appSpec",
          "description": "Specification of the app."
        },
        "status": {
          "$ref": "#/definitions/flyteidl2appStatus",
          "description": "Status of the app."
        }
      },
      "description": "Represents an app with its specification and status."
    },
    "appAutoscalingConfig": {
      "type": "object",
      "properties": {
        "replicas": {
          "$ref": "#/definitions/appReplicas",
          "description": "Configuration for the number of replicas."
        },
        "scaledown_period": {
          "type": "string",
          "description": "The period for scaling down the object."
        },
        "scaling_metric": {
          "$ref": "#/definitions/appScalingMetric",
          "description": "Metric for scaling the app."
        }
      },
      "description": "Represents the autoscaling configuration of an app."
    },
    "appConcurrency": {
      "type": "object",
      "properties": {
        "target_value": {
          "type": "integer",
          "format": "int64",
          "title": "This is the target value for the scaling configuration.\ndefault=100"
        }
      },
      "description": "This section enables scaling based on the request concurrency. Concurrency calculates how many\nrequests are being processed at the same time. This is useful for apps that take longer to process\nrequests (e.g. seconds)\nThe autoscaler has a default window of 60 seconds to calculate the concurrency value. However, it has\npanic mode that kicks in if the request rate jumps to 2x its value within 6 seconds. If that's\ntriggered, it'll start scaling up immediately instead of waiting for the full 60 seconds."
    },
    "appCondition": {
      "type": "object",
      "properties": {
        "last_transition_time": {
          "type": "string",
          "format": "date-time",
          "description": "Last transition time of the condition."
        },
        "deployment_status": {
          "$ref": "#/definitions/StatusDeploymentStatus",
          "description": "Deployment status of the app."
        },
        "message": {
          "type": "string",
          "description": "Message for the condition."
        },
        "revision": {
          "type": "string",
          "format": "uint64",
          "description": "Revision the Condition applies to. This can be used by consumers\nto introspect and visualize which revisions are up."
        },
        "actor": {
          "$ref": "#/definitions/commonEnrichedIdentity",
          "description": "Actor is the principal that caused the condition."
        }
      },
      "description": "Represents the condition of an app."
    },
    "appCreateEvent": {
      "type": "object",
      "properties": {
        "app": {
          "$ref": "#/definitions/appApp",
          "description": "The created app."
        }
      },
      "description": "Event message for app creation."
    },
    "appCreateResponse": {
      "type": "object",
      "properties": {
        "app": {
          "$ref": "#/definitions/appApp",
          "description": "The created app."
        }
      },
      "description": "Response message for creating an app."
    },
    "appDeleteEvent": {
      "type": "object",
      "properties": {
        "app": {
          "$ref": "#/definitions/appApp",
          "description": "The deleted app."
        }
      },
      "description": "Event message for app deletion."
    },
    "appDeleteResponse": {
      "type": "object",
      "description": "Response message for deleting an app."
    },
    "appImageSpecSet": {
      "type": "object",
      "properties": {
        "images": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/flyteidl2appImageSpec"
          },
          "description": "List of image specifications."
        }
      }
    },
    "appIngress": {
      "type": "object",
      "properties": {
        "public_url": {
          "type": "string",
          "description": "Public URL of the app."
        },
        "cname_url": {
          "type": "string",
          "description": "Canonical name (CNAME) URL of the app."
        },
        "vpc_url": {
          "type": "string",
          "description": "VPC URL of the app."
        }
      }
    },
    "appIngressConfig": {
      "type": "object",
      "properties": {
        "private": {
          "type": "boolean",
          "description": "Indicates if the app should be private."
        },
        "subdomain": {
          "type": "string",
          "description": "Subdomain for the app. If not specified, a random subdomain will be generated."
        },
        "cname": {
          "type": "string",
          "description": "Canonical name (CNAME) for the app."
        }
      },
      "description": "Represents the ingress configuration of an app."
    },
    "appInput": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "title": "Name is a unique identifier of the input within the list of inputs of the app"
        },
        "string_value": {
          "type": "string",
          "title": "StringValue is a plain string value for the input"
        },
        "artifact_query": {
          "$ref": "#/definitions/coreArtifactQuery",
          "description": "ArtifactQuery is that should result in a single artifact that will be used as the input to the app at runtime.\nThe artifact will be pinned at the time of the app creation."
        },
        "artifact_id": {
          "$ref": "#/definitions/coreArtifactID",
          "description": "ArtifactId is an identifier of an artifact that will be used as the input to the app at runtime."
        },
        "app_id": {
          "$ref": "#/definitions/flyteidl2appIdentifier",
          "description": "ID of the app."
        }
      }
    },
    "appInputList": {
      "type": "object",
      "properties": {
        "items": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/appInput"
          },
          "description": "Items is the list of inputs to fulfil for the app."
        }
      },
      "description": "InputList is a list of dependencies for the app."
    },
    "appK8sMetadata": {
      "type": "object",
      "properties": {
        "namespace": {
          "type": "string",
          "description": "Namespace points to the namespace the app is deployed in."
        }
      }
    },
    "appLeaseResponse": {
      "type": "object",
      "properties": {
        "apps": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/appApp"
          },
          "description": "List of leased apps."
        }
      },
      "description": "Response message for leasing apps."
    },
    "appLink": {
      "type": "object",
      "properties": {
        "path": {
          "type": "string",
          "description": "URL of the external service.\nThis can be an absolute or relative path."
        },
        "title": {
          "type": "string",
          "description": "Human readable name of the external service."
        },
        "is_relative": {
          "type": "boolean",
          "description": "Whether the path is absolute (default) or relative."
        }
      },
      "title": "Represents a link to an external resource (Arize project link, W\u0026B dashboard, etc)"
    },
    "appListResponse": {
      "type": "object",
      "properties": {
        "apps": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/appApp"
          },
          "description": "List of apps."
        },
        "token": {
          "type": "string",
          "description": "Token for fetching the next page of results, if any."
        }
      },
      "description": "Response message for listing apps."
    },
    "appMaterializedInput": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string",
          "title": "Name is a unique identifier of the input within the list of inputs of the app"
        },
        "artifact_id": {
          "$ref": "#/definitions/coreArtifactID",
          "description": "ArtifactId is an identifier of an artifact that will be used as the input to the app at runtime."
        }
      }
    },
    "appMaterializedInputs": {
      "type": "object",
      "properties": {
        "items": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/appMaterializedInput"
          }
        },
        "revision": {
          "type": "string",
          "format": "uint64",
          "description": "Revision of the app object that we materialized the input for."
        }
      }
    },
    "appMeta": {
      "type": "object",
      "properties": {
        "id": {
          "$ref": "#/definitions/flyteidl2appIdentifier",
          "description": "ID of the app."
        },
        "revision": {
          "type": "string",
          "format": "uint64",
          "description": "Revision of the app object."
        },
        "labels": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Labels for the app."
        }
      }
    },
    "appProfile": {
      "type": "object",
      "properties": {
        "type": {
          "type": "string",
          "title": "App Type (e.g. FastAPI, Flask, VLLM, NIM etc.)"
        },
        "name": {
          "type": "string",
          "description": "Friendly name of the app."
        },
        "short_description": {
          "type": "string",
          "description": "Short description of the app."
        },
        "icon_url": {
          "type": "string",
          "description": "Icon URL of the app."
        }
      }
    },
    "appReplicas": {
      "type": "object",
      "properties": {
        "min": {
          "type": "integer",
          "format": "int64",
          "description": "Minimum number of replicas."
        },
        "max": {
          "type": "integer",
          "format": "int64",
          "description": "Maximum number of replicas."
        }
      },
      "description": "Represents the configuration for the number of replicas."
    },
    "appRequestRate": {
      "type": "object",
      "properties": {
        "target_value": {
          "type": "integer",
          "format": "int64",
          "title": "This is the target value for the scaling configuration.\ndefault=100"
        }
      },
      "description": "RequestRate enables scaling based on the request rate. Request rate calculates how many requests\nthe app is receiving per second.\nThe autoscaler has a default window of 60 seconds to calculate the request rate. However, it has\npanic mode that kicks in if the request rate jumps to 2x its value within 6 seconds. If that's\ntriggered, it'll start scaling up immediately instead of waiting for the full 60 seconds."
    },
    "appScalingMetric": {
      "type": "object",
      "properties": {
        "request_rate": {
          "$ref": "#/definitions/appRequestRate",
          "description": "Configuration for scaling based on request rate."
        },
        "concurrency": {
          "$ref": "#/definitions/appConcurrency",
          "description": "Configuration for scaling based on concurrency."
        }
      },
      "title": "ScalingMetric allows different scaling strategies for the app.\nSee: https://knative.dev/docs/serving/autoscaling/autoscaling-metrics/"
    },
    "appSpec": {
      "type": "object",
      "properties": {
        "container": {
          "$ref": "#/definitions/coreContainer",
          "description": "Container payload."
        },
        "pod": {
          "$ref": "#/definitions/coreK8sPod",
          "description": "K8s pod payload."
        },
        "autoscaling": {
          "$ref": "#/definitions/appAutoscalingConfig",
          "description": "Autoscaling configuration for the app."
        },
        "ingress": {
          "$ref": "#/definitions/appIngressConfig",
          "description": "Ingress configuration for the app."
        },
        "desired_state": {
          "$ref": "#/definitions/SpecDesiredState",
          "description": "Deployment status of the app."
        },
        "cluster_pool": {
          "type": "string",
          "description": "ClusterPool to place this app on. By default it'll use the default cluster pool."
        },
        "images": {
          "$ref": "#/definitions/appImageSpecSet",
          "description": "Set of image specifications for the app."
        },
        "security_context": {
          "$ref": "#/definitions/flyteidl2appSecurityContext",
          "description": "security_context encapsulates security attributes requested to run this task."
        },
        "extended_resources": {
          "$ref": "#/definitions/coreExtendedResources",
          "description": "Encapsulates all non-standard resources, not captured by\nv1.ResourceRequirements, to allocate to a task."
        },
        "runtime_metadata": {
          "$ref": "#/definitions/flyteidl2commonRuntimeMetadata",
          "description": "Runtime metadata for the app."
        },
        "profile": {
          "$ref": "#/definitions/appProfile",
          "description": "Profile of the app."
        },
        "creator": {
          "$ref": "#/definitions/commonEnrichedIdentity",
          "description": "Creator of the app is the first principal that provisioned this app. Other principals may\ninteract with the app by updating its spec or stopping/starting it."
        },
        "inputs": {
          "$ref": "#/definitions/appInputList",
          "description": "Inputs of the app."
        },
        "links": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/appLink"
          }
        },
        "timeouts": {
          "$ref": "#/definitions/appTimeoutConfig",
          "description": "Timeout configuration for the app."
        }
      },
      "description": "Represents the specification of an app."
    },
    "appTimeoutConfig": {
      "type": "object",
      "properties": {
        "request_timeout": {
          "type": "string",
          "title": "This is the maximum duration that the request instance\nis allowed to respond to a request. If unspecified, a system default will\nbe provided.\ndefault=300s"
        }
      }
    },
    "appUpdateEvent": {
      "type": "object",
      "properties": {
        "updated_app": {
          "$ref": "#/definitions/appApp",
          "description": "The updated app."
        },
        "old_app": {
          "$ref": "#/definitions/appApp",
          "description": "The old app before the update."
        }
      },
      "description": "Event message for app update."
    },
    "appUpdateResponse": {
      "type": "object",
      "properties": {
        "app": {
          "$ref": "#/definitions/appApp",
          "description": "The updated app."
        }
      },
      "description": "Response message for updating an app."
    },
    "appUpdateStatusResponse": {
      "type": "object",
      "properties": {
        "app": {
          "$ref": "#/definitions/appApp",
          "description": "The app with updated status."
        }
      },
      "description": "Response message for updating app status."
    },
    "commonAppSpec": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "organization": {
          "type": "string"
        }
      }
    },
    "commonApplication": {
      "type": "object",
      "properties": {
        "id": {
          "$ref": "#/definitions/commonApplicationIdentifier"
        },
        "spec": {
          "$ref": "#/definitions/commonAppSpec"
        }
      }
    },
    "commonApplicationIdentifier": {
      "type": "object",
      "properties": {
        "subject": {
          "type": "string"
        }
      }
    },
    "commonClusterIdentifier": {
      "type": "object",
      "properties": {
        "organization": {
          "type": "string"
        },
        "name": {
          "type": "string"
        }
      }
    },
    "commonDomain": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "organization": {
          "$ref": "#/definitions/commonOrganization"
        }
      }
    },
    "commonEnrichedIdentity": {
      "type": "object",
      "properties": {
        "user": {
          "$ref": "#/definitions/commonUser"
        },
        "application": {
          "$ref": "#/definitions/commonApplication"
        }
      }
    },
    "commonFilter": {
      "type": "object",
      "properties": {
        "function": {
          "$ref": "#/definitions/FilterFunction"
        },
        "field": {
          "type": "string",
          "title": "e.g. name or version"
        },
        "values": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Only in the case of a VALUE_IN function, values may contain multiple entries."
        }
      }
    },
    "commonLaunchPlan": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "project": {
          "$ref": "#/definitions/commonProject"
        }
      }
    },
    "commonOrganization": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        }
      }
    },
    "commonPermission": {
      "type": "object",
      "properties": {
        "resource": {
          "$ref": "#/definitions/flyteidl2commonResource"
        },
        "actions": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/flyteidl2commonAction"
          }
        }
      },
      "description": "Defines a set of allowed actions on a specific authorization resource."
    },
    "commonPolicy": {
      "type": "object",
      "properties": {
        "id": {
          "$ref": "#/definitions/commonPolicyIdentifier"
        },
        "bindings": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/commonPolicyBinding"
          }
        },
        "description": {
          "type": "string",
          "title": "Optional: human readable description"
        }
      },
      "description": "A policy is a collection of roles bound to a resource."
    },
    "commonPolicyBinding": {
      "type": "object",
      "properties": {
        "role_id": {
          "$ref": "#/definitions/commonRoleIdentifier",
          "description": "The role designates the permitted set of actions which can be applied to the resource."
        },
        "resource": {
          "$ref": "#/definitions/flyteidl2commonResource"
        }
      },
      "description": "A policy binding represents a role (a set of actions) defined on a resource."
    },
    "commonPolicyIdentifier": {
      "type": "object",
      "properties": {
        "organization": {
          "type": "string"
        },
        "name": {
          "type": "string",
          "title": "Unique name for this policy within the organization"
        }
      }
    },
    "commonProject": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "domain": {
          "$ref": "#/definitions/commonDomain"
        }
      }
    },
    "commonProjectIdentifier": {
      "type": "object",
      "properties": {
        "organization": {
          "type": "string"
        },
        "domain": {
          "type": "string"
        },
        "name": {
          "type": "string"
        }
      }
    },
    "commonRole": {
      "type": "object",
      "properties": {
        "id": {
          "$ref": "#/definitions/commonRoleIdentifier"
        },
        "permissions": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/commonPermission"
          }
        },
        "role_spec": {
          "$ref": "#/definitions/commonRoleSpec"
        },
        "role_type": {
          "$ref": "#/definitions/commonRoleType"
        },
        "actions": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/flyteidl2commonAction"
          }
        }
      }
    },
    "commonRoleIdentifier": {
      "type": "object",
      "properties": {
        "organization": {
          "type": "string"
        },
        "name": {
          "type": "string",
          "title": "Unique name for this role within the organization"
        }
      }
    },
    "commonRoleSpec": {
      "type": "object",
      "properties": {
        "description": {
          "type": "string",
          "description": "Optional, human readable description for this role."
        }
      }
    },
    "commonRoleType": {
      "type": "string",
      "enum": [
        "ROLE_TYPE_NONE",
        "ROLE_TYPE_ADMIN",
        "ROLE_TYPE_CONTRIBUTOR",
        "ROLE_TYPE_VIEWER",
        "ROLE_TYPE_CUSTOM",
        "ROLE_TYPE_CLUSTER_MANAGER",
        "ROLE_TYPE_FLYTE_PROJECT_ADMIN",
        "ROLE_TYPE_SERVERLESS_VIEWER",
        "ROLE_TYPE_SERVERLESS_CONTRIBUTOR",
        "ROLE_TYPE_SUPPORT"
      ],
      "default": "ROLE_TYPE_NONE",
      "description": "- ROLE_TYPE_NONE: Default group. Not used in practice.\n - ROLE_TYPE_ADMIN: The admin role has a collective set of permissions to do everything\n - ROLE_TYPE_CONTRIBUTOR: The contributor role has a collective set of permissions to view inventory, view executions, write inventory and create executions\n - ROLE_TYPE_VIEWER: The viewer role has a collective set of permissions to view inventory and view executions\n - ROLE_TYPE_CUSTOM: Represent a role with user-defined sets of permissions.\n - ROLE_TYPE_CLUSTER_MANAGER: The role with permissions to administer a specific customer cluster.\n - ROLE_TYPE_FLYTE_PROJECT_ADMIN: Role with permissions specific to administer flyte project(s).\n - ROLE_TYPE_SERVERLESS_VIEWER: The viewer role for serverless\n - ROLE_TYPE_SERVERLESS_CONTRIBUTOR: The contributor role for serverless\n - ROLE_TYPE_SUPPORT: The support role would have contributor permissions plus the access to support endpoints",
      "title": "A role type is a short-hand for understanding the permissions associated with a role.\nBoilerplate role types include a conventional collection of permissions\nCustom role types include a user-defined collection of permissions"
    },
    "commonSort": {
      "type": "object",
      "properties": {
        "key": {
          "type": "string",
          "title": "Indicates an attribute to sort the response values.\n+required"
        },
        "direction": {
          "$ref": "#/definitions/SortDirection",
          "title": "Indicates the direction to apply sort key for response values.\n+optional"
        }
      },
      "description": "Specifies sort ordering in a list request."
    },
    "commonUser": {
      "type": "object",
      "properties": {
        "id": {
          "$ref": "#/definitions/commonUserIdentifier"
        },
        "spec": {
          "$ref": "#/definitions/commonUserSpec"
        },
        "roles": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/commonRole"
          }
        },
        "policies": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/commonPolicy"
          }
        }
      },
      "description": "Encapsulates user profile details for a member of an organization."
    },
    "commonUserIdentifier": {
      "type": "object",
      "properties": {
        "subject": {
          "type": "string"
        }
      }
    },
    "commonUserSpec": {
      "type": "object",
      "properties": {
        "first_name": {
          "type": "string"
        },
        "last_name": {
          "type": "string"
        },
        "email": {
          "type": "string"
        },
        "organization": {
          "type": "string"
        },
        "user_handle": {
          "type": "string"
        },
        "groups": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "photo_url": {
          "type": "string"
        }
      }
    },
    "commonWorkflow": {
      "type": "object",
      "properties": {
        "name": {
          "type": "string"
        },
        "project": {
          "$ref": "#/definitions/commonProject"
        }
      }
    },
    "coreArtifactBindingData": {
      "type": "object",
      "properties": {
        "partition_key": {
          "type": "string"
        },
        "bind_to_time_partition": {
          "type": "boolean"
        },
        "time_transform": {
          "$ref": "#/definitions/coreTimeTransform",
          "title": "This is only relevant in the time partition case"
        }
      },
      "title": "Only valid for triggers"
    },
    "coreArtifactID": {
      "type": "object",
      "properties": {
        "artifact_key": {
          "$ref": "#/definitions/coreArtifactKey"
        },
        "version": {
          "type": "string"
        },
        "partitions": {
          "$ref": "#/definitions/corePartitions",
          "description": "Think of a partition as a tag on an Artifact, except it's a key-value pair.\nDifferent partitions naturally have different versions (execution ids)."
        },
        "time_partition": {
          "$ref": "#/definitions/coreTimePartition",
          "description": "There is no such thing as an empty time partition - if it's not set, then there is no time partition."
        }
      }
    },
    "coreArtifactKey": {
      "type": "object",
      "properties": {
        "project": {
          "type": "string",
          "description": "Project and domain and suffix needs to be unique across a given artifact store."
        },
        "domain": {
          "type": "string"
        },
        "name": {
          "type": "string"
        },
        "org": {
          "type": "string"
        }
      }
    },
    "coreArtifactQuery": {
      "type": "object",
      "properties": {
        "artifact_id": {
          "$ref": "#/definitions/coreArtifactID"
        },
        "artifact_tag": {
          "$ref": "#/definitions/coreArtifactTag"
        },
        "uri": {
          "type": "string"
        },
        "binding": {
          "$ref": "#/definitions/coreArtifactBindingData",
          "description": "This is used in the trigger case, where a user specifies a value for an input that is one of the triggering\nartifacts, or a partition value derived from a triggering artifact."
        }
      },
      "title": "Uniqueness constraints for Artifacts\n - project, domain, name, version, partitions\nOption 2 (tags are standalone, point to an individual artifact id):\n - project, domain, name, alias (points to one partition if partitioned)\n - project, domain, name, partition key, partition value"
    },
    "coreArtifactTag": {
      "type": "object",
      "properties": {
        "artifact_key": {
          "$ref": "#/definitions/coreArtifactKey"
        },
        "value": {
          "$ref": "#/definitions/coreLabelValue"
        }
      }
    },
    "coreContainer": {
      "type": "object",
      "properties": {
        "image": {
          "type": "string",
          "title": "Container image url. Eg: docker/redis:latest"
        },
        "command": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Command to be executed, if not provided, the default entrypoint in the container image will be used."
        },
        "args": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "These will default to Flyte given paths. If provided, the system will not append known paths. If the task still\nneeds flyte's inputs and outputs path, add $(FLYTE_INPUT_FILE), $(FLYTE_OUTPUT_FILE) wherever makes sense and the\nsystem will populate these before executing the container."
        },
        "resources": {
          "$ref": "#/definitions/coreResources",
          "description": "Container resources requirement as specified by the container engine."
        },
        "env": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/coreKeyValuePair"
          },
          "description": "Environment variables will be set as the container is starting up."
        },
        "config": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/coreKeyValuePair"
          },
          "description": "Allows extra configs to be available for the container.\nTODO: elaborate on how configs will become available.\nDeprecated, please use TaskTemplate.config instead."
        },
        "ports": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/coreContainerPort"
          },
          "title": "Ports to open in the container. This feature is not supported by all execution engines. (e.g. supported on K8s but\nnot supported on AWS Batch)\nOnly K8s"
        },
        "data_config": {
          "$ref": "#/definitions/coreDataLoadingConfig",
          "title": "BETA: Optional configuration for DataLoading. If not specified, then default values are used.\nThis makes it possible to to run a completely portable container, that uses inputs and outputs\nonly from the local file-system and without having any reference to flyteidl. This is supported only on K8s at the moment.\nIf data loading is enabled, then data will be mounted in accompanying directories specified in the DataLoadingConfig. If the directories\nare not specified, inputs will be mounted onto and outputs will be uploaded from a pre-determined file-system path. Refer to the documentation\nto understand the default paths.\nOnly K8s"
        },
        "architecture": {
          "$ref": "#/definitions/ContainerArchitecture"
        }
      }
    },
    "coreContainerPort": {
      "type": "object",
      "properties": {
        "container_port": {
          "type": "integer",
          "format": "int64",
          "description": "Number of port to expose on the pod's IP address.\nThis must be a valid port number, 0 \u003c x \u003c 65536."
        },
        "name": {
          "type": "string",
          "description": "Name of the port to expose on the pod's IP address."
        }
      },
      "description": "Defines port properties for a container."
    },
    "coreDataLoadingConfig": {
      "type": "object",
      "properties": {
        "enabled": {
          "type": "boolean",
          "title": "Flag enables DataLoading Config. If this is not set, data loading will not be used!"
        },
        "input_path": {
          "type": "string",
          "title": "File system path (start at root). This folder will contain all the inputs exploded to a separate file.\nExample, if the input interface needs (x: int, y: blob, z: multipart_blob) and the input path is '/var/flyte/inputs', then the file system will look like\n/var/flyte/inputs/inputs.\u003cmetadata format dependent -\u003e .pb .json .yaml\u003e -\u003e Format as defined previously. The Blob and Multipart blob will reference local filesystem instead of remote locations\n/var/flyte/inputs/x -\u003e X is a file that contains the value of x (integer) in string format\n/var/flyte/inputs/y -\u003e Y is a file in Binary format\n/var/flyte/inputs/z/... -\u003e Note Z itself is a directory\nMore information about the protocol - refer to docs #TODO reference docs here"
        },
        "output_path": {
          "type": "string",
          "title": "File system path (start at root). This folder should contain all the outputs for the task as individual files and/or an error text file"
        },
        "format": {
          "$ref": "#/definitions/DataLoadingConfigLiteralMapFormat",
          "title": "In the inputs folder, there will be an additional summary/metadata file that contains references to all files or inlined primitive values.\nThis format decides the actual encoding for the data. Refer to the encoding to understand the specifics of the contents and the encoding"
        },
        "io_strategy": {
          "$ref": "#/definitions/coreIOStrategy"
        }
      },
      "description": "This configuration allows executing raw containers in Flyte using the Flyte CoPilot system.\nFlyte CoPilot, eliminates the needs of flytekit or sdk inside the container. Any inputs required by the users container are side-loaded in the input_path\nAny outputs generated by the user container - within output_path are automatically uploaded."
    },
    "coreExtendedResources": {
      "type": "object",
      "properties": {
        "gpu_accelerator": {
          "$ref": "#/definitions/coreGPUAccelerator",
          "description": "GPU accelerator to select for task. Contains information about device type, and\nfor multi-instance GPUs, the partition size to use."
        },
        "shared_memory": {
          "$ref": "#/definitions/coreSharedMemory"
        }
      },
      "description": "Encapsulates all non-standard resources, not captured by v1.ResourceRequirements, to\nallocate to a task."
    },
    "coreGPUAccelerator": {
      "type": "object",
      "properties": {
        "device": {
          "type": "string",
          "description": "This can be any arbitrary string, and should be informed by the labels or taints\nassociated with the nodes in question. Default cloud provider labels typically\nuse the following values: `nvidia-tesla-t4`, `nvidia-tesla-a100`, etc."
        },
        "unpartitioned": {
          "type": "boolean"
        },
        "partition_size": {
          "type": "string",
          "description": "Like `device`, this can be any arbitrary string, and should be informed by\nthe labels or taints associated with the nodes in question. Default cloud\nprovider labels typically use the following values: `1g.5gb`, `2g.10gb`, etc."
        },
        "device_class": {
          "$ref": "#/definitions/GPUAcceleratorDeviceClass",
          "description": "The class of accelerator device. Defaults to NVIDIA_GPU if not specified."
        }
      },
      "description": "Metadata associated with the GPU accelerator to allocate to a task. Contains\ninformation about device type, and for multi-instance GPUs, the partition size to\nuse."
    },
    "coreGranularity": {
      "type": "string",
      "enum": [
        "UNSET",
        "MINUTE",
        "HOUR",
        "DAY",
        "MONTH"
      ],
      "default": "UNSET",
      "title": "- DAY: default"
    },
    "coreIOStrategy": {
      "type": "object",
      "properties": {
        "download_mode": {
          "$ref": "#/definitions/IOStrategyDownloadMode",
          "title": "Mode to use to manage downloads"
        },
        "upload_mode": {
          "$ref": "#/definitions/IOStrategyUploadMode",
          "title": "Mode to use to manage uploads"
        }
      },
      "title": "Strategy to use when dealing with Blob, Schema, or multipart blob data (large datasets)"
    },
    "coreInputBindingData": {
      "type": "object",
      "properties": {
        "var": {
          "type": "string"
        }
      }
    },
    "coreK8sObjectMetadata": {
      "type": "object",
      "properties": {
        "labels": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Optional labels to add to the pod definition."
        },
        "annotations": {
          "type": "object",
          "additionalProperties": {
            "type": "string"
          },
          "description": "Optional annotations to add to the pod definition."
        }
      },
      "description": "Metadata for building a kubernetes object when a task is executed."
    },
    "coreK8sPod": {
      "type": "object",
      "properties": {
        "metadata": {
          "$ref": "#/definitions/coreK8sObjectMetadata",
          "description": "Contains additional metadata for building a kubernetes pod."
        },
        "pod_spec": {
          "type": "object",
          "title": "Defines the primary pod spec created when a task is executed.\nThis should be a JSON-marshalled pod spec, which can be defined in\n- go, using: https://github.com/kubernetes/api/blob/release-1.21/core/v1/types.go#L2936\n- python: using https://github.com/kubernetes-client/python/blob/release-19.0/kubernetes/client/models/v1_pod_spec.py"
        },
        "data_config": {
          "$ref": "#/definitions/coreDataLoadingConfig",
          "title": "BETA: Optional configuration for DataLoading. If not specified, then default values are used.\nThis makes it possible to to run a completely portable container, that uses inputs and outputs\nonly from the local file-system and without having any reference to flytekit. This is supported only on K8s at the moment.\nIf data loading is enabled, then data will be mounted in accompanying directories specified in the DataLoadingConfig. If the directories\nare not specified, inputs will be mounted onto and outputs will be uploaded from a pre-determined file-system path. Refer to the documentation\nto understand the default paths.\nOnly K8s"
        },
        "primary_container_name": {
          "type": "string",
          "description": "Defines the primary container name when pod template override is executed."
        }
      },
      "description": "Defines a pod spec and additional pod metadata that is created when a task is executed."
    },
    "coreKeyValuePair": {
      "type": "object",
      "properties": {
        "key": {
          "type": "string",
          "description": "required."
        },
        "value": {
          "type": "string",
          "description": "+optional."
        }
      },
      "description": "A generic key value pair."
    },
    "coreLabelValue": {
      "type": "object",
      "properties": {
        "static_value": {
          "type": "string",
          "title": "The string static value is for use in the Partitions object"
        },
        "time_value": {
          "type": "string",
          "format": "date-time",
          "title": "The time value is for use in the TimePartition case"
        },
        "triggered_binding": {
          "$ref": "#/definitions/coreArtifactBindingData"
        },
        "input_binding": {
          "$ref": "#/definitions/coreInputBindingData"
        },
        "runtime_binding": {
          "$ref": "#/definitions/coreRuntimeBinding"
        }
      }
    },
    "coreOAuth2Client": {
      "type": "object",
      "properties": {
        "client_id": {
          "type": "string",
          "title": "client_id is the public id for the client to use. The system will not perform any pre-auth validation that the\nsecret requested matches the client_id indicated here.\n+required"
        },
        "client_secret": {
          "$ref": "#/definitions/flyteidl2coreSecret",
          "title": "client_secret is a reference to the secret used to authenticate the OAuth2 client.\n+required"
        }
      },
      "description": "OAuth2Client encapsulates OAuth2 Client Credentials to be used when making calls on behalf of that task."
    },
    "coreOperator": {
      "type": "string",
      "enum": [
        "MINUS",
        "PLUS"
      ],
      "default": "MINUS"
    },
    "corePartitions": {
      "type": "object",
      "properties": {
        "value": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/coreLabelValue"
          }
        }
      }
    },
    "coreResources": {
      "type": "object",
      "properties": {
        "requests": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/ResourcesResourceEntry"
          },
          "description": "The desired set of resources requested. ResourceNames must be unique within the list."
        },
        "limits": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/ResourcesResourceEntry"
          },
          "description": "Defines a set of bounds (e.g. min/max) within which the task can reliably run. ResourceNames must be unique\nwithin the list."
        }
      },
      "description": "A customizable interface to convey resources requested for a container. This can be interpreted differently for different\ncontainer engines."
    },
    "coreRuntimeBinding": {
      "type": "object"
    },
    "coreSharedMemory": {
      "type": "object",
      "properties": {
        "mount_path": {
          "type": "string",
          "title": "Mount path to place in container"
        },
        "mount_name": {
          "type": "string",
          "title": "Name for volume"
        },
        "size_limit": {
          "type": "string",
          "title": "Size limit for shared memory. If not set, then the shared memory is equal\nto the allocated memory.\n+optional"
        }
      },
      "description": "Metadata associated with configuring a shared memory volume for a task."
    },
    "coreTimePartition": {
      "type": "object",
      "properties": {
        "value": {
          "$ref": "#/definitions/coreLabelValue"
        },
        "granularity": {
          "$ref": "#/definitions/coreGranularity"
        }
      }
    },
    "coreTimeTransform": {
      "type": "object",
      "properties": {
        "transform": {
          "type": "string"
        },
        "op": {
          "$ref": "#/definitions/coreOperator"
        }
      }
    },
    "flyteidl2appGetResponse": {
      "type": "object",
      "properties": {
        "app": {
          "$ref": "#/definitions/appApp",
          "description": "The retrieved app."
        }
      },
      "description": "Response message for retrieving an app."
    },
    "flyteidl2appIdentifier": {
      "type": "object",
      "properties": {
        "org": {
          "type": "string",
          "description": "Org that the app belongs to."
        },
        "project": {
          "type": "string",
          "description": "Project that the app belongs to."
        },
        "domain": {
          "type": "string",
          "description": "Domain that the app belongs to."
        },
        "name": {
          "type": "string",
          "description": "Name that the user provided for the app."
        }
      }
    },
    "flyteidl2appImageSpec": {
      "type": "object",
      "properties": {
        "tag": {
          "type": "string",
          "description": "Tag of the image."
        },
        "build_job_url": {
          "type": "string",
          "description": "URL of the build job for the image."
        }
      }
    },
    "flyteidl2appSecurityContext": {
      "type": "object",
      "properties": {
        "run_as": {
          "$ref": "#/definitions/flyteidl2coreIdentity",
          "description": "run_as encapsulates the identity a pod should run as. If the task fills in multiple fields here, it'll be up to the\nbackend plugin to choose the appropriate identity for the execution engine the task will run on."
        },
        "secrets": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/flyteidl2coreSecret"
          },
          "description": "secrets indicate the list of secrets the task needs in order to proceed. Secrets will be mounted/passed to the\npod as it starts. If the plugin responsible for kicking of the task will not run it on a flyte cluster (e.g. AWS\nBatch), it's the responsibility of the plugin to fetch the secret (which means propeller identity will need access\nto the secret) and to pass it to the remote execution engine."
        },
        "allow_anonymous": {
          "type": "boolean",
          "description": "AllowAnonymous indicates if the app should be accessible without authentication. This assumes the app will handle\nits own authentication or that it's a public app."
        }
      },
      "description": "SecurityContext holds security attributes that apply to tasks."
    },
    "flyteidl2appStatus": {
      "type": "object",
      "properties": {
        "assigned_cluster": {
          "type": "string"
        },
        "current_replicas": {
          "type": "integer",
          "format": "int64",
          "description": "Current number of replicas."
        },
        "ingress": {
          "$ref": "#/definitions/appIngress",
          "description": "List of public URLs for the app."
        },
        "created_at": {
          "type": "string",
          "format": "date-time",
          "title": "CreatedAt is the time when the app was first created"
        },
        "last_updated_at": {
          "type": "string",
          "format": "date-time",
          "title": "LastUpdatedAt is the time when the app was last updated"
        },
        "conditions": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/appCondition"
          },
          "description": "Conditions for the app."
        },
        "lease_expiration": {
          "type": "string",
          "format": "date-time",
          "description": "LeaseExpiration refers to how long the app is leased to a cluster for it to start processing it. If the lease\nperiod expires, the cluster will no longer be allowed to update this app and another cluster can pick it up."
        },
        "k8s_metadata": {
          "$ref": "#/definitions/appK8sMetadata",
          "description": "K8sMetadata contains metadata about the app in the K8s cluster."
        },
        "materialized_inputs": {
          "$ref": "#/definitions/appMaterializedInputs"
        }
      },
      "description": "Represents the status of an app."
    },
    "flyteidl2appWatchResponse": {
      "type": "object",
      "properties": {
        "create_event": {
          "$ref": "#/definitions/appCreateEvent",
          "description": "Event for app creation."
        },
        "update_event": {
          "$ref": "#/definitions/appUpdateEvent",
          "description": "Event for app update."
        },
        "delete_event": {
          "$ref": "#/definitions/appDeleteEvent",
          "description": "Event for app deletion."
        }
      },
      "description": "Response message for watching app events."
    },
    "flyteidl2commonAction": {
      "type": "string",
      "enum": [
        "ACTION_NONE",
        "ACTION_CREATE",
        "ACTION_READ",
        "ACTION_UPDATE",
        "ACTION_DELETE",
        "ACTION_VIEW_FLYTE_INVENTORY",
        "ACTION_VIEW_FLYTE_EXECUTIONS",
        "ACTION_REGISTER_FLYTE_INVENTORY",
        "ACTION_CREATE_FLYTE_EXECUTIONS",
        "ACTION_ADMINISTER_PROJECT",
        "ACTION_MANAGE_PERMISSIONS",
        "ACTION_ADMINISTER_ACCOUNT",
        "ACTION_MANAGE_CLUSTER",
        "ACTION_EDIT_EXECUTION_RELATED_ATTRIBUTES",
        "ACTION_EDIT_CLUSTER_RELATED_ATTRIBUTES",
        "ACTION_EDIT_UNUSED_ATTRIBUTES",
        "ACTION_SUPPORT_SYSTEM_LOGS"
      ],
      "default": "ACTION_NONE",
      "title": "- ACTION_VIEW_FLYTE_INVENTORY: Read Flyte workflows, tasks and launch plans\n - ACTION_VIEW_FLYTE_EXECUTIONS: View Flyte executions\n - ACTION_REGISTER_FLYTE_INVENTORY: Register new versions of Flyte workflows, tasks and launch plans\n - ACTION_CREATE_FLYTE_EXECUTIONS: Create new Flyte workflow and task executions\n - ACTION_ADMINISTER_PROJECT: Create new projects and update project descriptions\n - ACTION_MANAGE_PERMISSIONS: Add users, roles and update role assignments.\n - ACTION_ADMINISTER_ACCOUNT: Manage billing, account-wide settings\n - ACTION_MANAGE_CLUSTER: Operations for clusters\n - ACTION_EDIT_EXECUTION_RELATED_ATTRIBUTES: Edit execution related attributes, including TASK_RESOURCE, WORKFLOW_EXECUTION_CONFIG, and EXTERNAL_RESOURCE\n - ACTION_EDIT_CLUSTER_RELATED_ATTRIBUTES: Edit cluster related attributes, including CLUSTER_RESOURCE and CLUSTER_ASSIGNMENT\n - ACTION_EDIT_UNUSED_ATTRIBUTES: Edit unused attributes, including EXECUTION_QUEUE, EXECUTION_CLUSTER_LABEL, QUALITY_OF_SERVICE_SPECIFICATION, and PLUGIN_OVERRIDE\n - ACTION_SUPPORT_SYSTEM_LOGS: View system logs"
    },
    "flyteidl2commonListRequest": {
      "type": "object",
      "properties": {
        "limit": {
          "type": "integer",
          "format": "int64",
          "title": "Indicates the number of resources to be returned.\n+required"
        },
        "token": {
          "type": "string",
          "title": "In the case of multiple pages of results, the server-provided token can be used to fetch the next page\nin a query.\n+optional"
        },
        "sort_by": {
          "$ref": "#/definitions/commonSort",
          "title": "Deprecated, use sort_by_fields instead.\nSpecifies how listed entities should be sorted in the response.\n+optional"
        },
        "filters": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/commonFilter"
          },
          "title": "Indicates a list of filters. This field is used for grpc get requests.\n+optional"
        },
        "raw_filters": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "title": "Indicates a raw list of filters passed as string.This field is used for REST get requests\n+optional"
        },
        "sort_by_fields": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/commonSort"
          },
          "title": "Specifies how listed entities should be sorted in the response.\nSort fields are applied in order.\n+optional"
        }
      }
    },
    "flyteidl2commonResource": {
      "type": "object",
      "properties": {
        "organization": {
          "$ref": "#/definitions/commonOrganization"
        },
        "domain": {
          "$ref": "#/definitions/commonDomain"
        },
        "project": {
          "$ref": "#/definitions/commonProject"
        },
        "workflow": {
          "$ref": "#/definitions/commonWorkflow"
        },
        "launch_plan": {
          "$ref": "#/definitions/commonLaunchPlan"
        },
        "cluster": {
          "$ref": "#/definitions/commonClusterIdentifier"
        }
      }
    },
    "flyteidl2commonRuntimeMetadata": {
      "type": "object",
      "properties": {
        "type": {
          "$ref": "#/definitions/flyteidl2commonRuntimeMetadataRuntimeType",
          "description": "Type of runtime."
        },
        "version": {
          "type": "string",
          "description": "Version of the runtime. All versions should be backward compatible. However, certain cases call for version\nchecks to ensure tighter validation or setting expectations."
        },
        "flavor": {
          "type": "string",
          "description": "+optional It can be used to provide extra information about the runtime (e.g. python, golang... etc.)."
        }
      },
      "description": "Runtime information. This is loosely defined to allow for extensibility."
    },
    "flyteidl2commonRuntimeMetadataRuntimeType": {
      "type": "string",
      "enum": [
        "OTHER",
        "FLYTE_SDK",
        "UNION_SDK"
      ],
      "default": "OTHER"
    },
    "flyteidl2coreIdentity": {
      "type": "object",
      "properties": {
        "iam_role": {
          "type": "string",
          "description": "iam_role references the fully qualified name of Identity \u0026 Access Management role to impersonate."
        },
        "k8s_service_account": {
          "type": "string",
          "description": "k8s_service_account references a kubernetes service account to impersonate."
        },
        "oauth2_client": {
          "$ref": "#/definitions/coreOAuth2Client",
          "description": "oauth2_client references an oauth2 client. Backend plugins can use this information to impersonate the client when\nmaking external calls."
        },
        "execution_identity": {
          "type": "string",
          "title": "execution_identity references the subject who makes the execution"
        }
      },
      "description": "Identity encapsulates the various security identities a task can run as. It's up to the underlying plugin to pick the\nright identity for the execution environment."
    },
    "flyteidl2coreSecret": {
      "type": "object",
      "properties": {
        "group": {
          "type": "string",
          "title": "The name of the secret group where to find the key referenced below. For K8s secrets, this should be the name of\nthe v1/secret object. For Confidant, this should be the Credential name. For Vault, this should be the secret name.\nFor AWS Secret Manager, this should be the name of the secret.\n+required"
        },
        "group_version": {
          "type": "string",
          "title": "The group version to fetch. This is not supported in all secret management systems. It'll be ignored for the ones\nthat do not support it.\n+optional"
        },
        "key": {
          "type": "string",
          "title": "The name of the secret to mount. This has to match an existing secret in the system. It's up to the implementation\nof the secret management system to require case sensitivity. For K8s secrets, Confidant and Vault, this should\nmatch one of the keys inside the secret. For AWS Secret Manager, it's ignored.\n+optional"
        },
        "mount_requirement": {
          "$ref": "#/definitions/SecretMountType",
          "title": "mount_requirement is optional. Indicates where the secret has to be mounted. If provided, the execution will fail\nif the underlying key management system cannot satisfy that requirement. If not provided, the default location\nwill depend on the key management system.\n+optional"
        },
        "env_var": {
          "type": "string",
          "title": "env_var is optional. Custom environment variable to set the value of the secret. If mount_requirement is ENV_VAR,\nthen the value is the secret itself. If mount_requirement is FILE, then the value is the path to the secret file.\n+optional"
        }
      },
      "description": "Secret encapsulates information about the secret a task needs to proceed. An environment variable\nFLYTE_SECRETS_ENV_PREFIX will be passed to indicate the prefix of the environment variables that will be present if\nsecrets are passed through environment variables.\nFLYTE_SECRETS_DEFAULT_DIR will be passed to indicate the prefix of the path where secrets will be mounted if secrets\nare passed through file mounts."
    },
    "googlerpcStatus": {
      "type": "object",
      "properties": {
        "code": {
          "type": "integer",
          "format": "int32",
          "description": "The status code, which should be an enum value of [google.rpc.Code][google.rpc.Code]."
        },
        "message": {
          "type": "string",
          "description": "A developer-facing error message, which should be in English. Any\nuser-facing error message should be localized and sent in the\n[google.rpc.Status.details][google.rpc.Status.details] field, or localized by the client."
        },
        "details": {
          "type": "array",
          "items": {
            "type": "object",
            "$ref": "#/definitions/protobufAny"
          },
          "description": "A list of messages that carry the error details.  There is a common set of\nmessage types for APIs to use."
        }
      },
      "description": "The `Status` type defines a logical error model that is suitable for\ndifferent programming environments, including REST APIs and RPC APIs. It is\nused by [gRPC](https://github.com/grpc). Each `Status` message contains\nthree pieces of data: error code, error message, and error details.\n\nYou can find out more about this error model and how to work with it in the\n[API Design Guide](https://cloud.google.com/apis/design/errors)."
    },
    "protobufAny": {
      "type": "object",
      "properties": {
        "@type": {
          "type": "string",
          "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com. As of May 2023, there are no widely used type server\nimplementations and no plans to implement one.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
        }
      },
      "additionalProperties": {},
      "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(\u0026foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n    // or ...\n    if (any.isSameTypeAs(Foo.getDefaultInstance())) {\n      foo = any.unpack(Foo.getDefaultInstance());\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := \u0026pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := \u0026pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": \u003cstring\u003e,\n      \"lastName\": \u003cstring\u003e\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
    },
    "protobufNullValue": {
      "type": "string",
      "enum": [
        "NULL_VALUE"
      ],
      "default": "NULL_VALUE",
      "description": "`NullValue` is a singleton enumeration to represent the null value for the\n`Value` type union.\n\nThe JSON representation for `NullValue` is JSON `null`.\n\n - NULL_VALUE: Null value."
    }
  }
}
