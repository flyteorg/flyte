// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: idl2/workflow/run_definition.proto

package workflow

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"

	core "github.com/flyteorg/flyte/v2/gen/go/idl2/core"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort

	_ = core.CatalogCacheStatus(0)
)

// Validate checks the field values on Labels with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Labels) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Labels with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in LabelsMultiError, or nil if none found.
func (m *Labels) ValidateAll() error {
	return m.validate(true)
}

func (m *Labels) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Values

	if len(errors) > 0 {
		return LabelsMultiError(errors)
	}

	return nil
}

// LabelsMultiError is an error wrapping multiple validation errors returned by
// Labels.ValidateAll() if the designated constraints aren't met.
type LabelsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LabelsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LabelsMultiError) AllErrors() []error { return m }

// LabelsValidationError is the validation error returned by Labels.Validate if
// the designated constraints aren't met.
type LabelsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LabelsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LabelsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LabelsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LabelsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LabelsValidationError) ErrorName() string { return "LabelsValidationError" }

// Error satisfies the builtin error interface
func (e LabelsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLabels.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LabelsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LabelsValidationError{}

// Validate checks the field values on Annotations with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Annotations) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Annotations with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AnnotationsMultiError, or
// nil if none found.
func (m *Annotations) ValidateAll() error {
	return m.validate(true)
}

func (m *Annotations) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Values

	if len(errors) > 0 {
		return AnnotationsMultiError(errors)
	}

	return nil
}

// AnnotationsMultiError is an error wrapping multiple validation errors
// returned by Annotations.ValidateAll() if the designated constraints aren't met.
type AnnotationsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AnnotationsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AnnotationsMultiError) AllErrors() []error { return m }

// AnnotationsValidationError is the validation error returned by
// Annotations.Validate if the designated constraints aren't met.
type AnnotationsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AnnotationsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AnnotationsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AnnotationsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AnnotationsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AnnotationsValidationError) ErrorName() string { return "AnnotationsValidationError" }

// Error satisfies the builtin error interface
func (e AnnotationsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAnnotations.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AnnotationsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AnnotationsValidationError{}

// Validate checks the field values on Envs with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Envs) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Envs with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in EnvsMultiError, or nil if none found.
func (m *Envs) ValidateAll() error {
	return m.validate(true)
}

func (m *Envs) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetValues() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, EnvsValidationError{
						field:  fmt.Sprintf("Values[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, EnvsValidationError{
						field:  fmt.Sprintf("Values[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return EnvsValidationError{
					field:  fmt.Sprintf("Values[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return EnvsMultiError(errors)
	}

	return nil
}

// EnvsMultiError is an error wrapping multiple validation errors returned by
// Envs.ValidateAll() if the designated constraints aren't met.
type EnvsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EnvsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EnvsMultiError) AllErrors() []error { return m }

// EnvsValidationError is the validation error returned by Envs.Validate if the
// designated constraints aren't met.
type EnvsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EnvsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EnvsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EnvsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EnvsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EnvsValidationError) ErrorName() string { return "EnvsValidationError" }

// Error satisfies the builtin error interface
func (e EnvsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEnvs.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EnvsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EnvsValidationError{}

// Validate checks the field values on RunSpec with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RunSpec) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RunSpec with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in RunSpecMultiError, or nil if none found.
func (m *RunSpec) ValidateAll() error {
	return m.validate(true)
}

func (m *RunSpec) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetLabels()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RunSpecValidationError{
					field:  "Labels",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RunSpecValidationError{
					field:  "Labels",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLabels()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RunSpecValidationError{
				field:  "Labels",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAnnotations()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RunSpecValidationError{
					field:  "Annotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RunSpecValidationError{
					field:  "Annotations",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAnnotations()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RunSpecValidationError{
				field:  "Annotations",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEnvs()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RunSpecValidationError{
					field:  "Envs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RunSpecValidationError{
					field:  "Envs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEnvs()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RunSpecValidationError{
				field:  "Envs",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetInterruptible()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RunSpecValidationError{
					field:  "Interruptible",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RunSpecValidationError{
					field:  "Interruptible",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetInterruptible()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RunSpecValidationError{
				field:  "Interruptible",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for OverwriteCache

	// no validation rules for Cluster

	if len(errors) > 0 {
		return RunSpecMultiError(errors)
	}

	return nil
}

// RunSpecMultiError is an error wrapping multiple validation errors returned
// by RunSpec.ValidateAll() if the designated constraints aren't met.
type RunSpecMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RunSpecMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RunSpecMultiError) AllErrors() []error { return m }

// RunSpecValidationError is the validation error returned by RunSpec.Validate
// if the designated constraints aren't met.
type RunSpecValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RunSpecValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RunSpecValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RunSpecValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RunSpecValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RunSpecValidationError) ErrorName() string { return "RunSpecValidationError" }

// Error satisfies the builtin error interface
func (e RunSpecValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRunSpec.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RunSpecValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RunSpecValidationError{}

// Validate checks the field values on Run with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Run) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Run with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in RunMultiError, or nil if none found.
func (m *Run) ValidateAll() error {
	return m.validate(true)
}

func (m *Run) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetAction()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RunValidationError{
					field:  "Action",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RunValidationError{
					field:  "Action",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RunValidationError{
				field:  "Action",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RunMultiError(errors)
	}

	return nil
}

// RunMultiError is an error wrapping multiple validation errors returned by
// Run.ValidateAll() if the designated constraints aren't met.
type RunMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RunMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RunMultiError) AllErrors() []error { return m }

// RunValidationError is the validation error returned by Run.Validate if the
// designated constraints aren't met.
type RunValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RunValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RunValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RunValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RunValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RunValidationError) ErrorName() string { return "RunValidationError" }

// Error satisfies the builtin error interface
func (e RunValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRun.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RunValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RunValidationError{}

// Validate checks the field values on RunDetails with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RunDetails) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RunDetails with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RunDetailsMultiError, or
// nil if none found.
func (m *RunDetails) ValidateAll() error {
	return m.validate(true)
}

func (m *RunDetails) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetRunSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RunDetailsValidationError{
					field:  "RunSpec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RunDetailsValidationError{
					field:  "RunSpec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRunSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RunDetailsValidationError{
				field:  "RunSpec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAction()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RunDetailsValidationError{
					field:  "Action",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RunDetailsValidationError{
					field:  "Action",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RunDetailsValidationError{
				field:  "Action",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RunDetailsMultiError(errors)
	}

	return nil
}

// RunDetailsMultiError is an error wrapping multiple validation errors
// returned by RunDetails.ValidateAll() if the designated constraints aren't met.
type RunDetailsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RunDetailsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RunDetailsMultiError) AllErrors() []error { return m }

// RunDetailsValidationError is the validation error returned by
// RunDetails.Validate if the designated constraints aren't met.
type RunDetailsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RunDetailsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RunDetailsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RunDetailsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RunDetailsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RunDetailsValidationError) ErrorName() string { return "RunDetailsValidationError" }

// Error satisfies the builtin error interface
func (e RunDetailsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRunDetails.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RunDetailsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RunDetailsValidationError{}

// Validate checks the field values on TaskActionMetadata with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TaskActionMetadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TaskActionMetadata with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TaskActionMetadataMultiError, or nil if none found.
func (m *TaskActionMetadata) ValidateAll() error {
	return m.validate(true)
}

func (m *TaskActionMetadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TaskActionMetadataValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TaskActionMetadataValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TaskActionMetadataValidationError{
				field:  "Id",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for TaskType

	// no validation rules for ShortName

	if len(errors) > 0 {
		return TaskActionMetadataMultiError(errors)
	}

	return nil
}

// TaskActionMetadataMultiError is an error wrapping multiple validation errors
// returned by TaskActionMetadata.ValidateAll() if the designated constraints
// aren't met.
type TaskActionMetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TaskActionMetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TaskActionMetadataMultiError) AllErrors() []error { return m }

// TaskActionMetadataValidationError is the validation error returned by
// TaskActionMetadata.Validate if the designated constraints aren't met.
type TaskActionMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TaskActionMetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TaskActionMetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TaskActionMetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TaskActionMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TaskActionMetadataValidationError) ErrorName() string {
	return "TaskActionMetadataValidationError"
}

// Error satisfies the builtin error interface
func (e TaskActionMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTaskActionMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TaskActionMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TaskActionMetadataValidationError{}

// Validate checks the field values on TraceActionMetadata with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TraceActionMetadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TraceActionMetadata with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TraceActionMetadataMultiError, or nil if none found.
func (m *TraceActionMetadata) ValidateAll() error {
	return m.validate(true)
}

func (m *TraceActionMetadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if len(errors) > 0 {
		return TraceActionMetadataMultiError(errors)
	}

	return nil
}

// TraceActionMetadataMultiError is an error wrapping multiple validation
// errors returned by TraceActionMetadata.ValidateAll() if the designated
// constraints aren't met.
type TraceActionMetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TraceActionMetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TraceActionMetadataMultiError) AllErrors() []error { return m }

// TraceActionMetadataValidationError is the validation error returned by
// TraceActionMetadata.Validate if the designated constraints aren't met.
type TraceActionMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TraceActionMetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TraceActionMetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TraceActionMetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TraceActionMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TraceActionMetadataValidationError) ErrorName() string {
	return "TraceActionMetadataValidationError"
}

// Error satisfies the builtin error interface
func (e TraceActionMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTraceActionMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TraceActionMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TraceActionMetadataValidationError{}

// Validate checks the field values on ConditionActionMetadata with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ConditionActionMetadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConditionActionMetadata with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ConditionActionMetadataMultiError, or nil if none found.
func (m *ConditionActionMetadata) ValidateAll() error {
	return m.validate(true)
}

func (m *ConditionActionMetadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	oneofScopePresent := false
	switch v := m.Scope.(type) {
	case *ConditionActionMetadata_RunId:
		if v == nil {
			err := ConditionActionMetadataValidationError{
				field:  "Scope",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofScopePresent = true

		if utf8.RuneCountInString(m.GetRunId()) < 1 {
			err := ConditionActionMetadataValidationError{
				field:  "RunId",
				reason: "value length must be at least 1 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	case *ConditionActionMetadata_ActionId:
		if v == nil {
			err := ConditionActionMetadataValidationError{
				field:  "Scope",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofScopePresent = true

		if utf8.RuneCountInString(m.GetActionId()) < 1 {
			err := ConditionActionMetadataValidationError{
				field:  "ActionId",
				reason: "value length must be at least 1 runes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	case *ConditionActionMetadata_Global:
		if v == nil {
			err := ConditionActionMetadataValidationError{
				field:  "Scope",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		oneofScopePresent = true
		// no validation rules for Global
	default:
		_ = v // ensures v is used
	}
	if !oneofScopePresent {
		err := ConditionActionMetadataValidationError{
			field:  "Scope",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ConditionActionMetadataMultiError(errors)
	}

	return nil
}

// ConditionActionMetadataMultiError is an error wrapping multiple validation
// errors returned by ConditionActionMetadata.ValidateAll() if the designated
// constraints aren't met.
type ConditionActionMetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConditionActionMetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConditionActionMetadataMultiError) AllErrors() []error { return m }

// ConditionActionMetadataValidationError is the validation error returned by
// ConditionActionMetadata.Validate if the designated constraints aren't met.
type ConditionActionMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConditionActionMetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConditionActionMetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConditionActionMetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConditionActionMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConditionActionMetadataValidationError) ErrorName() string {
	return "ConditionActionMetadataValidationError"
}

// Error satisfies the builtin error interface
func (e ConditionActionMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConditionActionMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConditionActionMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConditionActionMetadataValidationError{}

// Validate checks the field values on ActionMetadata with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ActionMetadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ActionMetadata with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ActionMetadataMultiError,
// or nil if none found.
func (m *ActionMetadata) ValidateAll() error {
	return m.validate(true)
}

func (m *ActionMetadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Parent

	// no validation rules for Group

	if all {
		switch v := interface{}(m.GetExecutedBy()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ActionMetadataValidationError{
					field:  "ExecutedBy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ActionMetadataValidationError{
					field:  "ExecutedBy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetExecutedBy()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ActionMetadataValidationError{
				field:  "ExecutedBy",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	switch v := m.Spec.(type) {
	case *ActionMetadata_Task:
		if v == nil {
			err := ActionMetadataValidationError{
				field:  "Spec",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if m.GetTask() == nil {
			err := ActionMetadataValidationError{
				field:  "Task",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTask()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ActionMetadataValidationError{
						field:  "Task",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ActionMetadataValidationError{
						field:  "Task",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTask()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ActionMetadataValidationError{
					field:  "Task",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ActionMetadata_Trace:
		if v == nil {
			err := ActionMetadataValidationError{
				field:  "Spec",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if m.GetTrace() == nil {
			err := ActionMetadataValidationError{
				field:  "Trace",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTrace()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ActionMetadataValidationError{
						field:  "Trace",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ActionMetadataValidationError{
						field:  "Trace",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTrace()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ActionMetadataValidationError{
					field:  "Trace",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ActionMetadata_Condition:
		if v == nil {
			err := ActionMetadataValidationError{
				field:  "Spec",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if m.GetCondition() == nil {
			err := ActionMetadataValidationError{
				field:  "Condition",
				reason: "value is required",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCondition()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ActionMetadataValidationError{
						field:  "Condition",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ActionMetadataValidationError{
						field:  "Condition",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCondition()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ActionMetadataValidationError{
					field:  "Condition",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ActionMetadataMultiError(errors)
	}

	return nil
}

// ActionMetadataMultiError is an error wrapping multiple validation errors
// returned by ActionMetadata.ValidateAll() if the designated constraints
// aren't met.
type ActionMetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ActionMetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ActionMetadataMultiError) AllErrors() []error { return m }

// ActionMetadataValidationError is the validation error returned by
// ActionMetadata.Validate if the designated constraints aren't met.
type ActionMetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ActionMetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ActionMetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ActionMetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ActionMetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ActionMetadataValidationError) ErrorName() string { return "ActionMetadataValidationError" }

// Error satisfies the builtin error interface
func (e ActionMetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sActionMetadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ActionMetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ActionMetadataValidationError{}

// Validate checks the field values on ActionStatus with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ActionStatus) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ActionStatus with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ActionStatusMultiError, or
// nil if none found.
func (m *ActionStatus) ValidateAll() error {
	return m.validate(true)
}

func (m *ActionStatus) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Phase

	if all {
		switch v := interface{}(m.GetStartTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ActionStatusValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ActionStatusValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ActionStatusValidationError{
				field:  "StartTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetAttempts() <= 0 {
		err := ActionStatusValidationError{
			field:  "Attempts",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for CacheStatus

	if m.EndTime != nil {

		if all {
			switch v := interface{}(m.GetEndTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ActionStatusValidationError{
						field:  "EndTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ActionStatusValidationError{
						field:  "EndTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEndTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ActionStatusValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ActionStatusMultiError(errors)
	}

	return nil
}

// ActionStatusMultiError is an error wrapping multiple validation errors
// returned by ActionStatus.ValidateAll() if the designated constraints aren't met.
type ActionStatusMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ActionStatusMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ActionStatusMultiError) AllErrors() []error { return m }

// ActionStatusValidationError is the validation error returned by
// ActionStatus.Validate if the designated constraints aren't met.
type ActionStatusValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ActionStatusValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ActionStatusValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ActionStatusValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ActionStatusValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ActionStatusValidationError) ErrorName() string { return "ActionStatusValidationError" }

// Error satisfies the builtin error interface
func (e ActionStatusValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sActionStatus.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ActionStatusValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ActionStatusValidationError{}

// Validate checks the field values on Action with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Action) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Action with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ActionMultiError, or nil if none found.
func (m *Action) ValidateAll() error {
	return m.validate(true)
}

func (m *Action) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ActionValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ActionValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ActionValidationError{
				field:  "Id",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ActionValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ActionValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ActionValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetStatus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ActionValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ActionValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStatus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ActionValidationError{
				field:  "Status",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ActionMultiError(errors)
	}

	return nil
}

// ActionMultiError is an error wrapping multiple validation errors returned by
// Action.ValidateAll() if the designated constraints aren't met.
type ActionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ActionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ActionMultiError) AllErrors() []error { return m }

// ActionValidationError is the validation error returned by Action.Validate if
// the designated constraints aren't met.
type ActionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ActionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ActionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ActionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ActionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ActionValidationError) ErrorName() string { return "ActionValidationError" }

// Error satisfies the builtin error interface
func (e ActionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ActionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ActionValidationError{}

// Validate checks the field values on EnrichedAction with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EnrichedAction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EnrichedAction with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EnrichedActionMultiError,
// or nil if none found.
func (m *EnrichedAction) ValidateAll() error {
	return m.validate(true)
}

func (m *EnrichedAction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetAction()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EnrichedActionValidationError{
					field:  "Action",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EnrichedActionValidationError{
					field:  "Action",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAction()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EnrichedActionValidationError{
				field:  "Action",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for MeetsFilter

	// no validation rules for ChildrenPhaseCounts

	if len(errors) > 0 {
		return EnrichedActionMultiError(errors)
	}

	return nil
}

// EnrichedActionMultiError is an error wrapping multiple validation errors
// returned by EnrichedAction.ValidateAll() if the designated constraints
// aren't met.
type EnrichedActionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EnrichedActionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EnrichedActionMultiError) AllErrors() []error { return m }

// EnrichedActionValidationError is the validation error returned by
// EnrichedAction.Validate if the designated constraints aren't met.
type EnrichedActionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EnrichedActionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EnrichedActionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EnrichedActionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EnrichedActionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EnrichedActionValidationError) ErrorName() string { return "EnrichedActionValidationError" }

// Error satisfies the builtin error interface
func (e EnrichedActionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEnrichedAction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EnrichedActionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EnrichedActionValidationError{}

// Validate checks the field values on ErrorInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ErrorInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ErrorInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ErrorInfoMultiError, or nil
// if none found.
func (m *ErrorInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *ErrorInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Message

	// no validation rules for Kind

	if len(errors) > 0 {
		return ErrorInfoMultiError(errors)
	}

	return nil
}

// ErrorInfoMultiError is an error wrapping multiple validation errors returned
// by ErrorInfo.ValidateAll() if the designated constraints aren't met.
type ErrorInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ErrorInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ErrorInfoMultiError) AllErrors() []error { return m }

// ErrorInfoValidationError is the validation error returned by
// ErrorInfo.Validate if the designated constraints aren't met.
type ErrorInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ErrorInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ErrorInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ErrorInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ErrorInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ErrorInfoValidationError) ErrorName() string { return "ErrorInfoValidationError" }

// Error satisfies the builtin error interface
func (e ErrorInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sErrorInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ErrorInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ErrorInfoValidationError{}

// Validate checks the field values on AbortInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AbortInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AbortInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AbortInfoMultiError, or nil
// if none found.
func (m *AbortInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *AbortInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Reason

	if all {
		switch v := interface{}(m.GetAbortedBy()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AbortInfoValidationError{
					field:  "AbortedBy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AbortInfoValidationError{
					field:  "AbortedBy",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAbortedBy()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AbortInfoValidationError{
				field:  "AbortedBy",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AbortInfoMultiError(errors)
	}

	return nil
}

// AbortInfoMultiError is an error wrapping multiple validation errors returned
// by AbortInfo.ValidateAll() if the designated constraints aren't met.
type AbortInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AbortInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AbortInfoMultiError) AllErrors() []error { return m }

// AbortInfoValidationError is the validation error returned by
// AbortInfo.Validate if the designated constraints aren't met.
type AbortInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AbortInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AbortInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AbortInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AbortInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AbortInfoValidationError) ErrorName() string { return "AbortInfoValidationError" }

// Error satisfies the builtin error interface
func (e AbortInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAbortInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AbortInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AbortInfoValidationError{}

// Validate checks the field values on ActionDetails with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ActionDetails) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ActionDetails with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ActionDetailsMultiError, or
// nil if none found.
func (m *ActionDetails) ValidateAll() error {
	return m.validate(true)
}

func (m *ActionDetails) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ActionDetailsValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ActionDetailsValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ActionDetailsValidationError{
				field:  "Id",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMetadata()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ActionDetailsValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ActionDetailsValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ActionDetailsValidationError{
				field:  "Metadata",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetStatus()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ActionDetailsValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ActionDetailsValidationError{
					field:  "Status",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStatus()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ActionDetailsValidationError{
				field:  "Status",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetResolvedTaskSpec()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ActionDetailsValidationError{
					field:  "ResolvedTaskSpec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ActionDetailsValidationError{
					field:  "ResolvedTaskSpec",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetResolvedTaskSpec()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ActionDetailsValidationError{
				field:  "ResolvedTaskSpec",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetAttempts() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ActionDetailsValidationError{
						field:  fmt.Sprintf("Attempts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ActionDetailsValidationError{
						field:  fmt.Sprintf("Attempts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ActionDetailsValidationError{
					field:  fmt.Sprintf("Attempts[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	switch v := m.Result.(type) {
	case *ActionDetails_ErrorInfo:
		if v == nil {
			err := ActionDetailsValidationError{
				field:  "Result",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetErrorInfo()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ActionDetailsValidationError{
						field:  "ErrorInfo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ActionDetailsValidationError{
						field:  "ErrorInfo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetErrorInfo()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ActionDetailsValidationError{
					field:  "ErrorInfo",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *ActionDetails_AbortInfo:
		if v == nil {
			err := ActionDetailsValidationError{
				field:  "Result",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAbortInfo()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ActionDetailsValidationError{
						field:  "AbortInfo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ActionDetailsValidationError{
						field:  "AbortInfo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAbortInfo()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ActionDetailsValidationError{
					field:  "AbortInfo",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ActionDetailsMultiError(errors)
	}

	return nil
}

// ActionDetailsMultiError is an error wrapping multiple validation errors
// returned by ActionDetails.ValidateAll() if the designated constraints
// aren't met.
type ActionDetailsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ActionDetailsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ActionDetailsMultiError) AllErrors() []error { return m }

// ActionDetailsValidationError is the validation error returned by
// ActionDetails.Validate if the designated constraints aren't met.
type ActionDetailsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ActionDetailsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ActionDetailsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ActionDetailsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ActionDetailsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ActionDetailsValidationError) ErrorName() string { return "ActionDetailsValidationError" }

// Error satisfies the builtin error interface
func (e ActionDetailsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sActionDetails.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ActionDetailsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ActionDetailsValidationError{}

// Validate checks the field values on ActionAttempt with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ActionAttempt) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ActionAttempt with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ActionAttemptMultiError, or
// nil if none found.
func (m *ActionAttempt) ValidateAll() error {
	return m.validate(true)
}

func (m *ActionAttempt) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Phase

	if all {
		switch v := interface{}(m.GetStartTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ActionAttemptValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ActionAttemptValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ActionAttemptValidationError{
				field:  "StartTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetAttempt() <= 0 {
		err := ActionAttemptValidationError{
			field:  "Attempt",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetLogInfo() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ActionAttemptValidationError{
						field:  fmt.Sprintf("LogInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ActionAttemptValidationError{
						field:  fmt.Sprintf("LogInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ActionAttemptValidationError{
					field:  fmt.Sprintf("LogInfo[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetOutputs()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ActionAttemptValidationError{
					field:  "Outputs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ActionAttemptValidationError{
					field:  "Outputs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutputs()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ActionAttemptValidationError{
				field:  "Outputs",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for LogsAvailable

	// no validation rules for CacheStatus

	for idx, item := range m.GetClusterEvents() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ActionAttemptValidationError{
						field:  fmt.Sprintf("ClusterEvents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ActionAttemptValidationError{
						field:  fmt.Sprintf("ClusterEvents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ActionAttemptValidationError{
					field:  fmt.Sprintf("ClusterEvents[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetPhaseTransitions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ActionAttemptValidationError{
						field:  fmt.Sprintf("PhaseTransitions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ActionAttemptValidationError{
						field:  fmt.Sprintf("PhaseTransitions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ActionAttemptValidationError{
					field:  fmt.Sprintf("PhaseTransitions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Cluster

	if all {
		switch v := interface{}(m.GetLogContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ActionAttemptValidationError{
					field:  "LogContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ActionAttemptValidationError{
					field:  "LogContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLogContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ActionAttemptValidationError{
				field:  "LogContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.EndTime != nil {

		if all {
			switch v := interface{}(m.GetEndTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ActionAttemptValidationError{
						field:  "EndTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ActionAttemptValidationError{
						field:  "EndTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEndTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ActionAttemptValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.ErrorInfo != nil {

		if all {
			switch v := interface{}(m.GetErrorInfo()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ActionAttemptValidationError{
						field:  "ErrorInfo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ActionAttemptValidationError{
						field:  "ErrorInfo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetErrorInfo()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ActionAttemptValidationError{
					field:  "ErrorInfo",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ActionAttemptMultiError(errors)
	}

	return nil
}

// ActionAttemptMultiError is an error wrapping multiple validation errors
// returned by ActionAttempt.ValidateAll() if the designated constraints
// aren't met.
type ActionAttemptMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ActionAttemptMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ActionAttemptMultiError) AllErrors() []error { return m }

// ActionAttemptValidationError is the validation error returned by
// ActionAttempt.Validate if the designated constraints aren't met.
type ActionAttemptValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ActionAttemptValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ActionAttemptValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ActionAttemptValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ActionAttemptValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ActionAttemptValidationError) ErrorName() string { return "ActionAttemptValidationError" }

// Error satisfies the builtin error interface
func (e ActionAttemptValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sActionAttempt.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ActionAttemptValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ActionAttemptValidationError{}

// Validate checks the field values on ClusterEvent with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ClusterEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ClusterEvent with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ClusterEventMultiError, or
// nil if none found.
func (m *ClusterEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *ClusterEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetOccurredAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ClusterEventValidationError{
					field:  "OccurredAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ClusterEventValidationError{
					field:  "OccurredAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOccurredAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ClusterEventValidationError{
				field:  "OccurredAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Message

	if len(errors) > 0 {
		return ClusterEventMultiError(errors)
	}

	return nil
}

// ClusterEventMultiError is an error wrapping multiple validation errors
// returned by ClusterEvent.ValidateAll() if the designated constraints aren't met.
type ClusterEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ClusterEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ClusterEventMultiError) AllErrors() []error { return m }

// ClusterEventValidationError is the validation error returned by
// ClusterEvent.Validate if the designated constraints aren't met.
type ClusterEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ClusterEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ClusterEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ClusterEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ClusterEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ClusterEventValidationError) ErrorName() string { return "ClusterEventValidationError" }

// Error satisfies the builtin error interface
func (e ClusterEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sClusterEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ClusterEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ClusterEventValidationError{}

// Validate checks the field values on PhaseTransition with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PhaseTransition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PhaseTransition with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PhaseTransitionMultiError, or nil if none found.
func (m *PhaseTransition) ValidateAll() error {
	return m.validate(true)
}

func (m *PhaseTransition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Phase

	if all {
		switch v := interface{}(m.GetStartTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PhaseTransitionValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PhaseTransitionValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PhaseTransitionValidationError{
				field:  "StartTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.EndTime != nil {

		if all {
			switch v := interface{}(m.GetEndTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PhaseTransitionValidationError{
						field:  "EndTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PhaseTransitionValidationError{
						field:  "EndTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEndTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PhaseTransitionValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return PhaseTransitionMultiError(errors)
	}

	return nil
}

// PhaseTransitionMultiError is an error wrapping multiple validation errors
// returned by PhaseTransition.ValidateAll() if the designated constraints
// aren't met.
type PhaseTransitionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PhaseTransitionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PhaseTransitionMultiError) AllErrors() []error { return m }

// PhaseTransitionValidationError is the validation error returned by
// PhaseTransition.Validate if the designated constraints aren't met.
type PhaseTransitionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PhaseTransitionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PhaseTransitionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PhaseTransitionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PhaseTransitionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PhaseTransitionValidationError) ErrorName() string { return "PhaseTransitionValidationError" }

// Error satisfies the builtin error interface
func (e PhaseTransitionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPhaseTransition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PhaseTransitionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PhaseTransitionValidationError{}

// Validate checks the field values on ActionEvent with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ActionEvent) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ActionEvent with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ActionEventMultiError, or
// nil if none found.
func (m *ActionEvent) ValidateAll() error {
	return m.validate(true)
}

func (m *ActionEvent) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetId() == nil {
		err := ActionEventValidationError{
			field:  "Id",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetId()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ActionEventValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ActionEventValidationError{
					field:  "Id",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetId()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ActionEventValidationError{
				field:  "Id",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.GetAttempt() <= 0 {
		err := ActionEventValidationError{
			field:  "Attempt",
			reason: "value must be greater than 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Phase

	// no validation rules for Version

	if all {
		switch v := interface{}(m.GetStartTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ActionEventValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ActionEventValidationError{
					field:  "StartTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStartTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ActionEventValidationError{
				field:  "StartTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ActionEventValidationError{
					field:  "UpdatedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ActionEventValidationError{
					field:  "UpdatedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ActionEventValidationError{
				field:  "UpdatedTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	for idx, item := range m.GetLogInfo() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ActionEventValidationError{
						field:  fmt.Sprintf("LogInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ActionEventValidationError{
						field:  fmt.Sprintf("LogInfo[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ActionEventValidationError{
					field:  fmt.Sprintf("LogInfo[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetLogContext()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ActionEventValidationError{
					field:  "LogContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ActionEventValidationError{
					field:  "LogContext",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLogContext()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ActionEventValidationError{
				field:  "LogContext",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Cluster

	if all {
		switch v := interface{}(m.GetOutputs()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ActionEventValidationError{
					field:  "Outputs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ActionEventValidationError{
					field:  "Outputs",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOutputs()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ActionEventValidationError{
				field:  "Outputs",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for CacheStatus

	for idx, item := range m.GetClusterEvents() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ActionEventValidationError{
						field:  fmt.Sprintf("ClusterEvents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ActionEventValidationError{
						field:  fmt.Sprintf("ClusterEvents[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ActionEventValidationError{
					field:  fmt.Sprintf("ClusterEvents[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetReportedTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ActionEventValidationError{
					field:  "ReportedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ActionEventValidationError{
					field:  "ReportedTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetReportedTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ActionEventValidationError{
				field:  "ReportedTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.EndTime != nil {

		if all {
			switch v := interface{}(m.GetEndTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ActionEventValidationError{
						field:  "EndTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ActionEventValidationError{
						field:  "EndTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEndTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ActionEventValidationError{
					field:  "EndTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.ErrorInfo != nil {

		if all {
			switch v := interface{}(m.GetErrorInfo()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ActionEventValidationError{
						field:  "ErrorInfo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ActionEventValidationError{
						field:  "ErrorInfo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetErrorInfo()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ActionEventValidationError{
					field:  "ErrorInfo",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ActionEventMultiError(errors)
	}

	return nil
}

// ActionEventMultiError is an error wrapping multiple validation errors
// returned by ActionEvent.ValidateAll() if the designated constraints aren't met.
type ActionEventMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ActionEventMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ActionEventMultiError) AllErrors() []error { return m }

// ActionEventValidationError is the validation error returned by
// ActionEvent.Validate if the designated constraints aren't met.
type ActionEventValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ActionEventValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ActionEventValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ActionEventValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ActionEventValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ActionEventValidationError) ErrorName() string { return "ActionEventValidationError" }

// Error satisfies the builtin error interface
func (e ActionEventValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sActionEvent.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ActionEventValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ActionEventValidationError{}

// Validate checks the field values on NamedLiteral with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NamedLiteral) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NamedLiteral with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NamedLiteralMultiError, or
// nil if none found.
func (m *NamedLiteral) ValidateAll() error {
	return m.validate(true)
}

func (m *NamedLiteral) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if all {
		switch v := interface{}(m.GetValue()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NamedLiteralValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NamedLiteralValidationError{
					field:  "Value",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetValue()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NamedLiteralValidationError{
				field:  "Value",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return NamedLiteralMultiError(errors)
	}

	return nil
}

// NamedLiteralMultiError is an error wrapping multiple validation errors
// returned by NamedLiteral.ValidateAll() if the designated constraints aren't met.
type NamedLiteralMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NamedLiteralMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NamedLiteralMultiError) AllErrors() []error { return m }

// NamedLiteralValidationError is the validation error returned by
// NamedLiteral.Validate if the designated constraints aren't met.
type NamedLiteralValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NamedLiteralValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NamedLiteralValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NamedLiteralValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NamedLiteralValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NamedLiteralValidationError) ErrorName() string { return "NamedLiteralValidationError" }

// Error satisfies the builtin error interface
func (e NamedLiteralValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNamedLiteral.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NamedLiteralValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NamedLiteralValidationError{}

// Validate checks the field values on OutputReferences with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *OutputReferences) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OutputReferences with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// OutputReferencesMultiError, or nil if none found.
func (m *OutputReferences) ValidateAll() error {
	return m.validate(true)
}

func (m *OutputReferences) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OutputUri

	// no validation rules for ReportUri

	if len(errors) > 0 {
		return OutputReferencesMultiError(errors)
	}

	return nil
}

// OutputReferencesMultiError is an error wrapping multiple validation errors
// returned by OutputReferences.ValidateAll() if the designated constraints
// aren't met.
type OutputReferencesMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OutputReferencesMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OutputReferencesMultiError) AllErrors() []error { return m }

// OutputReferencesValidationError is the validation error returned by
// OutputReferences.Validate if the designated constraints aren't met.
type OutputReferencesValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OutputReferencesValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OutputReferencesValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OutputReferencesValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OutputReferencesValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OutputReferencesValidationError) ErrorName() string { return "OutputReferencesValidationError" }

// Error satisfies the builtin error interface
func (e OutputReferencesValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOutputReferences.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OutputReferencesValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OutputReferencesValidationError{}

// Validate checks the field values on Inputs with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Inputs) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Inputs with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in InputsMultiError, or nil if none found.
func (m *Inputs) ValidateAll() error {
	return m.validate(true)
}

func (m *Inputs) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetLiterals() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InputsValidationError{
						field:  fmt.Sprintf("Literals[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InputsValidationError{
						field:  fmt.Sprintf("Literals[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InputsValidationError{
					field:  fmt.Sprintf("Literals[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetContext() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, InputsValidationError{
						field:  fmt.Sprintf("Context[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, InputsValidationError{
						field:  fmt.Sprintf("Context[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return InputsValidationError{
					field:  fmt.Sprintf("Context[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return InputsMultiError(errors)
	}

	return nil
}

// InputsMultiError is an error wrapping multiple validation errors returned by
// Inputs.ValidateAll() if the designated constraints aren't met.
type InputsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InputsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InputsMultiError) AllErrors() []error { return m }

// InputsValidationError is the validation error returned by Inputs.Validate if
// the designated constraints aren't met.
type InputsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InputsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InputsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InputsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InputsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InputsValidationError) ErrorName() string { return "InputsValidationError" }

// Error satisfies the builtin error interface
func (e InputsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInputs.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InputsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InputsValidationError{}

// Validate checks the field values on Outputs with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Outputs) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Outputs with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in OutputsMultiError, or nil if none found.
func (m *Outputs) ValidateAll() error {
	return m.validate(true)
}

func (m *Outputs) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetLiterals() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OutputsValidationError{
						field:  fmt.Sprintf("Literals[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OutputsValidationError{
						field:  fmt.Sprintf("Literals[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OutputsValidationError{
					field:  fmt.Sprintf("Literals[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return OutputsMultiError(errors)
	}

	return nil
}

// OutputsMultiError is an error wrapping multiple validation errors returned
// by Outputs.ValidateAll() if the designated constraints aren't met.
type OutputsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OutputsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OutputsMultiError) AllErrors() []error { return m }

// OutputsValidationError is the validation error returned by Outputs.Validate
// if the designated constraints aren't met.
type OutputsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OutputsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OutputsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OutputsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OutputsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OutputsValidationError) ErrorName() string { return "OutputsValidationError" }

// Error satisfies the builtin error interface
func (e OutputsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOutputs.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OutputsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OutputsValidationError{}
