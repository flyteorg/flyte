// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             (unknown)
// source: idl2/workflow/run_service.proto

package workflow

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	RunService_CreateRun_FullMethodName          = "/flyteidl.workflow.RunService/CreateRun"
	RunService_AbortRun_FullMethodName           = "/flyteidl.workflow.RunService/AbortRun"
	RunService_GetRunDetails_FullMethodName      = "/flyteidl.workflow.RunService/GetRunDetails"
	RunService_WatchRunDetails_FullMethodName    = "/flyteidl.workflow.RunService/WatchRunDetails"
	RunService_GetActionDetails_FullMethodName   = "/flyteidl.workflow.RunService/GetActionDetails"
	RunService_WatchActionDetails_FullMethodName = "/flyteidl.workflow.RunService/WatchActionDetails"
	RunService_GetActionData_FullMethodName      = "/flyteidl.workflow.RunService/GetActionData"
	RunService_ListRuns_FullMethodName           = "/flyteidl.workflow.RunService/ListRuns"
	RunService_WatchRuns_FullMethodName          = "/flyteidl.workflow.RunService/WatchRuns"
	RunService_ListActions_FullMethodName        = "/flyteidl.workflow.RunService/ListActions"
	RunService_WatchActions_FullMethodName       = "/flyteidl.workflow.RunService/WatchActions"
	RunService_WatchClusterEvents_FullMethodName = "/flyteidl.workflow.RunService/WatchClusterEvents"
	RunService_AbortAction_FullMethodName        = "/flyteidl.workflow.RunService/AbortAction"
)

// RunServiceClient is the client API for RunService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RunServiceClient interface {
	// Create a new run of the given task.
	CreateRun(ctx context.Context, in *CreateRunRequest, opts ...grpc.CallOption) (*CreateRunResponse, error)
	// Abort a run.
	AbortRun(ctx context.Context, in *AbortRunRequest, opts ...grpc.CallOption) (*AbortRunResponse, error)
	// Get detailed information about a run.
	GetRunDetails(ctx context.Context, in *GetRunDetailsRequest, opts ...grpc.CallOption) (*GetRunDetailsResponse, error)
	// Stream detailed information updates about a run. The call will terminate when the run reaches a terminal phase.
	WatchRunDetails(ctx context.Context, in *WatchRunDetailsRequest, opts ...grpc.CallOption) (RunService_WatchRunDetailsClient, error)
	// Get detailed information about an action.
	GetActionDetails(ctx context.Context, in *GetActionDetailsRequest, opts ...grpc.CallOption) (*GetActionDetailsResponse, error)
	// Stream detailed information updates about an action. The call will terminate when the action reaches a terminal phase.
	WatchActionDetails(ctx context.Context, in *WatchActionDetailsRequest, opts ...grpc.CallOption) (RunService_WatchActionDetailsClient, error)
	// Get input and output for an action.
	GetActionData(ctx context.Context, in *GetActionDataRequest, opts ...grpc.CallOption) (*GetActionDataResponse, error)
	// List runs based on the provided filter criteria.
	ListRuns(ctx context.Context, in *ListRunsRequest, opts ...grpc.CallOption) (*ListRunsResponse, error)
	// Stream updates for runs based on the provided filter criteria. Responses may include newly discovered
	// runs or updates to existing ones from the point of invocation.
	WatchRuns(ctx context.Context, in *WatchRunsRequest, opts ...grpc.CallOption) (RunService_WatchRunsClient, error)
	// List all actions for a given run.
	ListActions(ctx context.Context, in *ListActionsRequest, opts ...grpc.CallOption) (*ListActionsResponse, error)
	// Stream updates for actions given a run. Responses may include newly discovered nested runs or updates
	// to  existing ones from the point of invocation.
	WatchActions(ctx context.Context, in *WatchActionsRequest, opts ...grpc.CallOption) (RunService_WatchActionsClient, error)
	// Stream of k8s cluster events in human readable form
	WatchClusterEvents(ctx context.Context, in *WatchClusterEventsRequest, opts ...grpc.CallOption) (RunService_WatchClusterEventsClient, error)
	// AbortAction aborts a single action that was previously created or is currently being processed by a worker.
	AbortAction(ctx context.Context, in *AbortActionRequest, opts ...grpc.CallOption) (*AbortActionResponse, error)
}

type runServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewRunServiceClient(cc grpc.ClientConnInterface) RunServiceClient {
	return &runServiceClient{cc}
}

func (c *runServiceClient) CreateRun(ctx context.Context, in *CreateRunRequest, opts ...grpc.CallOption) (*CreateRunResponse, error) {
	out := new(CreateRunResponse)
	err := c.cc.Invoke(ctx, RunService_CreateRun_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runServiceClient) AbortRun(ctx context.Context, in *AbortRunRequest, opts ...grpc.CallOption) (*AbortRunResponse, error) {
	out := new(AbortRunResponse)
	err := c.cc.Invoke(ctx, RunService_AbortRun_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runServiceClient) GetRunDetails(ctx context.Context, in *GetRunDetailsRequest, opts ...grpc.CallOption) (*GetRunDetailsResponse, error) {
	out := new(GetRunDetailsResponse)
	err := c.cc.Invoke(ctx, RunService_GetRunDetails_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runServiceClient) WatchRunDetails(ctx context.Context, in *WatchRunDetailsRequest, opts ...grpc.CallOption) (RunService_WatchRunDetailsClient, error) {
	stream, err := c.cc.NewStream(ctx, &RunService_ServiceDesc.Streams[0], RunService_WatchRunDetails_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &runServiceWatchRunDetailsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type RunService_WatchRunDetailsClient interface {
	Recv() (*WatchRunDetailsResponse, error)
	grpc.ClientStream
}

type runServiceWatchRunDetailsClient struct {
	grpc.ClientStream
}

func (x *runServiceWatchRunDetailsClient) Recv() (*WatchRunDetailsResponse, error) {
	m := new(WatchRunDetailsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *runServiceClient) GetActionDetails(ctx context.Context, in *GetActionDetailsRequest, opts ...grpc.CallOption) (*GetActionDetailsResponse, error) {
	out := new(GetActionDetailsResponse)
	err := c.cc.Invoke(ctx, RunService_GetActionDetails_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runServiceClient) WatchActionDetails(ctx context.Context, in *WatchActionDetailsRequest, opts ...grpc.CallOption) (RunService_WatchActionDetailsClient, error) {
	stream, err := c.cc.NewStream(ctx, &RunService_ServiceDesc.Streams[1], RunService_WatchActionDetails_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &runServiceWatchActionDetailsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type RunService_WatchActionDetailsClient interface {
	Recv() (*WatchActionDetailsResponse, error)
	grpc.ClientStream
}

type runServiceWatchActionDetailsClient struct {
	grpc.ClientStream
}

func (x *runServiceWatchActionDetailsClient) Recv() (*WatchActionDetailsResponse, error) {
	m := new(WatchActionDetailsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *runServiceClient) GetActionData(ctx context.Context, in *GetActionDataRequest, opts ...grpc.CallOption) (*GetActionDataResponse, error) {
	out := new(GetActionDataResponse)
	err := c.cc.Invoke(ctx, RunService_GetActionData_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runServiceClient) ListRuns(ctx context.Context, in *ListRunsRequest, opts ...grpc.CallOption) (*ListRunsResponse, error) {
	out := new(ListRunsResponse)
	err := c.cc.Invoke(ctx, RunService_ListRuns_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runServiceClient) WatchRuns(ctx context.Context, in *WatchRunsRequest, opts ...grpc.CallOption) (RunService_WatchRunsClient, error) {
	stream, err := c.cc.NewStream(ctx, &RunService_ServiceDesc.Streams[2], RunService_WatchRuns_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &runServiceWatchRunsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type RunService_WatchRunsClient interface {
	Recv() (*WatchRunsResponse, error)
	grpc.ClientStream
}

type runServiceWatchRunsClient struct {
	grpc.ClientStream
}

func (x *runServiceWatchRunsClient) Recv() (*WatchRunsResponse, error) {
	m := new(WatchRunsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *runServiceClient) ListActions(ctx context.Context, in *ListActionsRequest, opts ...grpc.CallOption) (*ListActionsResponse, error) {
	out := new(ListActionsResponse)
	err := c.cc.Invoke(ctx, RunService_ListActions_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *runServiceClient) WatchActions(ctx context.Context, in *WatchActionsRequest, opts ...grpc.CallOption) (RunService_WatchActionsClient, error) {
	stream, err := c.cc.NewStream(ctx, &RunService_ServiceDesc.Streams[3], RunService_WatchActions_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &runServiceWatchActionsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type RunService_WatchActionsClient interface {
	Recv() (*WatchActionsResponse, error)
	grpc.ClientStream
}

type runServiceWatchActionsClient struct {
	grpc.ClientStream
}

func (x *runServiceWatchActionsClient) Recv() (*WatchActionsResponse, error) {
	m := new(WatchActionsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *runServiceClient) WatchClusterEvents(ctx context.Context, in *WatchClusterEventsRequest, opts ...grpc.CallOption) (RunService_WatchClusterEventsClient, error) {
	stream, err := c.cc.NewStream(ctx, &RunService_ServiceDesc.Streams[4], RunService_WatchClusterEvents_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &runServiceWatchClusterEventsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type RunService_WatchClusterEventsClient interface {
	Recv() (*WatchClusterEventsResponse, error)
	grpc.ClientStream
}

type runServiceWatchClusterEventsClient struct {
	grpc.ClientStream
}

func (x *runServiceWatchClusterEventsClient) Recv() (*WatchClusterEventsResponse, error) {
	m := new(WatchClusterEventsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *runServiceClient) AbortAction(ctx context.Context, in *AbortActionRequest, opts ...grpc.CallOption) (*AbortActionResponse, error) {
	out := new(AbortActionResponse)
	err := c.cc.Invoke(ctx, RunService_AbortAction_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RunServiceServer is the server API for RunService service.
// All implementations should embed UnimplementedRunServiceServer
// for forward compatibility
type RunServiceServer interface {
	// Create a new run of the given task.
	CreateRun(context.Context, *CreateRunRequest) (*CreateRunResponse, error)
	// Abort a run.
	AbortRun(context.Context, *AbortRunRequest) (*AbortRunResponse, error)
	// Get detailed information about a run.
	GetRunDetails(context.Context, *GetRunDetailsRequest) (*GetRunDetailsResponse, error)
	// Stream detailed information updates about a run. The call will terminate when the run reaches a terminal phase.
	WatchRunDetails(*WatchRunDetailsRequest, RunService_WatchRunDetailsServer) error
	// Get detailed information about an action.
	GetActionDetails(context.Context, *GetActionDetailsRequest) (*GetActionDetailsResponse, error)
	// Stream detailed information updates about an action. The call will terminate when the action reaches a terminal phase.
	WatchActionDetails(*WatchActionDetailsRequest, RunService_WatchActionDetailsServer) error
	// Get input and output for an action.
	GetActionData(context.Context, *GetActionDataRequest) (*GetActionDataResponse, error)
	// List runs based on the provided filter criteria.
	ListRuns(context.Context, *ListRunsRequest) (*ListRunsResponse, error)
	// Stream updates for runs based on the provided filter criteria. Responses may include newly discovered
	// runs or updates to existing ones from the point of invocation.
	WatchRuns(*WatchRunsRequest, RunService_WatchRunsServer) error
	// List all actions for a given run.
	ListActions(context.Context, *ListActionsRequest) (*ListActionsResponse, error)
	// Stream updates for actions given a run. Responses may include newly discovered nested runs or updates
	// to  existing ones from the point of invocation.
	WatchActions(*WatchActionsRequest, RunService_WatchActionsServer) error
	// Stream of k8s cluster events in human readable form
	WatchClusterEvents(*WatchClusterEventsRequest, RunService_WatchClusterEventsServer) error
	// AbortAction aborts a single action that was previously created or is currently being processed by a worker.
	AbortAction(context.Context, *AbortActionRequest) (*AbortActionResponse, error)
}

// UnimplementedRunServiceServer should be embedded to have forward compatible implementations.
type UnimplementedRunServiceServer struct {
}

func (UnimplementedRunServiceServer) CreateRun(context.Context, *CreateRunRequest) (*CreateRunResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateRun not implemented")
}
func (UnimplementedRunServiceServer) AbortRun(context.Context, *AbortRunRequest) (*AbortRunResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AbortRun not implemented")
}
func (UnimplementedRunServiceServer) GetRunDetails(context.Context, *GetRunDetailsRequest) (*GetRunDetailsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRunDetails not implemented")
}
func (UnimplementedRunServiceServer) WatchRunDetails(*WatchRunDetailsRequest, RunService_WatchRunDetailsServer) error {
	return status.Errorf(codes.Unimplemented, "method WatchRunDetails not implemented")
}
func (UnimplementedRunServiceServer) GetActionDetails(context.Context, *GetActionDetailsRequest) (*GetActionDetailsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetActionDetails not implemented")
}
func (UnimplementedRunServiceServer) WatchActionDetails(*WatchActionDetailsRequest, RunService_WatchActionDetailsServer) error {
	return status.Errorf(codes.Unimplemented, "method WatchActionDetails not implemented")
}
func (UnimplementedRunServiceServer) GetActionData(context.Context, *GetActionDataRequest) (*GetActionDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetActionData not implemented")
}
func (UnimplementedRunServiceServer) ListRuns(context.Context, *ListRunsRequest) (*ListRunsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListRuns not implemented")
}
func (UnimplementedRunServiceServer) WatchRuns(*WatchRunsRequest, RunService_WatchRunsServer) error {
	return status.Errorf(codes.Unimplemented, "method WatchRuns not implemented")
}
func (UnimplementedRunServiceServer) ListActions(context.Context, *ListActionsRequest) (*ListActionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListActions not implemented")
}
func (UnimplementedRunServiceServer) WatchActions(*WatchActionsRequest, RunService_WatchActionsServer) error {
	return status.Errorf(codes.Unimplemented, "method WatchActions not implemented")
}
func (UnimplementedRunServiceServer) WatchClusterEvents(*WatchClusterEventsRequest, RunService_WatchClusterEventsServer) error {
	return status.Errorf(codes.Unimplemented, "method WatchClusterEvents not implemented")
}
func (UnimplementedRunServiceServer) AbortAction(context.Context, *AbortActionRequest) (*AbortActionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AbortAction not implemented")
}

// UnsafeRunServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RunServiceServer will
// result in compilation errors.
type UnsafeRunServiceServer interface {
	mustEmbedUnimplementedRunServiceServer()
}

func RegisterRunServiceServer(s grpc.ServiceRegistrar, srv RunServiceServer) {
	s.RegisterService(&RunService_ServiceDesc, srv)
}

func _RunService_CreateRun_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateRunRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunServiceServer).CreateRun(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RunService_CreateRun_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunServiceServer).CreateRun(ctx, req.(*CreateRunRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RunService_AbortRun_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AbortRunRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunServiceServer).AbortRun(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RunService_AbortRun_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunServiceServer).AbortRun(ctx, req.(*AbortRunRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RunService_GetRunDetails_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRunDetailsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunServiceServer).GetRunDetails(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RunService_GetRunDetails_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunServiceServer).GetRunDetails(ctx, req.(*GetRunDetailsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RunService_WatchRunDetails_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchRunDetailsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RunServiceServer).WatchRunDetails(m, &runServiceWatchRunDetailsServer{stream})
}

type RunService_WatchRunDetailsServer interface {
	Send(*WatchRunDetailsResponse) error
	grpc.ServerStream
}

type runServiceWatchRunDetailsServer struct {
	grpc.ServerStream
}

func (x *runServiceWatchRunDetailsServer) Send(m *WatchRunDetailsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _RunService_GetActionDetails_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetActionDetailsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunServiceServer).GetActionDetails(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RunService_GetActionDetails_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunServiceServer).GetActionDetails(ctx, req.(*GetActionDetailsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RunService_WatchActionDetails_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchActionDetailsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RunServiceServer).WatchActionDetails(m, &runServiceWatchActionDetailsServer{stream})
}

type RunService_WatchActionDetailsServer interface {
	Send(*WatchActionDetailsResponse) error
	grpc.ServerStream
}

type runServiceWatchActionDetailsServer struct {
	grpc.ServerStream
}

func (x *runServiceWatchActionDetailsServer) Send(m *WatchActionDetailsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _RunService_GetActionData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetActionDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunServiceServer).GetActionData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RunService_GetActionData_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunServiceServer).GetActionData(ctx, req.(*GetActionDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RunService_ListRuns_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRunsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunServiceServer).ListRuns(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RunService_ListRuns_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunServiceServer).ListRuns(ctx, req.(*ListRunsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RunService_WatchRuns_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchRunsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RunServiceServer).WatchRuns(m, &runServiceWatchRunsServer{stream})
}

type RunService_WatchRunsServer interface {
	Send(*WatchRunsResponse) error
	grpc.ServerStream
}

type runServiceWatchRunsServer struct {
	grpc.ServerStream
}

func (x *runServiceWatchRunsServer) Send(m *WatchRunsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _RunService_ListActions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListActionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunServiceServer).ListActions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RunService_ListActions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunServiceServer).ListActions(ctx, req.(*ListActionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RunService_WatchActions_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchActionsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RunServiceServer).WatchActions(m, &runServiceWatchActionsServer{stream})
}

type RunService_WatchActionsServer interface {
	Send(*WatchActionsResponse) error
	grpc.ServerStream
}

type runServiceWatchActionsServer struct {
	grpc.ServerStream
}

func (x *runServiceWatchActionsServer) Send(m *WatchActionsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _RunService_WatchClusterEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(WatchClusterEventsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(RunServiceServer).WatchClusterEvents(m, &runServiceWatchClusterEventsServer{stream})
}

type RunService_WatchClusterEventsServer interface {
	Send(*WatchClusterEventsResponse) error
	grpc.ServerStream
}

type runServiceWatchClusterEventsServer struct {
	grpc.ServerStream
}

func (x *runServiceWatchClusterEventsServer) Send(m *WatchClusterEventsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _RunService_AbortAction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AbortActionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RunServiceServer).AbortAction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RunService_AbortAction_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RunServiceServer).AbortAction(ctx, req.(*AbortActionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RunService_ServiceDesc is the grpc.ServiceDesc for RunService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RunService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "flyteidl.workflow.RunService",
	HandlerType: (*RunServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateRun",
			Handler:    _RunService_CreateRun_Handler,
		},
		{
			MethodName: "AbortRun",
			Handler:    _RunService_AbortRun_Handler,
		},
		{
			MethodName: "GetRunDetails",
			Handler:    _RunService_GetRunDetails_Handler,
		},
		{
			MethodName: "GetActionDetails",
			Handler:    _RunService_GetActionDetails_Handler,
		},
		{
			MethodName: "GetActionData",
			Handler:    _RunService_GetActionData_Handler,
		},
		{
			MethodName: "ListRuns",
			Handler:    _RunService_ListRuns_Handler,
		},
		{
			MethodName: "ListActions",
			Handler:    _RunService_ListActions_Handler,
		},
		{
			MethodName: "AbortAction",
			Handler:    _RunService_AbortAction_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WatchRunDetails",
			Handler:       _RunService_WatchRunDetails_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "WatchActionDetails",
			Handler:       _RunService_WatchActionDetails_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "WatchRuns",
			Handler:       _RunService_WatchRuns_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "WatchActions",
			Handler:       _RunService_WatchActions_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "WatchClusterEvents",
			Handler:       _RunService_WatchClusterEvents_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "idl2/workflow/run_service.proto",
}
